module PROJECT
{
	module Storage
	{
		static sStorage = nil;
		static sConnectStatus = 0;
		static sRoot = nil;
		static sFunc = nil;
		static sWatcher = nil;
	
		function DeleteWatcher()
		{
			if (sWatcher != nil)
			{
				sWatcher.remove();
				sWatcher = nil;
				sRoot = nil;
				sFunc = nil;
			}
		}
	
		function CreateWatcher(context, root, func, interval)
		{
			DeleteWatcher();
	
			sRoot = root;
			sFunc = func;
			sConnectStatus = IsConnected();
	
			sWatcher = main::menu::MScriptWatcher(context, PROJECT::OnStorageWatcher);
			sWatcher.interval = interval;
			sWatcher.count = 0;
			sWatcher.append();
		}
	
		function IsConnected()
		{
			return sStorage.isConnect();
		}
	
		function IsFormatted()
		{
			return sStorage.isFormat();
		}
	
		function Format(context)
		{
			setProgress(context, sStorage.progress);
			openProgressDialog(context, context.translate(ConnectRoot, "FORMATTING"), nil);
	
			var file = sStorage.getNewFile();
			var r = file.format(sStorage, nil);
	
			closeProgressDialog(context);
	
			if (r)
			{
			}
			else
			{
				openConfirmDialog(context, 0, context.translate(ConnectRoot, "FORMAT_FAILED"));
			}
	
			return r;
		}
	
		function GetFreeSize()
		{
			return sStorage.realFree;
		}
	
		function GetStoredPatchSize()
		{
			var file = sStorage.getNewFile();
			var r = file.dataFileSize(sStorage);
			if (r < 0)
				r = 0;

			return r;
		}
	
		function SavePatch(context, dnasInst)
		{
			setProgress(context, sStorage.progress);
			openProgressDialog(context, context.translate(ConnectRoot, "SAVING"), nil);
	
			var file = sStorage.getNewFile();
			var r = file.saveDnas(sStorage, context.translate(ConnectRoot, "SAVE_UPDATE"), dnasInst);
	
			closeProgressDialog(context);

			// Presumably #DEBUG
			if (r)
			{}
			else
			{}
			return r;
		}
	
		function Close()
		{
			sStorage = nil;
			DeleteWatcher();
		}
	
		function Open(context, path, root, func, interval)
		{
			Close();
	
			if (path.substr(0, 2) == "mc")
			{
				if (path.substr(2, 1) == "0")
				{
					sStorage = main::menu::MMemoryCardManager("MODE_SAVE_PATCH");
				}
				else
				{
					sStorage = main::menu::MMemoryCardManager("MODE_SAVE_PATCH", 1);
				}
	
				if (root != nil)
					CreateWatcher(context, root, func, interval);
			}
		}
	}

	class http
	{
		#include "../share/http.ad"
	}
	
	static gHttp = http.new();

	module svo
	{
		#include "../share/svo.ad"
	}
	
	module AutoTick
	{
		#include "../share/auto_tick.ad"
	}

	function openConfirmDialog(context, type, message, title, yes, no)
	{
		var page = context.getCommonPage("ConfirmDialog");
		if (page == nil)
			;

		return page["open"](context, type, message, title, nil, yes, no);
	}
	
	function cancelConfirmDialog(context)
	{
		var page = context.getCommonPage("ConfirmDialog");
		if (page == nil)
			;

		return page["forceCancel"](context);
	}
	
	function delayOpenConfirmDialog(context, message)
	{
		context.pushEvent(main::menu::MScriptEvent(context, PROJECT, "delay_open_cb", [message]));
	}
	
	function delay_open_cb(context, message)
	{
		main::sound.play("ok");
		openConfirmDialog(context, 0, message);
	}
	
	function openProcessDialog(context, message, func, args)
	{
		var page = context.getCommonPage("ProcessDialog");
		if (page == nil)
			;

		return page["open"](context, message, func, args);
	}
	
	function lastProcessError(context)
	{
		var page = context.getCommonPage("ProcessDialog");
		if (page == nil)
			;

		return page["last_error_code"];
	}
	
	function openProgressDialog(context, message, func)
	{
		var page = context.getCommonPage("ProgressDialog");
		if (page == nil)
			;

		return page["open"](context, message, func);
	}
	
	function closeProgressDialog(context)
	{
		var page = context.getCommonPage("ProgressDialog");
		if (page == nil)
			;

		return page["close"](context);
	}
	
	function setProgress(context, p)
	{
		var page = context.getCommonPage("ProgressDialog");
		if (page == nil)
			;

		return page["setProgress"](p);
	}
	
	function setProgressRawMode(context, mode)
	{
		var page = context.getCommonPage("ProgressDialog");
		if (page == nil)
			;

		return page["setRawMode"](mode);
	}
	
	function setProgressDialogVisible(context, f)
	{
		var page = context.getCommonPage("ProgressDialog");
		if (page == nil)
			;

		return page["setVisible"](f);
	}


	function onSystemMessage(context, message)
	{
		openConfirmDialog(context, 0, message);
	}
	
	function onDisconnectEvent(context)
	{
		openConfirmDialog(context, 0, context.translate(ConnectRoot, "DISCONNECTED"));
		restart(context);
	}
	
	function onReceiverNotLobbyEvent(context)
	{
		var pipe = main::network.im_pipe;
		pipe.put(context.translate(ConnectRoot, "RECEIVER_BUSY"));
	}
	
	function onBuddyAddRequest(context, id, name)
	{
		var mes = context.translate(ConnectRoot, "ON_BUDDY_ADD").format(name);
		openConfirmDialog(context, 1, mes);
		return;
	}
	
	function onBuddyAddResponseAccepted(context, id, name)
	{
		var mes = context.translate(ConnectRoot, "ON_BUDDY_ACCEPT").format(name);
		openConfirmDialog(context, 0, mes);
		return;
	}
	
	function onBuddyAddResponseDenied(context, id, name)
	{
		var mes = context.translate(ConnectRoot, "ON_BUDDY_DENIED").format(name);
		openConfirmDialog(context, 0, mes);
		return;
	}
	
	function onBuddyAddResponseFailed(context, id, name)
	{
		var mes = context.translate(ConnectRoot, "ON_BUDDY_FAILED").format(name);
		openConfirmDialog(context, 0, mes);
		return;
	}
	
	function onImBusy(context, msg)
	{
		context.translate(ConnectRoot, "ON_IM_BUSY");
		return;
	}
	
	static sWatcher = nil;
	
	function DeleteWatcher()
	{
		if (sWatcher != nil)
		{
			sWatcher.remove();
			sWatcher = nil;
		}
	}
	
	function CreateWatcher(context, func, interval)
	{
		DeleteWatcher();
		sWatcher = main::menu::MScriptWatcher(context, func);
		sWatcher.interval = interval;
		sWatcher.count = 0;
		sWatcher.append();
	}
	
	function GetWatcherCount()
	{
		return sWatcher.count;
	}
	
	function setCursor(context, name)
	{
		var page = context.getCommonPage("CursorRoot");
		if (page == nil)
			;

		page["setIcon"](context, name);
	}
	
	function _start_page(context, next_page)
	{
		if (next_page != nil)
		{
			if (context != nil)
			{
				if (context.transition != nil)
					context.transition.panOutIn(context);

				setCursor(context, "load");
				context.startPage(next_page);
				setCursor(context);
			}
		}
		else if (context != nil)
		{
			if (context.transition != nil)
			{
				context.transition.panOut(context);
				context.transition.syncOut(context);
			}

			context.finish();
		}

		context.flushKeyEvent();
	}
	
	function start_page(context, next_page)
	{
		context.pushEvent(main::menu::MFunctionEvent(_start_page, context, next_page));
	}
	
	function start_project(context, next_project, arg)
	{
		main::game.next_menu_project = next_project;
		if (arg != nil)
			main::game.next_menu_arg = arg;

		start_page(context, nil);
	}
	
	function start_sequence(context, next_sequence)
	{
		main::game.next_sequence = next_sequence;
		start_page(context, nil);
	}
	
	function set_last_focus(name)
	{
		last_focus = name;
	}
	
	function focus_last(root, parent)
	{
		var focused_widget = nil;
	
		if (last_focus != nil)
		{
			if (parent.defined(last_focus))
			{
				focused_widget = parent[last_focus];
				root.setFocus(focused_widget);
			}
			last_focus = nil;
		}
		return focused_widget;
	}


	static gVendor  = "";
	static gProduct = "";
	
	static gNetcnf = main::menu::MNetConf();
	
	static gNetMode = "WAN";

    function OnStorageWatcher(context)
    {
        if (Storage::sConnectStatus != Storage::IsConnected())
        {
            var event = main::menu::MScriptEvent(context, Storage::sRoot, Storage::sFunc);
            context.pushEvent(event);
        }
    }

    function GetInterface()
    {
        var cnt = main::network.getInterfaceCount();
        for (var i = 0; i < cnt; i++)
        {
            var [vendor, product] = main::network.getInterfaceVendorProduct(i);

            if (vendor.substr(0, 3) == "SCE" && product.substr(0, 8) == "Ethernet")
            {
                gVendor  = vendor;
                gProduct = product;
                return true;
            }
        }

        return false;
    }

    function onLoad(context)
    {
        if (!main::network.isInterfaceInitialized())
            main::network.initializeInterface();

        if (main::game.next_menu_arg == "LAN")
            gNetMode = "LAN";

        main::network.setCallbackModule(PROJECT);
        main::network.inLobby(1);

        main::sound.load();
        main::menu::LoadKanjiFont("unicode.kf");

        context.createRenderContext(1);

        var render_context = context.getRenderContext(0);
        main::menu::MMovieFace::initialize(render_context);

        render_context.transition = main::menu::MCrossTransition();
        render_context.transition.panIn(render_context);

        gNetcnf.InitYncf();

        var arg = main::game.next_menu_arg;
        if (arg != nil && arg == "config")
        {
            main::game.next_menu_arg = "";
            render_context.startPage(ConfigRoot);
        }
        else
            render_context.startPage(ConnectRoot);
    }

    static restart_flg = false;

    function onUnload(context)
    {
        main::menu::MMovieFace::terminate();
        main::sound.unload();
        main::menu::UnloadKanjiFont();

        main::network.inLobby(false);
        main::network.setCallbackModule(nil);

        if (restart_flg)
            downNetwork();
    }

    function downNetwork()
    {
        if (main::network.isRTIMEInitialized())
            main::network.terminateRTIME();

        main::network.terminateNetwork();
        main::network.network_enable = false;
    }

    function setFadeActor(widget)
    {
        var actor = main::menu::MFadeActor(widget, 1.0);
        actor.repeat = true;
        actor.period = 0.25;
        widget.actor = actor;
    }

    function restart(context)
    {
        restart_flg = true;
        main::network.network_enable = false;
        main::game.next_menu_project = main::game.major_menu_project;
        start_page(context, nil);
    }

}
