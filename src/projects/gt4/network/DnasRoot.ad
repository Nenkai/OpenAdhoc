module PROJECT::ROOT
{
	static sDnas = nil;
	static sSkip = nil;
	static sInitializing = nil;

	function setBarActor(widget)
	{
		widget.x = -widget.w;
	
		var actor = main::menu::MMoveActor(widget, 640.0, widget.y);
		widget.actor = actor;
	
		widget.actor.ratio = 0.01;
		widget.actor.repeat = 1;
		widget.actor.flip = 0;
		widget.actor.linear = true;
		widget.actor.out = false;
	
		widget.actor.warp();
		widget.actor.out = true;
	}
	
	setBarActor(bar);

	function StrError(context, errno)
	{
		var showFooter = false;
		var str;
	
		switch (errno)
		{
			case -101:
				str = context.translate(DnasRoot, "SS_SERVER_BUSY");
				break;
			
			case -102:
				str = context.translate(DnasRoot, "SS_BEFORE_SERVICE");
				showFooter = true;
				break;
			
			case -103:
				str = context.translate(DnasRoot, "SS_OUT_OF_SERVICE");
				showFooter = true;
				break;
			
			case -104:
				str = context.translate(DnasRoot, "SS_END_OF_SERVICE");
				showFooter = true;
				break;
			
			case -105:
				str = context.translate(DnasRoot, "SS_SESSION_TIME_OUT");
				break;
			
			case -106:
				str = context.translate(DnasRoot, "SS_INVALID_SERVER");
				var showFooter = true;
				break;
			
			case -107:
				str = context.translate(DnasRoot, "SS_INTERNAL_ERROR");
				var showFooter = true;
				break;
			
			case -108:
				str = context.translate(DnasRoot, "SS_EXTERNAL_ERROR");
				var showFooter = true;
				break;
			
			case -401:
			case -404:
				str = context.translate(DnasRoot, "SS_INVALID_HW");
				var showFooter = true;
				break;
			
			case -402:
			case -403:
				str = context.translate(DnasRoot, "SS_INVALID_MEDIA");
				var showFooter = true;
				break;
			
			case -601:
				str = context.translate(DnasRoot, "GLUE_ABORT");
				break;
			
			case -602:
				str = context.translate(DnasRoot, "NET_PROXY");
				break;
			
			case -617:
			case -603:
				str = context.translate(DnasRoot, "NET_TIMEOUT");
				break;
			
			case -612:
				str = context.translate(DnasRoot, "DNS_TRY_AGAIN");
				break;
			
			case -611:
			case -613:
			case -614:
				str = context.translate(DnasRoot, "DNS_COMMON");
				break;
			
			case -615:
				str = context.translate(DnasRoot, "DNS_OTHERS");
				break;
			
			case -610:
			case -616:
			case -618:
			case -619:
			case -620:
			case -626:
				str = context.translate(DnasRoot, "NET_SERVER");
				break;
			
			case -621:
			case -622:
			case -623:
			case -624:
			case -625:
				str = context.translate(DnasRoot, "NET_COMM");
				break;
			
			default:
				str = context.translate(DnasRoot, "OTHER");
				if (errno <= -800)
					showFooter = true;
				break;
			
		}
	
		if (showFooter)
		{
			footer.visible = true;
			footer["text"].text = context.translate(DnasRoot, "footer");
		}
	
		return str;
	}

	function OnFrame(context)
	{
		if (sSkip)
			return;
	
		if (sDnas.IsDone())
		{
			var error = sDnas.GetLastError();
		
			if (!error)
			{
				main::network.setDnasSignature(sDnas.GetId());
				DeleteWatcher();
				start_page(context, EntryRoot);
			}
			else
			{
				message["text"].text = "%d: %s".format(error, StrError(context, error));
				DeleteWatcher();
				bar.actor = nil;
				logo.visible = false;
			}
		}
	}

	function GetPassPhrase(code, ver)
	{
		var a = [];
	
		if (code == "dna")
		{
			if (ver == "beta")
			{
				a.push(64);
				a.push(188);
				a.push(9);
				a.push(213);
				a.push(83);
				a.push(53);
				a.push(156);
				a.push(224);
			}
		}
		else if (code == "dne")
		{
			if (ver == "beta")
			{
				a.push(231);
				a.push(154);
				a.push(175);
				a.push(47);
				a.push(9);
				a.push(209);
				a.push(231);
				a.push(153);
			}
		}
		else if (code == "dni")
		{
			if (ver == "beta")
			{
				a.push(173);
				a.push(114);
				a.push(184);
				a.push(127);
				a.push(95);
				a.push(155);
				a.push(177);
				a.push(178);
			}
		}
	
		return a;
	}

	function OnInitialize(context)
	{
		var code = main::menu::MSystem::GetDnasCode();
		var ver  = main::menu::MSystem::GetVersionBranch();
	
		var filename = "/dnas/auth_" + code + "_" + ver + ".dat";
		var netconf = main::game.option.netconf;
		var success = false;
	
		if (netconf.use_proxy)
		{
			success = sDnas.Initialize(
				filename,
				GetPassPhrase(code, ver),
				netconf.proxy,
				netconf.proxy_port
			);
		}
		else
		{
			success = sDnas.Initialize(
				filename,
				GetPassPhrase(code, ver)
			);
		}
	
		if (success)
		{
			success = sDnas.RequestId();
	
			if (success)
			{
				sSkip = false;
				CreateWatcher(context, OnFrame, 2);
			}
		}
	
		if (!success)
		{
			var error = sDnas.GetLastError();
			message["text"].text = "%d: %s".format(error, StrError(context, error));
		}
	
		sInitializing = nil;
	}

	function onInitialize(context)
	{
		sInitializing = true;
		logo.visible = true;
		footer.visible = false;
		mark::TextFace.text = context.translate(DnasRoot, "notice");
		message["text"].text = context.translate(DnasRoot, "AUTH");
		tip::TextFace.text = context.translate(ConnectingRoot, "TOOLTIP|Cancel");
		sDnas = main::menu::MDnas();
		var event = main::menu::MScriptEvent(context, DnasRoot, "OnInitialize");
		context.pushEvent(event);
	}
	
	function onFinalize(context)
	{
		DeleteWatcher();
		sDnas = nil;
		sSkip = nil;
		sInitializing = nil;
	}
	
	function onCancel(context)
	{
		if (sInitializing != nil)
			return EVENTRESULT_FILTER;
	
		main::sound.play("cancel");
		sSkip = true;
		DeleteWatcher();
		sDnas.Abort();
		quit(context);
		sSkip = false;
		return EVENTRESULT_FILTER;
	}
}