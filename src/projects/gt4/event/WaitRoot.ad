module PROJECT::ROOT
{
	static watcher = nil;
	static joined = false;
	static count = 10 * 15;

	function onInitialize(context)
	{
		var event = main::menu::MScriptEvent(context, ROOT, "auto_matching");
		context.pushEvent(event);
		count = 10 * 15;
	}
	
	function onFinalize(context)
	{
		if (watcher != nil)
		{
			watcher.remove();
			watcher = nil;
		}
	}


	function showMessage(message)
	{
		Message::tooltip.value = message;
	}
	
	function expected_member_max()
	{
		var option = main::game.option;
		return option.LAN_auto_matching_num + (option.LAN_monitor_num - 1);
	}


	function auto_matching(context)
	{
		import main::network;
	
		var option = main::game.option;
		var id = network.getAvailableGameIdLAN(1, 1000);
	
		if (id < 0)
		{
			var member_max = expected_member_max();
			var res = network.gcreateLAN(
				option.LAN_machine_name,
				"default_gf",
				member_max,
				option.LAN_machine_name
			);
	
			if (!res)
			{
				showMessage("create failed");
				context.startPage(GameRoot);
				return;
			}
	
			showMessage("creating..done.");
		}
		else
		{
			showMessage("joinning...");
			var res = network.gjoinLAN(
				game_id,
				main::game.option.LAN_machine_name
			);
	
			if (!res)
			{
				showMessage("join failed");
				context.startPage(GameRoot);
				return;
			}
	
			showMessage("join succeeded");
		}
	
		watcher = main::menu::MScriptWatcher(context, ROOT, "onTick");
		watcher.interval = 15;
		watcher.append();
	
		network.raceMenuNotifyStyle("play");
		network.raceMenuNotifyTarget("");
		network.raceMenuNotifySequence(1);
	}


	function onTick(context)
	{
		import main::network;
	
		if (count > 0)
			count--;
		else if (count == 0)
		{
			network.raceMenuNotifySequence(2);
		}
	
		Count::text.text = "%d".format(count / 15);
	
		var member_num = network.getMemberNumLAN();
		var my_index = network.raceMenuMyIndex();
	
		var end_flg = true;

		for (var i = 0; i < member_num; i++)
		{
			if (network.raceMenuPeekSequence(i) < 2)
			{
				end_flg = false;
				break;
			}
		}
	
		if (end_flg)
		{
			context.transition.panOutIn(context);
			context.transition.syncOut(context);
			context.startPage(CourseRoot);
		}
	}
}