module PROJECT::MComponent::SetupPanel::SetupWindow
{
	method doColorize()
	{
        var title = MComponent::SetupPanel::SetupWindow::Title;
        var slider;

        if (MComponent::SetupPanel.defined("Slider"))
            slider = MComponent::SetupPanel::Slider;

        var pulldown;
        if (MComponent::SetupPanel.defined("Pulldown"))
            pulldown = MComponent::SetupPanel::Pulldown;

        var text_input;
        if (MComponent::SetupPanel.defined("TextInput"))
            text_input = MComponent::SetupPanel::TextInput;

        var number_input;
        if (MComponent::SetupPanel.defined("NumberInput"))
            number_input = MComponent::SetupPanel::NumberInput;

        var vacant;
        if (MComponent::SetupPanel.defined("Vacant"))
            vacant = MComponent::SetupPanel::Vacant;

        var bottom_spacer;
        if (MComponent::SetupPanel.defined("BottomSpacer"))
            bottom_spacer = MComponent::SetupPanel::BottomSpacer;

        var buttons;
        if (MComponent::SetupPanel.defined("Buttons"))
            buttons = MComponent::SetupPanel::Buttons;

        var i = 0;
		var it = self.first_window;
	
		while (it != nil)
		{
			var p = it.__prototype__;
	
			if (p == title)
			{
				continue;
			}
			
			if (p == buttons)
			{
				continue;
			}
	
			if (it.visible)
			{
				if (p == bottom_spacer)
				{
					var ii = (i % 2) + 7;
					var c = main::menu::MColorObject();
					c.color_index = ii;
					it.bspacer.setColor(c);
				}
				else if (p == pulldown || p == text_input || p == number_input || p == slider || p == vacant)
				{
					var ii = ((i + 1) % 2) + 7;
					var c = main::menu::MColorObject();
					c.color_index = ii;
					it.bg.setColor(c);
					i++;
				}
			}

			it = it.next_window;
		}
	}

	method onLoad(context)
	{
		doColorize();
	}
}

module PROJECT::MComponent::SetupPanel::Buttons::OK::bgf
{
	method __copy_init__()
	{
		self.actor = main::menu::MFadeActor(self, 1.0);
		self.actor.period = 0.25;
		self.actor.repeat = 1;
	}
}

module PROJECT::MComponent::SetupPanel::Buttons::CancelOK::No::bgf
{
	method __copy_init__()
	{
		self.actor = main::menu::MFadeActor(self, 1.0);
		self.actor.period = 0.25;
		self.actor.repeat = 1;
	}
}

module PROJECT::MComponent::SetupPanel::Buttons::CancelOK::Yes::bgf
{
	method __copy_init__()
	{
		self.actor = main::menu::MFadeActor(self, 1.0);
		self.actor.period = 0.25;
		self.actor.repeat = 1;
	}
}

module PROJECT::MComponent::Buttons::oval
{
	method decide(context)
	{
		var bgf = self.bgf;
		bgf.actor.period = 0.05;
		context.sync(0.5);
		bgf.actor.period = 0.25;
		bgf.actor.out = false;
		bgf.actor.warp();
	}
}

module PROJECT::MComponent::Buttons::oval::bgf
{
	method __copy_init__()
	{
		self.actor = main::menu::MFadeActor(self, 1.0);
		self.actor.period = 0.25;
		self.actor.repeat = 1;
	}
}

module PROJECT
{
	#include "storage.ad"
	class http
	{
		#include "../share/http.ad"
	}
	static gHttp = http.new();
	module svo
	{
		#include "../share/svo.ad"
	}
	module AutoTick
	{
		#include "../share/auto_tick.ad"
	}
	#include "../share/dialog.ad"

	function terminateRTIME()
	{
		if (main::network.isRTIMEInitialized())
			main::network.terminateRTIME();
	}
	
	function downNetwork()
	{
		terminateRTIME();
		main::network.terminateNetwork();
		main::network.network_enable = false;
	}

	#include "../share/online_event.ad"
	#include "../share/online_error.ad"
	#include "../share/online_util.ad"
	#include "../share/online_xml.ad"
	#include "../share/watcher_util.ad"
	#include "../share/memorycard.ad"
	#include "../share/page_util.ad"
	#include "../share/actor.ad"
	#include "../share/shot_screen.ad"
	
	static message_project = nil;
	static gVendor = "";
	static gProduct = "";
	static gNetcnf = main::menu::MNetConf();
	static gNetMode = "WAN";

	function OnStorageWatcher(context)
	{
		if (Storage::sConnectStatus != Storage::IsConnected())
		{
			var event = main::menu::MScriptEvent(context, Storage::sRoot, Storage::sFunc);
			context.pushEvent(event);
		}
	}
	
	function GetInterface()
	{
		var cnt = main::network.getInterfaceCount();
		
	
		for (var i = 0; i < cnt; i++)
		{
			|var vendor, var product| = main::network.getInterfaceVendorProduct(i);
	
			if (vendor.substr(0, 3) == "SCE" && product.substr(0, 8) == "Ethernet")
			{
				gVendor = vendor;
				gProduct = product;
				return true;
			}
		}
	
		return false;
	}


	function isAutoMenu()
	{
		return false;
	}

	function onLoad(context)
	{
		if (!main::network.isInterfaceInitialized())
			main::network.initializeInterface();
	
		if (main::game.next_menu_arg == "LAN")
			gNetMode = "LAN";
	
		main::network.setCallbackModule(NetworkProject);
		main::network.setSystemEventEnable(1);
		main::network.inLobby(1);
	
		main::sound.load();
	
		message_project = main::manager.loadProject("/projects/message/message");
	
		main::menu::LoadKanjiFont("unicode.kf");
	
		context.createRenderContext(1);
		var render_context = context.getRenderContext(0);
	
		main::menu::MMovieFace::initialize(render_context);
	
		render_context.transition = main::menu::MCrossTransition();
		render_context.transition.panIn(render_context);
	
		gNetcnf.InitYncf();
	
		var arg = main::game.next_menu_arg;
	
		if (arg != nil && arg == "config")
		{
			main::game.next_menu_arg = "";
			render_context.startPage(ConfigRoot);
		}
		else if (main::game.major_menu_page == "")
			render_context.startPage(ConnectRoot);
		else
		{
			render_context.startPage(NetworkProject[main::game.major_menu_page]);
			main::game.major_menu_page = "";
		}
	}

	static restart_flg = false;
	static restart_all_flg = false;
	
	function onUnload(context)
	{
		main::menu::MMovieFace::terminate();
		main::sound.unload();
		main::manager.unloadProject(message_project);
		main::menu::UnloadKanjiFont();
	
		main::network.inLobby(0);
		main::network.setCallbackModule(nil);
	
		if (restart_flg)
			terminateRTIME();
	
		if (restart_all_flg)
			downNetwork();
	}

	// Throws "Static subroutine name 'setFadeActor' is already defined"
	//function setFadeActor(widget)
	//{
	//	var actor = main::menu::MFadeActor(widget, 1.0);
	//	actor.repeat = 1;
	//	actor.period = 0.25;
	//	widget.actor = actor;
	//}
	
	function restart(context)
	{
		if (!restart_flg)
		{
			restart_flg = true;
			main::network.setSystemEventEnable(0);
			main::game.major_menu_project = "online";
			main::game.major_menu_page = "EntryRoot";
			start_project(context, "network");
		}
	}
	
	function quit(context)
	{
		if (!restart_all_flg)
		{
			restart_all_flg = true;
			main::network.setSystemEventEnable(0);
			main::game.major_menu_project = "arcade";
			main::game.major_menu_page = "";
			start_project(context, "arcade");
		}
	}


	function isRestarted()
	{
		return restart_flg || restart_all_flg;
	}
	
	function saveAuto(context, root, end_func)
	{
		main::game.major_menu_project = "online";
		main::game.major_menu_page = "";
		context.pushEvent(main::menu::MScriptEvent(context, NetworkProject, "doAutoSave", [root, end_func]));
	}
	
	function doAutoSave(context, root, end_func)
	{
		openProgressDialog(context, context.translate(NetworkProject, "MemoryCard", "now_saving"));
		var r = autoSave(context, nil);
		closeProgressDialog(context);
		if (end_func != nil)
			end_func(context, r);
	}
	
	function SavePatch(context, dnasInst, datasize)
	{
		var manager = main::menu::MMemoryCardManager("MODE_SAVE_PATCH");
		setProgress(context, manager.progress);
		var result = false;
		startMcWatcher(context, manager);
		if (!_SavePatch(context, manager, dnasInst, datasize, result))
			;
		else
			endMcWatcher();
	
		return result;
	}

	function _SavePatch(context, manager, dnasInst, datasize, resultRef)
	{
		var file = manager.getNewFile();
		manager.isChanged();
	
		if (!manager.isConnect())
		{
			if (!openMcDialog(context, 1, translateMc(context, "no_memory_card_retry?").format(1), nil, translateMc(context, "save cancel"), translateMc(context, "retry")))
			{
				return false;
			}
			return true;
		}
	
		if (!manager.isFormat())
		{
			print("unformatted");
			if (openMcDialog(context, 3, translateMc(context, "no_gt4_data_retry?").format(1),nil))
			{
				return false;
			}
			return true;
		}
	
		var r = file.isExist(manager);
	
		if (r == 0)
		{
			print("there is gt4 data");
	
			var filesize = file.dataFileSize(manager);
			print "size data %{datasize}, file %{filesize}, free %{manager.realFree}\n";
	
			var kfree = manager.realFree;
			kfree += (filesize + 1023) / 1024;
	
			var ksize = (datasize + 1023) / 1024;
	
			if (kfree < ksize)
			{
				openConfirmDialog(context,2,context.translate(EntryRoot, "NO_SPACE").format(ksize - kfree));
				return true;
			}
		}
		else if (r == 1)
		{
			print("no gt4 data");
			if (openMcDialog(context, 3, translateMc(context, "no_gt4_data_retry?").format(1), nil))
			{
				return false;
			}
			return true;
		}
		else
		{
			openConfirmDialog(context, 2, translateMc(context, "access_error"));
			return true;
		}
	
		print("saving...");
	
		openProgressDialog(context, translateMc(context, "now_saving"));
	
		r = file.saveDnas(manager, context.translate(ConnectRoot, "SAVE_UPDATE"), dnasInst);
	
		closeProgressDialog(context);
	
		if (r)
		{
			*resultRef = true;
		}
		else
		{
			*resultRef = false;
		}
	
		return true;
	}
}