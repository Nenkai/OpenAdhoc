module PROJECT::ROOT
{

	static bestlapmode = false;
	
	function onInitialize(context)
	{
		ROOT.visible = true;
	
		enterPage(context, ROOT, hidden::Title::title.doCopy());
	
		var newitem = hidden::NewItem.doCopy();
		newitem.x = 0;
		newitem.y = 0;
	
		ROOT["Common"]["AppendBG"].appendChild(context, newitem);
	
		selectFolder_ = 0; /* From project */
		hidden.visible = false;
	
		hideReplayItem(ROOT);
	
		hidden::ReplayItem::label.text = "";
	
		init(context);
	
		ROOT["Common"]["Command"]["DeleteMode"].visible = true;
	
		Template::setExitActivate(commandExit);
		Template::setOptionActivate(commandOption);
	}
	
	function onFinalize(context)
	{
		leavePage(context, ROOT);
	}
	
	function onCancel(context)
	{
		main::sound.play("cancel");
		exit(context);
		return EVENTRESULT_FILTER;
	}
	
	function exit(context)
	{
		start_page(context, nil);
	}
	
	function init(context)
	{
		context.cursor_visible = true;
	
		initCommon(context, ROOT);
		initFolders(context);
		initCommands(context);
		initList(context);
	
		setDragable(false);
		setAliasFileMode(false);
		setHasNewFile(true);
	
		manager = nil;
	
		var slot = currentSlot();
		var mode = main::game.next_menu_arg;
	
		print("mode == %{mode}\n");
	
		manager = main::menu::MMemoryCardManager(mode, slot);
	
		bestlapmode = (mode == "MODE_SAVE_BESTLAP_REPLAY");
	
		var file = getFile(0);
		var racemode = file.racemode;
		var submode = file.racesubmode;
	
		print("mode = %{racemode}, %{submode}\n");
	
		var modestr = context.translate(ROOT, "RaceModeName", racemode);
	
		if (submode >= 0)
			modestr += submode.toString();
	
		file.title = modestr;
	
		var newItem = hidden::ReplayItem.doCopy();
		newItem.can_focus = false;
	
		setupWidgetReplay(context, 0 /* i */, newItem /* w */);
	
		var saveItem = ROOT["Common"]["AppendBG"]["NewItem"]["SaveItem"];
		saveItem.appendChild(context, newItem);
	
		ROOT.setFocus(getList());
	
		manager.start();
	}
	
	
	function currentSlot()
	{
		return main::game.option.replay_memory_card_slot;
	}
	
	static folders_ = [];
	
	function initFolders(context)
	{
		initFolderCommon(context, folders_);
	}
	
	function commandDummy(context)
	{
		print("dummy");
	}
	
	function commandOption(context)
	{
		print("option!");
	
		var slot = currentSlot();
	
		ReplaySlotDialog::open(context);
	
		if (slot != currentSlot())
			init(context);
	}
	
	function commandExit(context)
	{
		print("exit");
		exit(context);
	}
	
	function initCommands(context)
	{
	}
	
	function initList(context)
	{
		initListCommon(context, hidden::ReplayItem);
	}
	
	function setupWidget(context, i, w)
	{
		w["label"].text = context.translate(
			ROOT,
			(i == 0) ? "create new file" : "overwrite"
		);
	
		if (i == 0)
			return true;
	
		setupWidgetReplay(context, i, w); // BUG?: no return
	}
}

module PROJECT::ROOT::Scroll::List
{
	function onActivate(context, event)
	{
		var focus_index = getList().focus_index;
	
		if (focus_index < 0 || getFileCount() < focus_index)
			return EVENTRESULT_STOP;
	
		var newfile = manager.getNewFile();
		var file = getFile(focus_index);
	
		if (file == nil || newfile == nil)
			return EVENTRESULT_STOP;
	
		var f_title = file.title;
	
		manager.requestPause();
		main::sound.play("ok");
	
		print("openEntry!");
	
		ROOT.visible = false;
	
		if (EntryRoot::open(context, 1, newfile.title))
		{
			manager.waitPause();
			ROOT.visible = true;
	
			newfile.title = EntryRoot::getText();
	
			var r = saveVariousDataForSelector(
				context,
				manager,
				bestlapmode ? "best_replay" : "full_replay",
				currentSlot(),
				file,
				newfile
			);
	
			if (r != 0)
			{
				clearList(context);
				manager.clear();
			}
		}
	
		print("closeEntry!");
	
		ROOT.visible = true;
		manager.restart();
		return EVENTRESULT_STOP;
	}
	
	function onKeyPress(context, event, item)
	{
		return PROJECT::onListKeyPress(context, event);
	}
	
	function onKeyRelease(context, event)
	{
		PROJECT::onListKeyRelease(context, event);
		return EVENTRESULT_CONTINUE;
	}
}