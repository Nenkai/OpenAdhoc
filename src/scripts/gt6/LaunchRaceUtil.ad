

//---------------------------------------------------------------------------------------
// LaunchRaceUtil.ad
//
// utility module for organizing and starting race events.
// 
//---------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------
// module
//---------------------------------------------------------------------------------------

module LaunchRaceUtil
{
    class Data
    {
        attribute context;
        attribute gp;
        attribute player_cp_list;
        attribute player_dp_list;
        attribute bspec_dp_list;
        attribute online_id_list;

        method __init__(c, gp, pcl, pdl, bdl, oil)
        {
            self.context = c;
            self.gp = gp;
            self.player_cp_list = pcl;
            self.player_dp_list = pdl;
            self.bspec_dp_list = bdl;
            self.online_id_list = oil;
        }
    }

    static launch_data = nil;

    function getEventInfo(gp)
    {
        var bg = "NONE";
        var flag = "NONE";
        var event_text = "";
        var bgm_code = "quick_before";
        var logo = "";
        
        switch (gp.event.game_mode)
        {
            case gtengine::GameMode::SINGLE_RACE:
                bg = "ARCADE";
                flag = "white";
                event_text = manager.translate("RaceTypeName", "GameMode_SINGLE_RACE");
                break;

            case gtengine::GameMode::ONLINE_SINGLE_RACE:
                bg = "EVENT_RACE";
                flag = "white";
                event_text = gp.event.information.title.getText();
                break;

            case gtengine::GameMode::ONLINE_TIME_ATTACK:
                bg = "ARCADE";
                flag = "black";

                if (gp.launch_context == gtengine::LaunchContext::ACADEMY)
                {
                    bg = "ACADEMY";
                    flag = "academy";
                }
                else if (gp.event.begin_date != gp.event.end_date)
                {
                    bg = "EVENT_RACE";
                    flag = "black";
                }

                event_text = gp.event.information.title.getText();
                bgm_code = "quick_before_timetrial";
                break;

            case gtengine::GameMode::ONLINE_DRIFT_ATTACK:
                bg = "EVENT_RACE";
                flag = "black";
                event_text = gp.event.information.title.getText();
                break;

            case gtengine::GameMode::EVENT_RACE:
                bg = "EVENT_RACE";
                flag = "white";
                event_text = gp.event.information.title.getText();
                bgm_code = getGT6CareerModeBridgeBGMCode(gp);
                break;

            case gtengine::GameMode::TIME_ATTACK:
                bg = "ARCADE";
                flag = "black";
                event_text = manager.translate("RaceTypeName", "GameMode_TIME_ATTACK");
                bgm_code = "quick_before_timetrial";
                break;

            case gtengine::GameMode::DRIFT_ATTACK:
                bg = "ARCADE";
                flag = "black";
                event_text = manager.translate("RaceTypeName", "GameMode_DRIFT_ATTACK");
                break;

            case gtengine::GameMode::ONLINE_BATTLE:
                bg = "QUICK_MATCH";
                flag = "white";
                event_text = gp.event.information.title.getText();
                break;

            case gtengine::GameMode::TUTORIAL:
                SoundUtil::MenuBGMCrossfadeGroup("title", 0f, 0f);
                break;

            case gtengine::GameMode::LICENSE:
                bg = "EVENT_RACE";
                flag = "license";
                event_text = gp.event.information.title.getText();
                bgm_code = "quick_before_license";
                break;

            case gtengine::GameMode::ONLINE_ROOM:
                bg = "ONLINE_ROOM";
                flag = "white";
                event_text = gp.online_room.comment;
                break;

            case gtengine::GameMode::FREE_RUN:
                bg = "ARCADE";
                flag = "black";
                event_text = manager.translate("RaceTypeName", "GameMode_FREE_RUN");
                bgm_code = "quick_before_timetrial";
                break;

            case gtengine::GameMode::MISSION:
                bg = "EVENT_RACE";
                flag = "black";
                event_text = gp.event.information.title.getText();
                bgm_code = getGT6CareerModeBridgeBGMCode(gp);

                if (gp.event.track.course_code == gtengine::MSpecDB::getCourseCode("goodwood_fos"))
                    bg = "GOODWOOD";

                if (gp.event.track.course_code == gtengine::MSpecDB::getCourseCode("goodwood_fos_2014"))
                    bg = "GOODWOOD2014";

                if (gp.event.track.course_code == gtengine::MSpecDB::getCourseCode("goodwood_fos_2015"))
                    bg = "GOODWOOD2015";
                break;
                
            case gtengine::GameMode::COFFEE_BREAK:
                bg = "EVENT_RACE";
                flag = "coffee";
                event_text = gp.event.information.title.getText();
                bgm_code = "quick_before_coffeebreak";
                break;
            
            case gtengine::GameMode::SPLIT_BATTLE:
                bg = "ARCADE";
                flag = "white";
                event_text = manager.translate("RaceTypeName", "GameMode_SPLIT_BATTLE");
                break;

            case gtengine::GameMode::GPS_REPLAY:
                bg = "ARCADE";
                flag = "white";
                event_text = manager.translate("RaceTypeName", "GameMode_GPS_REPLAY");
                break;

            case gtengine::GameMode::ARCADE_STYLE_RACE:
                bg = "TIME_RALLY";
                flag = "white";
                event_text = gp.event.information.title.getText();
                bgm_code = "quick_before_arcadestyle";
                break;

            case gtengine::GameMode::PRACTICE:
                bg = "ARCADE";
                flag = "black";
                event_text = gp.event.information.title.getText();
                bgm_code = "quick_before_timetrial";
                break;

            case gtengine::GameMode::COURSE_EDIT:
                bg = "ARCADE";
                flag = "black";
                event_text = manager.translate("RaceTypeName", "GameMode_COURSE_EDIT");
                bgm_code = "quick_before_timetrial";
                logo = "course";
                break; 
        }

        if (!gp.event.replay.isExpected() && 
            gp.event.track != nil && 
            gp.event.track.course_code != nil &&
            gp.event.track.course_code != gtengine::MSpecDB::NO_CODE)
        {
            var info = gtengine::MSpecDB::getCourseRow(gp.event.track.course_code);
            var gravity = info.AccelerationOfGravity;
            if (gravity != nil && gravity < 9.7f)
            {
                bg = "MOON";
                bgm_code = "quick_before_moon";
            }
        }

        return [bg, flag, event_text, bgm_code, logo];
    }

    function launch(context, gp, player_cp_list, player_dp_list, bspec_dp_list, online_id_list)
    {
        launch_data = Data(context, gp, player_cp_list, player_dp_list, bspec_dp_list, online_id_list);
        
        var no_bridge = gp.event.play_style.no_quickmenu;
        if (gp.event.replay.isExpected())
            no_bridge = true;

        if (gp.event.game_mode == gtengine::GameMode::TUTORIAL)
            no_bridge = true;

        if (gp.keep_sequence)
            return;

        var transition;
        if (!no_bridge)
        {
            var loading_race_root;
            if (main::cursor_project.KamishibaiInfo != nil)
            {
                loading_race_root = main::cursor_project.KamishibaiRoot;
                loading_race_root.setup(main::cursor_project.KamishibaiInfo);
                main::cursor_project.KamishibaiInfo = nil;
            }
            else
            {
                loading_race_root = main::cursor_project.LoadingRaceRoot;
                var [bg, flag, event_text, bgm_code, logo] = getEventInfo(gp);

                if (bgm_code != nil)
                    SoundUtil::MenuBGMCrossfadeGroup(bgm_code, 0f, 0f, SoundUtil::REPEAT_TRACK);

                var course_code = gp.event.track.course_code;
                if (course_code == gtengine::COURSE_CODE_GENERATED)
                {
                    if (gp.event.track.edit_data != nil)
                        course_code = gtengine::getSceneryCourseCode(gp.event.track.edit_data);
                }

                loading_race_root.setup(course_code, bg, flag, event_text, logo);
            }

            main::cursor_project.setBridgeRoot(loading_race_root);
            transition = loading_race_root;
        }
        else
            transition = main::cursor_project.GTLogoTransition;

        SequenceUtil::startSequence(context, GameSequence::RACE, transition);
    }

    function setupWeather(rp)
    {
        if (rp.weather_base_celsius != gtengine::MRaceParameter().weather_base_celsius)
            ;
        else
            rp.setTemperatureFromCourseInfo();
        rp.setup();
    }

    function setupWeatherFix(rp)
    {
        if (rp.weather_base_celsius != gtengine::MRaceParameter().weather_base_celsius)
            ;
        else
            rp.setTemperatureFromCourseInfo();
        
        var course_code = rp.course_code;
        if (course_code.isInstanceOf(gtengine::MCourseGenerateData))
            course_code = gtengine::getSceneryCourseCode(course_code);
        
        var WeatherValue = main::SPECDB.executeQuery1R1C("SELECT WeatherValue FROM COURSE WHERE ID=?", [course_code]);
        rp.decisive_weather = gtengine::DecisiveWeather::NONE;
        rp.weather_no_schedule = false;
        rp.weather_point_num = 1;
        rp.weather_value0 = WeatherValue;
        rp.weather_accel100 = 0;
        rp.initial_retention10 = -1;
    }

    function setupDateTime(rp)
    {
        if (rp.datetime.getBySecond() != gtengine::MRaceParameter().datetime.getBySecond())
            ;
        else
        {
            var course_code = rp.course_code;
            if (course_code == gtengine::COURSE_CODE_GENERATED)
                course_code = rp.scenery_code;

            var cinfo = gtengine::MSpecDB::getCourseRow(course_code);
            if (cinfo != nil)
            {
                var time = pdistd::MTime();
                time.year = 2010;
                time.month = 4;
                time.day = 2;
                time.hour = 12;
                time.minute = 0;
                time.second = 0;

                if (cinfo.StartDateTime > 0)
                {
                    var start_datetime_sec = cinfo.StartDateTime;
                    time.setForCourse(cinfo.StartDateTime);
                }

                rp.datetime = time;
                rp.time_progress_speed = cinfo.TimeProgressSpeed;
            }
        }
    }

    function setup_start_position(gp)
    {
        var event = gp.event;
        var rp = event.race_parameter;
        var entry_set = event.entry_set;
        var use_initial_position = 0;
    
        for (var i = 0; i < entry_set.entries.size; ++i)
        {
            var entry = entry_set.entries[i];
            if (entry.available_initial_position)
            {
                use_initial_position = 2;
                rp.setLaunchPosition(i, entry.initial_position);
            }
            else
            {
                rp.setLaunchPosition(i, 0);
            }

            if (entry.initial_velocity > 0)
                rp.setLaunchSpeed(i, entry.initial_velocity);
            else
                rp.setLaunchSpeed(i, 0);

            rp.setDelayStartSecond(i, entry.delay);
            rp.setStartTypeSlot(i, entry.start_type);
        }

        if (!use_initial_position && entry_set.entry_generate.use_rolling_start_param)
        {
            use_initial_position = 1;
            rp.setLaunchPosition(0, entry_set.entry_generate.rolling_start_v);
            rp.setLaunchPosition(1, entry_set.entry_generate.gap_for_start_rolling_distance);
        }

        if (rp.start_type == gtengine::StartType::ROLLING2)
            rp.rolling_player_grid = entry_set.entry_generate.player_pos;
        rp.useLaunchData(use_initial_position);
    }

    function setupEntryStatus(gp)
    {
        setup_start_position(gp);
        var entry_set = gp.event.entry_set;
        var entry_generate = entry_set.entry_generate;

        if (entry_generate.generate_type == gtengine::GenerateType::ENTRY_BASE_SHUFFLE ||
            entry_generate.generate_type == gtengine::GenerateType::ENTRY_BASE_ORDER)
            ;
        else
        {
            var b_skill = entry_generate.ai_skill_breaking;
            var c_skill = entry_generate.ai_skill_cornering;
            var a_skill = entry_generate.ai_skill_accelerating;
            var s_skill = entry_generate.ai_skill_starting;
            var roughness = entry_generate.ai_roughness;

            for (var i = 0; i < ORG.racers_num; i++)
            {
                var cp = ORG.getEntriedCarParameter(i);
                if (cp.target)
                    continue;

                var dp = ORG.getEntriedDriverParameter(i);
                if (dp != nil)
                {
                    dp.setAISkill(b_skill, c_skill, a_skill, s_skill);
                    dp.ai_roughness = roughness;
                }

                ORG.setChangeableDriverParameterAtBeginningOfSession(i, nil, dp);
            }
        }
    }

    function setupRaceParameter(gp)
    {
        var event = gp.event;

        var rp = gtengine::MRaceParameter();
        rp.deepCopy(event.race_parameter);
        var track = event.track;
        if (track.edit_data != nil)
        {
            var gd = ORG.setGenerateData(track.edit_data);
            gd.maker_id = track.generated_course_id;
            rp.course_code = gd;
        }
        else if (track.course_code == gtengine::MSpecDB::NO_CODE || track.course_code == gtengine::COURSE_CODE_GENERATED)
        {
            track.course_code = gtengine::MSpecDB::getCourseCode("tsukuba") // Default
        }

        rp.course_code = track.course_code;
        rp.course_layout_no = track.course_layout_no;

        setupWeather(rp);
        setupDateTime(rp);
        return rp;
    }

    function applyRaceParameter(gp, rp)
    {
        if (rp.online_on && gp.event.game_mode == gtengine::GameMode::ONLINE_ROOM)
        {
            rp.entry_max = gp.online_room.room_max;
            rp.racers_max = gp.online_room.racer_max;
        }

        gp.event.race_parameter.deepCopy(rp);
    }

    function setCarParts(cp, category, val, and_own = false)
    {
        if (val >= 0)
        {
            cp.setParts(category, val);
            cp.ownParts(category, val);
        }
    }

    function makeCarParameterFromEntryBase(entry_base)
    {
        var cp = gtengine::MCarParameter(entry_base.car);
        cp.race_class_id = entry_base.race_class_id;
        cp.ownArcadePartsAll();

        cp.beginInfo();
        setCarParts(cp, gtengine::CarPartsType::NATUNE, entry_base.engine_na_tune_stage);
        setCarParts(cp, gtengine::CarPartsType::TURBINEKIT, entry_base.engine_turbo_kit);
        setCarParts(cp, gtengine::CarPartsType::COMPUTER, entry_base.engine_computer);

        if (entry_base.power_limiter >= 0)
            cp.restrictorPermill = entry_base.power_limiter * 10;

        setCarParts(cp, gtengine::CarPartsType::MUFFLER, entry_base.muffler);
        setCarParts(cp, gtengine::CarPartsType::SUSPENSION, entry_base.suspension);
        setCarParts(cp, gtengine::CarPartsType::GEAR, entry_base.transmission);

        if (entry_base.gear_max_speed >= 0)
        {
            var maxspeed = entry_base.gear_max_speed;
            var gear_info = SPECDB.query1("SELECT * FROM GEAR WHERE ID = ?", [cp.gear]);

            var min = gear_info.maxspeedMIN * 10;
            var max = gear_info.maxspeedMAX * 10;

            if (maxspeed < min)
            {
                var s = "maxspeed too small. min = %{min} your maxspeed = %{maxspeed}";
            }

            if (max < maxspeed)
            {
                var s = "maxspeed too big. max = %{max} your maxspeed = %{maxspeed}";
            }

            cp.quicktune_maxspeed = entry_base.gear_max_speed / 10;
        }

        if (entry_base.wheel >= 0)
        {
            cp.setWheelCode(entry_base.wheel, entry_base.wheel_color, entry_base.wheel_inch_up);
        }

        if (entry_base.tire_f >= 0)
            cp.setFrontTireCategory(entry_base.tire_f);

        if (entry_base.tire_r >= 0)
            cp.setRearTireCategory(entry_base.tire_r);

        
        setCarParts(cp, gtengine::CarPartsType::WING, entry_base.aero_wing);
        setCarParts(cp, gtengine::CarPartsType::AERO, entry_base.aero_1);
        setCarParts(cp, gtengine::CarPartsType::FLAT_FLOOR, entry_base.aero_2);
        setCarParts(cp, gtengine::CarPartsType::FREEDOM, entry_base.aero_3);

        if (entry_base.downforce_f >= 0)
            cp.FrontCl = entry_base.downforce_f;

        if (entry_base.downforce_r >= 0)
            cp.RearCl = entry_base.downforce_r;

        if (entry_base.paint_id >= 0)
        {
            cp.setPaintColor(0, entry_base.paint_id);
        }

        if (entry_base.decken_number >= 0)
        {
            cp.decken_number = entry_base.decken_number;
            cp.decken_type = entry_base.decken_type;
            cp.decken_custom_type = entry_base.decken_custom_type;
            cp.decken_custom_id = entry_base.decken_custom_id;
        }

        if (entry_base.ballast_weight > 0)
        {
            cp.ballastWeight = entry_base.ballast_weight;
            cp.ballastPosition = entry_base.ballast_position;
        }

        cp.endInfo();
        return cp;
    }

    function generateEntry_SHUFFLE(event, player_cp_list, entry_generate, entry_num, player_num)
    {
        var car_num = entry_num - player_num;
        var car_list = Array(car_num);

        if (entry_generate.cars == nil)
            return;

        var cars = Array(entry_generate.cars.size);
        for (var i = 0; i < entry_generate.cars.size; i++)
            cars[i] = entry_generate.cars[i].code;

        var list = CarSetUtil::getCarSetShuffle(cars, car_num);
        for (var i = 0; i < list.size; i++)
            car_list[i] = gtengine::MCarThin(list[i][0], list[i][1]);

        return car_list;
    }

    function generateEntry_ONE_MAKE(event, player_cp_list, entry_generate, entry_num, player_num)
    {
        var car_num = entry_num - player_num;
        if (car_num < 0)
            return nil;

        var car_list = Array(car_num);
        var cp = player_cp_list[0];
        var car_code = cp.getCarCode();
        var num = gtengine::MSpecDB::getCarVariation(car_code);
        var car_label = cp.getCarLabel();

        var is_rm_car = car_label.endWith("_rm");
        var has_decken = gtengine::MSpecDB::checkFlag(car_code, gtengine::GenericFlag::CAN_CHANGE_DECKEN);

        var decken_numbers = [cp.decken_number];

        var shuffled_list = pdistd::MRandom::GetShuffledList(num, car_list.size);
        for (var i = 0; i < car_list.size; i++)
        {
            if (is_rm_car)
            {
                var col = pdistd::MRandom::GetValue(0, num);
                var entry_cp = gtengine::MCarParameter(car_code, col);

                for (var j = 0; j < 5; j++)
                {
                    var paint_id = pdistd::MRandom::GetValue(1, 3130);
                    var type = SPECDB.executeQuery1R1C("SELECT Type0 FROM PAINT_COLOR_INFO WHERE ID=?", [paint_id]);

                    if (type == nil || type >= 99)
                        continue;
                    
                    entry_cp.setPaintColor(0, paint_id);
                }

                if (has_decken)
                {
                    entry_cp.decken_type = cp.decken_type;

                    var decken_number;
                    while (true)
                    {
                        decken_number = pdistd::MRandom::GetValue(1, 100);
                        if (decken_numbers.indexOf(decken_number) < 0)
                            break;
                    }

                    entry_cp.decken_number = decken_number;
                    decken_numbers.push(decken_number);
                }

                car_list[i] = entry_cp;
            }
            else
            {
                var col = shuffled_list[i];
                car_list[i] = gtengine::MCarThin(car_code, col);
            }
        }

        return car_list;
    }

    function generateEntry_ENEMY_LIST(event, player_cp_list, entry_generate, entry_num, player_num)
    {
        var car_num = entry_num - player_num;
        var cp = player_cp_list[0];

        var pp = SPECDB.executeQuery1R1C("SELECT PP FROM GENERIC_CAR WHERE ID=?", [cp.getCarCode()]);
        if (pp == nil)
        {
            cp.beginInfo();
            pp = cp.getPPWithTire1000();
            cp.endInfo();
        }

        var list_type = gtengine::EnemyListType::ONLY_PREMIUM;
        if (entry_generate.enemy_list_type != nil)
            list_type = entry_generate.enemy_list_type;

        var racecar = gtengine::MSpecDB::getCarCategory(cp.getCarCode()) != gtengine::CarCategory::NORMAL;
        var premium = list_type == gtengine::EnemyListType::ONLY_PREMIUM;
        var dirt = gtengine::MSpecDB::isDirtSnow(event.track.course_code);
        var car_list = [];
        var range = 80;
        var qstr = "SELECT ID FROM GENERIC_CAR WHERE ?<PP AND PP<?";

        if (racecar)
            qstr += " AND Category<>0";
        else
            qstr += " AND Category=0";

        if (dirt)
            qstr += " AND Dirt=1";

        qstr += " AND ArcadeEnemy=1 ORDER BY RANDOM() LIMIT ?";

        var list = SPECDB.queryList(qstr, [pp - range, pp + range, car_num]);
        if (list.size == 0)
        {
            class TmpIT
            {
                attribute ID;
            }

            var it = TmpIT();
            it.ID = cp.getCarCode();
            list.push(it);
        }

        if (list.size < car_num)
        {
            var tmp_list = [];
            foreach (var it in list)
            {
                var row = SPECDB.query1("SELECT NumColor FROM GENERIC_CAR WHERE ID=?", [it.ID]);
                if (row == nil)
                    continue;

                for (var col = 0; col < row.NumColor; ++col)
                {
                    var car = gtengine::MCarThin(it.ID, col);
                    tmp_list.push(car);
                }
            }

            if (tmp_list.size <= 0)
            {
                // BORKED PD LINE OF CODE
                // tmp_ist.push(gtengine::MCarThin(cp.getCarCode), 0)(<????>);

                // Fixed version
                tmp_list.push(gtengine::MCarThin(cp.getCarCode(), 0));
            }

            tmp_list.randomShuffle();

            for (var i = 0; i < car_num; ++i)
                car_list.push(tmp_list[i % tmp_list.size]);
        }
        else 
        {
            foreach (var it in list)
            {
                var row = SPECDB.query1("SELECT NumColor FROM GENERIC_CAR WHERE ID=?", [it.ID]);
                if (row == nil)
                    continue;

                var car = gtengine::MCarThin(it.ID, pdistd::MRandom::GetValue(0, row.NumColor));
                car_list.push(car);
            }
        }

        while (car_list.size < car_num)
        {
            car_list.push(car_list[0];)
        }

        return car_list;
    }

    function generateEntry_SPEC_DB(event, player_cp_list, entry_generate, entry_num, player_num)
    {
        RELEASE_ASSERT(false);
    }

    function generateEntry_ORDER(event, player_cp_list, entry_generate, entry_num, player_num)
    {
        var car_num = entry_num - player_num;
        var car_list = Array(car_num);

        if (entry_generate.cars == nil)
            return;

        var idx = 0;
        for (var i = 0; i < car_num; i++)
        {
            var code = entry_generate.cars[idx].code;
            var col = entry_generate.cars[idx].color;

            if (col < 0)
                col = pdistd::MRandom::GetValue(0, gtengine::MSpecDB::getCarVariation(code));

            car_list[i] = gtengine::MCarThin(code, col);
            ++idx;

            if (idx >= entry_generate.cars.size)
                idx = 0;
        }

        return car_list;
    }

    function generateEntry_FAVORITE_ENEMIES(event, player_cp_list, entry_generate, entry_num, player_num)
    {
        var car_num = entry_num - player_num;
        var car_list = [];

        var enemies = main::GAME_STATUS.user_profile.option.getLimitedEnemies();
        var base_pp = 500;
        var cp = nil;

        if (player_cp_list != nil && player_cp_list.size > 0)
            cp = player_cp_list[0];
        else if (enemies != nil && enemies.size > 0)
        {
            cp = gtengine::MCarParameter();
            cp.setCarCode(enemies[0]);
        }

        if (cp != nil)
        {
            cp.beginInfo();
            base_pp = cp.getPP1000();
            cp.endInfo();
        }

        var player_carcode = cp.getCarCode();
        var where_clause = "WHERE ID IN (%s)".format(enemies.join(","));

        var pp_range_max = GAME_STATUS.user_profile.option.kiosk_enemy_pp_range;
        var pp_range_min = GAME_STATUS.user_profile.option.kiosk_enemy_pp_range_min;

        var pp_max = base_pp + pp_range_max;
        var pp_min = base_pp - pp_range_min;

        where_clause += " AND %d <= PP AND PP <= %d".format(pp_min, pp_max);

        var course_code = event.track.course_code;
        var course = SPECDB.query1("SELECT Condition, KartOnly FROM COURSE WHERE ID=?", [course_code]);

        if (course.Condition == gtengine::CourseCondition::DIRT ||
            course.Condition == gtengine::CourseCondition::SNOW)
            where_clause += " AND SpecifyFlags1 & %{gtengine::GenericFlag::HAVE_DIRT_TIRE}";

        if (course.KartOnly)
            where_clause += " AND SpecifyFlags1 & %{gtengine::GenericFlag::IS_RACING_KART}";

        var list = SPECDB.executeQuery("SELECT ID, NumColor FROM GENERIC_CAR %{where_clause} ORDER BY PP");
        if (list == nil || list.size == 0)
        {
            list.push([player_carcode, gtengine::MSpecDB::getCarVariation(player_carcode)]);
        }

        for (var i = 0; i < entry_num; i++)
        {
            var ii = i % list.size;
            var [carcode, color_num] = list[ii];

            var ct = gtengine::MCarThin(carcode);
            ct.color = pdistd::MRandom::GetValue(0, color_num);
            car_list.push(ct);
        }

        car_list.randomShuffle();

        return car_list;
    }
    
    function get_pp_with_cache(ct, pp_map)
    {
        var pp = pp_map[ct.code];
        if (pp == nil)
        {
            var cp = gtengine::MCarParameter(ct);
            cp.beginInfo();
            pp = cp.getPPWithTire1000();
            cp.endInfo();
            pp_map[ct.code] = pp;
        }

        return pp;
    }

    function get_pp_with_cache_eb(eb, pp_map)
    {
        var ct = eb.car;
        return get_pp_with_cache(ct, pp_map);
    }

    function generateEntryBase(event, player_cp_list, entry_generate, entry_num, player_num)
    {
        if (entry_generate.entry_base_array == nil)
            return;

        var shuffled_list = pdistd::MRandom::GetShuffledList(entry_generate.entry_base_array.size, entry_num);
        var eb_list = Array(entry_num);

        if (entry_generate.generate_type == gtengine::GenerateType::ENTRY_BASE_ORDER)
        {
            for (var eb_id = 0; eb_id < entry_num; eb_id++)
                eb_list[eb_id] = entry_generate.entry_base_array[eb_id];
        }
        else
        {
            var eb_id = 0;
            foreach (var idx in shuffled_list)
            {
                eb_list[eb_id] = entry_generate.entry_base_array[idx];
                eb_id++;
            }
        }

        if (eb_list != nil)
        {
            if (entry_generate.enemy_sort_type != gtengine::EnemySortType::NONE)
            {
                var start_time = pdistd::GetSystemTimeMicroSecond();
                var pp_map = [:];

                if (entry_generate.enemy_sort_type == gtengine::EnemySortType::PP_ASCEND)
                {
                    var cmp_pp_ascend = (a, b) => 
                    {
                        var pp_a = get_pp_with_cache_eb(a, pp_map);
                        var pp_b = get_pp_with_cache_eb(b, pp_map);

                        if (pp_a < pp_b)
                            return true;
                        else
                            return false;
                    };

                    eb_list.sort(cmp_pp_ascend);
                }
                else if (entry_generate.enemy_sort_type == gtengine::EnemySortType::PP_DESCEND)
                {
                    var cmp_pp_descend = (a, b) => 
                    {
                        var pp_a = get_pp_with_cache_eb(a, pp_map);
                        var pp_b = get_pp_with_cache_eb(b, pp_map);

                        if (pp_a > pp_b)
                            return true;
                        else
                            return false;
                    };

                    eb_list.sort(cmp_pp_descend);
                }
            }

            var entry_set = event.entry_set;
            entry_set.entries.resize(entry_num);

            var j = 0;
            for (var i = 0; i < entry_num; i++)
            {
                var entry = entry_set.entries[i];
                var is_auto_demo = event.play_style.play_type == gtengine::PlayType::DEMO;

                if (i == entry_generate.player_pos && !is_auto_demo)
                {
                    entry.car = gtengine::MCarThin();
                    entry.player_no = 0;
                }
                else
                {
                    var cp = makeCarParameterFromEntryBase(eb_list[j]);
                    event.setupAvailableTiresInRace(cp);

                    var is_random_color = is_auto_demo;
                    if (event.game_mode == gtengine::GameMode::EVENT_RACE && eb_list[j].car.color == 0)
                        is_random_color = true;
                    
                    if (is_random_color)
                    {
                        var num = gtengine::MSpecDB::getCarVariation(cp.getCarCode());
                        cp.color = pdistd::MRandom::GetValue(0, num);
                    }

                    if (is_auto_demo)
                        cp.decken_number = i + 2;
                    else
                        cp.decken_number = i + 1;

                    if (is_auto_demo && i == entry_num / 2)
                    {
                        cp.target = true;
                        entry.player_no = 0;
                    }

                    entry.car_parameter = cp;
                    entry.race_class_id = eb_list[j].race_class_id;
                    entry.driver_name = eb_list[j].driver_name;
                    entry.driver_region = eb_list[j].driver_region;

                    for (var lp = 0; lp < eb_list[j].boost_race_ratio.size; lp++) // was lpi++ - fixed
                    {
                        entry.boost_race_ratio[lp] = eb_list[j].boost_race_ratio[lp];
                        entry.boost_ratio[lp] = eb_list[j].boost_ratio[lp];
                    }

                    entry.ai_skill_breaking = eb_list[j].ai_skill_breaking;
                    entry.ai_skill_cornering = eb_list[j].ai_skill_cornering;
                    entry.ai_skill_accelerating = eb_list[j].ai_skill_accelerating;
                    entry.ai_skill_starting = eb_list[j].ai_skill_starting;
                    entry.ai_roughness = eb_list[j].ai_roughness;
                    j++;
                }

                var delays = entry_generate.delays;
                if (i < delays.size)
                    entry.delay = delays[i];
            }
        }
    }

    function generateEntry(event, player_cp_list, is_arcade)
    {
        var entry_set = event.entry_set;
        var entry_generate = entry_set.entry_generate;
        var player_num = 0;

        if (player_cp_list != nil)
            player_num = player_cp_list.size;

        var entry_num = entry_generate.entry_num;

        var car_list;

        if (is_arcade &&
            main::GAME_STATUS.user_profile.option.kiosk_limit_enemy &&
            main::GAME_STATUS.user_profile.option.hasLimitedEnemy())
        {
            switch (entry_generate.generate_type)
            {
                case gtengine::GenerateType::ONE_MAKE:
                    car_list = generateEntry_ONE_MAKE(event, player_cp_list, entry_generate, entry_num, player_num);
                    break;

                case gtengine::GenerateType::SHUFFLE:
                case gtengine::GenerateType::ENEMY_LIST:
                case gtengine::GenerateType::SPEC_DB:
                case gtengine::GenerateType::ORDER:
                case gtengine::GenerateType::ENTRY_BASE_SHUFFLE:
                case gtengine::GenerateType::ENTRY_BASE_ORDER:
                    car_list = generateEntry_FAVORITE_ENEMIES(event, player_cp_list, entry_generate, entry_num, player_num);
                    break;
            }
        }
        else
        {
            switch (entry_generate.generate_type)
            {
                case gtengine::GenerateType::SHUFFLE:
                    car_list = generateEntry_SHUFFLE(event, player_cp_list, entry_generate, entry_num, player_num);
                    break;

                case gtengine::GenerateType::ONE_MAKE:
                    car_list = generateEntry_ONE_MAKE(event, player_cp_list, entry_generate, entry_num, player_num);
                    break;

                case gtengine::GenerateType::ENEMY_LIST:
                    car_list = generateEntry_ENEMY_LIST(event, player_cp_list, entry_generate, entry_num, player_num);
                    break;

                case gtengine::GenerateType::SPEC_DB:
                    car_list = generateEntry_ONE_MAKE(event, player_cp_list, entry_generate, entry_num, player_num);
                    break;

                case gtengine::GenerateType::ORDER:
                    car_list = generateEntry_ORDER(event, player_cp_list, entry_generate, entry_num, player_num);
                    break;

                case gtengine::GenerateType::ENTRY_BASE_SHUFFLE:
                case gtengine::GenerateType::ENTRY_BASE_ORDER:
                    generateEntryBase(event, player_cp_list, entry_generate, entry_num, player_num);
                    return;
            }
        }

        if (car_list != nil)
        {
            if (entry_generate.enemy_sort_type != gtengine::EnemySortType::NONE)
            {
                var start_time = pdistd::GetSystemTimeMicroSecond();
                var pp_map = [:];

                if (entry_generate.enemy_sort_type == gtengine::EnemySortType::PP_ASCEND)
                {
                    var cmp_pp_ascend = (a, b) => 
                    {
                        var pp_a = get_pp_with_cache(a, pp_map);
                        var pp_b = get_pp_with_cache(b, pp_map);

                        if (pp_a < pp_b)
                            return true;
                        else
                            return false;
                    };

                    car_list.sort(cmp_pp_ascend);
                }
                else if (entry_generate.enemy_sort_type == gtengine::EnemySortType::PP_DESCEND)
                {
                    var cmp_pp_descend = (a, b) => 
                    {
                        var pp_a = get_pp_with_cache(a, pp_map);
                        var pp_b = get_pp_with_cache(b, pp_map);

                        if (pp_a > pp_b)
                            return true;
                        else
                            return false;
                    };

                    car_list.sort(cmp_pp_descend);
                }
            }

            entry_set.entries.resize(entry_num);

            var j = 0;
            for (var i = 0; i < entry_num; i++)
            {
                var entry = entry_set.entries[i];
                if (i == entry_generate.player_pos)
                {
                    entry.car = gtengine::MCarThin();
                    entry.player_no = 0;
                }
                else
                {
                    if (car_list[j].isInstanceOf(gtengine::MCarParameter))
                        entry.car_parameter = car_list[j];
                    else
                        entry.car = car_list[j];
                    j++;
                }

                var delays = entry_generate.delays;
                if (i < delays.size)
                    entry.delay = delays[i];
            }
        }
    }

    function getLineTraceRate(bspec_level)
    {
        var rate = 1f;
        if (bspec_level < 10)
            rate = (bspec_level / 10f) * 0.5f;
        else
            rate = 0.5f + (((bspec_level - 10) / 30f) * 0.5f);

        if (rate > 1f)
            rate = 1f;

        if (rate < 0f)
            rate = 0f;

        return rate;
    }

    function getCornringSkill(bspec_level)
    {
        if (bspec_level <= 5)
        {
            var rate = bspec_level / 5f;
            return 81 + (5.25f * rate).toInt();
        }
        else
        {
            var rate = (bspec_level - 5) / 35f;
            if (rate > 1f)
                rate = 1f;

            return 86.25f + (8.75f * rate).toInt();
        }
    }

    function getBSpecEnemySkill(ai_driver, entry, bspec_level)
    {
        var rate = bspec_level / 40f;
        if (rate > 1f)
            rate = 1f;
        if (rate < 0f)
            rate = 0f;

        var stamina_rate = bspec_level / 99f;
        if (rate > 1f) // Pretty sure they meant stamina_rate
            rate = 1f;
        if (rate < 0f)
            rate = 0f;

        ai_driver.growth_parameter.stamina = 600 + (((8700 + pdistd::MRandom::GetValue(0, 200)) * stamina_rate) * 1.1f).toInt();
        ai_driver.growth_parameter.mentality = pdistd::MRandom::GetValue(0, 10);
        ai_driver.growth_parameter.condition = 0;
        ai_driver.growth_parameter.temper = pdistd::MRandom::GetValue(0, 100);
        ai_driver.growth_parameter.flexibility = 100;

        ai_driver.growth_parameter.skill_base_breaking = entry.ai_skill_breaking;
        ai_driver.growth_parameter.skill_base_cornering = entry.ai_skill_cornering;
        ai_driver.growth_parameter.skill_base_cornerout = entry.ai_skill_accelerating; // TIL

        ai_driver.growth_parameter.skill_base_line_trace = 100 - (100 * getLineTraceRate(bspec_level)).toInt();

        rate = bspec_level / 10f;
        if (rate > 1f)
            rate = 1f;
        if (rate < 0f)
            rate = 0f;

        ai_driver.growth_parameter.skill_base_stear_reaction = -20 + (20 * rate).toInt();
        ai_driver.growth_parameter.skill_base_shift_up = 90 + (10 * rate).toInt();
        ai_driver.growth_parameter.skill_heat_offset = 50 - (45 * rate).toInt();
    }

    function create_ai_driver(entry_set, entry, course_code, play_style, flag_set)
    {
        if (entry_set.entry_generate.generate_type == gtengine::GenerateType::ENTRY_BASE_SHUFFLE ||
            entry_set.entry_generate.generate_type == gtengine::GenerateType::ENTRY_BASE_ORDER)
            return create_ai_driver_by_entry(entry, entry_set.entry_generate.enemy_bspec_lv, course_code, play_style, flag_set);
        else
            return create_ai_driver_org(entry_set, course_code, play_style, flag_set);
    }

    function create_ai_driver_by_entry(entry, bspec_lv, course_code, play_style, flag_set)
    {
        var ai_driver = gtengine::MCarDriverParameter(gtengine::DriverType::AI);

        if (bspec_lv < 0)
        {
            ai_driver.disable_bspec_skill = true;
            ai_driver.display_name = entry.driver_name;
            ai_driver.region = entry.driver_region;
            ai_driver.setGroveAIParameter("max_ai", 100);

            var b_skill = entry.ai_skill_breaking;
            var c_skill = entry.ai_skill_cornering;
            var a_skill = entry.ai_skill_accelerating;
            var s_skill = 100;
            ai_driver.setAISkill(b_skill, c_skill, a_skill, s_skill);

            ai_driver.ai_roughness = entry.ai_roughness;
        }
        else
        {
            ai_driver.disable_bspec_skill = false;
            ai_driver.display_name = entry.driver_name;
            ai_driver.region = entry.driver_region;
            ai_driver.setGroveAIParameter("max_ai", 100);

            ai_driver.ai_roughness = entry.ai_roughness;
            getBSpecEnemySkill(ai_driver, entry, bspec_lv);
            
            var it = gtengine::MSpecDB::getCourseRow(course_code);
            if (it.Oval)
            {
                if (flag_set == gtengine::RaceFlagSet::FLAGSET_NASCAR)
                    ai_driver.special_ai_type = gtengine::SpecialAIType::OVALNASCAR;
                else
                    ai_driver.special_ai_type = gtengine::SpecialAIType::OVAL;
            }
        }
        
        return ai_driver;
    }

    function create_ai_driver_org(entry_set, course_code, play_style, flag_set)
    {
        var is_bspec = false;
        if (play_style != nil && play_style == gtengine::BSpecType::ONLY_B)
            is_bspec = true;

        var ai_driver = gtengine::MCarDriverParameter(gtengine::DriverType::AI);
        var ai_skill = entry_set.entry_generate.ai_skill;

        if (is_bspec)
        {
            ai_skill = 100;
            ai_driver.disable_bspec_skill = false;
        }

        var name_skill = DriverNameUtil::getWithSkill();
        if (name_skill == nil)
            name_skill = ["", 0, 0, ""];

        ai_driver.display_name = name_skill[0];
        ai_driver.region = name_skill[3];
        ai_driver.setGroveAIParameter("max_ai", ai_skill);

        if (!is_bspec)
        {
            var b_skill = entry_set.entry_generate.ai_skill_breaking;
            var c_skill = entry_set.entry_generate.ai_skill_cornering;
            var a_skill = entry_set.entry_generate.ai_skill_accelerating;
            var s_skill = entry_set.entry_generate.ai_skill_starting;

            if (b_skill != -1 || c_skill != -1 || a_skill != -1 || s_skill != -1)
                ai_driver.setAISkill(b_skill, c_skill, a_skill, s_skill);
        }

        ai_driver.ai_roughness = entry_set.entry_generate.ai_roughness;
        if (is_bspec)
        {
            ABspecUtil::getBSpecEnemySkill(ai_driver, entry_set.entry_generate.enemy_bspec_lv);
            ai_driver.growth_parameter.temper = name_skill[1];
        }

        var it = gtengine::MSpecDB::getCourseRow(course_code);
        if (it.Oval)
        {
            if (flag_set == gtengine::RaceFlagSet::FLAGSET_NASCAR)
                ai_driver.special_ai_type = gtengine::SpecialAIType::OVALNASCAR;
            else
                ai_driver.special_ai_type = gtengine::SpecialAIType::OVAL;
        }

        return ai_driver;
    }

    function choose_car(entry, player_cp_list, idx, entry_size, exist_player)
    {
        var cp = nil;
        var target = false;
        var is_player = entry.player_no != gtengine::MGameParameter::INVALID_VALUE_INT;

        if (!entry.car_parameter.isVacant())
        {
            if (is_player)
                target = true;
            else
                target = entry.car_parameter.target;
            cp = entry.car_parameter;
            cp.race_class_id != entry.race_class_id;
        }
        else
        {
            if (is_player)
            {
                target = true;
                var player_no = entry.player_no;
                if (entry.entry_base.car.code != gtengine::MSpecDB::NO_CODE)
                    cp = makeCarParameterFromEntryBase(entry.entry_base);
                else if (entry.car.code == gtengine::MSpecDB::NO_CODE)
                {
                    if (player_cp_list.size <= player_no)
                        player_no = 0;
                    cp = player_cp_list[player_no];
                }
                else
                {
                    cp = gtengine::MCarParameter(entry.car);
                }
            }
            else if (entry.car.code != gtengine::MSpecDB::NO_CODE)
            {
                cp = gtengine::MCarParameter(entry.car);
                cp.decken_number = pdistd::MRandom::GetValue(1, 100);
            }
            else
            {
                cp = gtengine::MCarParameter();
                cp.setCarCode("gtr_07");
            }
            
        }

        cp.special_driver = entry.proxy_driver_model;
        cp.race_class_id = entry.race_class_id;

        if (entry.initial_fuel100 > 0)
            cp.gasoline_liter = entry.initial_fuel100;
        
        return [is_player, target, cp];
    }

    function choose_drivers(event, entry, is_player, player_dp_list, bspec_dp_list)
    {
        var dp_list = Array(4);
        if (!entry.driver_parameter.isVacant())
        {
            for (var pilot_id = 0; pilot_id < dp_list.size; pilot_id++)
            {
                var dp = entry.driver_parameter_list[pilot_id];
                dp_list[pilot_id] = dp;

                if (!dp.isVacant() && dp_list[pilot_id].display_name == "")
                    dp_list[pilot_id].display_name = DriverNameUtil::get();
            }
        }
        else if (is_player)
        {
            var player_no = entry.player_no;
            if (player_no >= 0 && event.play_style.play_type == gtengine::PlayType::RACE)
            {
                if (event.play_style.bspec_type == gtengine::BSpecType::ONLY_B)
                {
                    for (var j = 0; j < 4; ++j)
                    {
                        var idx = (player_no * 4) + j;
                        if (idx < bspec_dp_list.size)
                        {
                            dp_list[j] = bspec_dp_list[idx];
                            dp_list[j].disable_bspec_skill = false;
                            
                            if (event.entry_set.entry_generate.bspec_lv_offset > 0)
                            {
                                var new_dp = gtengine::MCarDriverParameter();
                                new_dp.deepCopy(dp_list[j]);
                                new_dp.growth_parameter.lv += event.entry_set.entry_generate.bspec_lv_offset;

                                if (new_dp.growth_parameter.lv > 40)
                                    new_dp.growth_parameter.lv = 40;

                                ABspecUtil::getBSpecPlayerSkill(new_dp, new_dp.growth_parameter.lv, new_dp.growth_parameter.spec_id);
                                dp_list[j] = new_dp;
                            }
                        }
                    }
                }
                else 
                {
                    if (player_dp_list != nil && player_no < player_dp_list.size)
                        dp_list[0] = player_dp_list[player_no];
                    else
                    {
                        dp_list[0] = gtengine::MCarDriverParameter();
                        dp_list[0].setDefault();
                        dp_list[0].setPlayer(0);
                    }

                    if (bspec_dp_list != nil && bspec_dp_list.size > 0)
                        dp_list[1] = bspec_dp_list[0];
                }
            }
            else 
            {
                dp_list[0] = create_ai_driver(event.entry_set, entry, event.track.course_code, 
                    event.play_style.bspec_type, event.race_parameter.flagset);

                if (entry.driver_name != "")
                    dp_list[0].display_name = entry.driver_name;
            }
        }
        else if (event.play_style.bspec_type == gtengine::BSpecType::ONLY_B)
        {
            var limit = 4;
            if (event.regulation.limit_bspec_driver_count > 0 && 
                limit > event.regulation.limit_bspec_driver_count)
                limit = event.regulation.limit_bspec_driver_count;

            for (var k = 0; k < limit; ++k)
            {
                dp_list[k] = create_ai_driver(event.entry_set, entry, event.track.course_code, 
                    event.play_style.bspec_type, event.race_parameter.flagset);

                if (event.regulation.limit_bspec_driver_count > 1)
                {
                    dp_list[k].ai_pit_decision_10_tire_before_race = pdistd::MRandom::GetValue(2, 4);
                    dp_list[k].ai_pit_decision_10_vitality_before_race = pdistd::MRandom::GetValue(1, 3);
                }
            }
        }
        else
        {
            // GT5 Remnant
            dp_list[0] = create_ai_driver(event.entry_set, entry, event.track.course_code, 
                event.play_style.bspec_type, event.race_parameter.flagset);

            var event_id = event.event_id;
            if (event_id >= 1000295 && event_id <= 1000297)
            {
                var dp = dp_list[0];
                dp.display_name = "S.Vettel";
                dp.region = "DE";
                dp.body_code = 6;
                dp.head_code = 6;
                dp.body_color_code = 1;
                dp.head_color_code = 1;
                dp_list[0] = dp;
            }
        }

        if (!is_player)
        {
            for (var i = 0; i < dp_list.size; i++)
            {
                if (dp_list[i] != nil)
                    dp_list[i].physics_pro = 0;
            }
        }

        var result_dp_list = Array();
        foreach (var dp in dp_list)
        {
            if (dp != nil && !dp.isVacant())
                result_dp_list.push(dp);
        }

        return result_dp_list;
    }

    function setConstraintEnemyTire(cp, event)
    {
        var enemy_tire = event.constraint.enemy_tire;
        if (enemy_tire == nil || enemy_tire < 0)
            return;

        cp.setFrontTireCategory(enemy_tire);
        cp.setRearTireCategory(enemy_tire);
    }

    function applyConstraintToCpDpList(event, rp, cp, dp_list)
    {
        var is_raintire_recommended = rp.isRainTireRecommended();
        var cons = event.constraint;
        var res = cons.checkIfQualified(cp, dp_list);

        if (res[0])
            ;
        else
        {
            if (cp.rentacar)
            {
                cp.ownArcadePartsAll();
                event.setupAvailableTiresInRace(cp);
                cp.setSuitableTires(event.track.course_code, is_raintire_recommended);
            }

            var [new_cp, new_dp_list] = cons.apply(cp, dp_list);
            cp = new_cp;
            dp_list = new_dp_list;
        }

        return [cp, dp_list];
    }

    function reserve_entry_set(event, rp, player_cp_list, player_dp_list, bspec_dp_list, online_id_list)
    {
        var target_count_for_debug = 0;
        var is_raintire_recommended = rp.isRainTireRecommended();

        var entry_set = event.entry_set;
        if (entry_set.entries != nil)
        {
            var exist_player = false;
            if (player_cp_list.size > 0)
                exist_player = true;
            else
            {
                for (var i = 0; i < entry_set.entries.size; i++)
                {
                    var entry = entry_set.entries[i];
                    var is_player = entry.player_no != gtengine::MGameParameter::INVALID_VALUE_INT;

                    if (is_player)
                    {
                        exist_player = true;
                        break;
                    }
                }
            }

            for (var i = 0; i < entry_set.entries.size; i++)
            {
                var entry = entry_set.entries[i];
                var [is_player, target, cp] = choose_car(entry, player_cp_list, i, entry_set.entries.size, exist_player);
                yield;

                var cp;
                if (event.game_mode == gtengine::GameMode::ONLINE_BATTLE)
                    cp = player_cp_list[0];
                    
                var dp_list = choose_drivers(event, entry, is_player, player_dp_list, bspec_dp_list);
                yield;

                if (is_player)
                    [cp, dp_list] = applyConstraintToCpDpList(event, rp, cp, dp_list);
                
                if (!is_player && entry.car.code != gtengine::MSpecDB::NO_CODE)
                {
                    var re = Regexp(".*nascar.*");
                    var label = main::gtengine::MSpecDB::getCarLabel(entry.car.code);
                    var cons = event.constraint;
                    
                    if (re.match(label) && cons.asm == 1)
                        dp_list[0].assist_asm = 0;
                }

                var main_dp = nil;
                if (is_player)
                {
                    if (cp.rentacar)
                    {
                        cp.ownArcadePartsAll();
                        event.setupAvailableTiresInRace(cp);
                    }

                    var nb_dr = 0;

                    foreach (var dp in dp_list)
                    {
                        if (dp != nil)
                            nb_dr += 1;
                    }

                    if (nb_dr > 1 && player_dp_list != nil && player_dp_list.size > 0)
                        main_dp = player_dp_list[0]
                }
                else
                {
                    var generate_type = event.entry_set.entry_generate.generate_type;
                    if (generate_type != gtengine::GenerateType::ENTRY_BASE_SHUFFLE &&
                        generate_type != gtengine::GenerateType::ENTRY_BASE_ORDER)
                    {
                        cp.ownArcadePartsAll();
                        cp.setSuitableTires(event.track.course_code, is_raintire_recommended);
                    }

                    setConstraintEnemyTire(cp, event);
                }

                foreach (var dp in dp_list)
                {
                    if (dp != nil)
                        dp.competition_flags = rp.academy_event != 0 ? 7 : 0;
                }

                if (online_id_list == nil || i >= online_id_list.size)
                    RaceOperator.makeReservation(cp, target, dp_list, main_dp, entry.pilot_id);
                else
                    RaceOperator.makeReservation(online_id_list[i], cp, target, dp_list, main_dp, entry.pilot_id);
                yield;

                if (target)
                    ++target_count_for_debug;

                if (event.game_mode == gtengine::GameMode::ONLINE_BATTLE)
                    break;
            }
        }

        // Not used
        event.game_mode != gtengine::GameMode::SPLIT_BATTLE &&
            event.game_mode != gtengine::GameMode::SPLIT_ONLINE_BATTLE &&
            event.game_mode != gtengine::GameMode::DRIFT_ATTACK &&
            event.game_mode != gtengine::GameMode::DRAG_RACE;
    }

    function setup(gp, player_cp_list, player_dp_list, bspec_dp_list, online_id_list)
    {
        var event = gp.event;
        var replay = event.replay;
        if (replay.isExpected())
        {
            if (replay.local_path != "")
            {
                setupForReplay(gp);
                return true;
            }
            else
                return false;
        }

        var q = replay.replay_recording_quality;
        if (GAME_STATUS.user_profile.option.full_quality_replay)
            q = gtengine::ReplayRecordingQuality::FULL;

        ORG.replay_recording_quality = q;
        if (event.game_mode == gtengine::GameMode::ONLINE_BATTLE)
        {
            if (player_dp_list != nil && player_dp_list.size > 0)
            {
                var displayName = PDINetwork.getDisplayName();
                if (displayName == "")
                    return false;

                player_dp_list[0].display_name = displayName;
            }
        }

        var res = setupRaceOperator(gp, player_cp_list, player_dp_list, bspec_dp_list, nil, online_id_list);
        return res;
    }

    function setupRaceOperator(gp, player_cp_list, player_dp_list, bspec_dp_list, before_build_cb, online_id_list)
    {
        var event = gp.event;
        RaceOperator.clear();

        if (AppOpt.defined("expand_memory"))
            main::RaceOperator.expand_memory = true;

        var entry_set = event.entry_set;
        var entry_generate = entry_set.entry_generate;

        if (event.game_mode == gtengine::GameMode::SINGLE_RACE)
        {
            if (player_cp_list != nil && player_cp_list.size >= 1)
            {
                if (gtengine::MSpecDB::checkFlag(player_cp_list[0].getCarCode(), gtengine::GenericFlag::ONE_MAKE_ONLY))
                    entry_generate.generate_type = gtengine::GenerateType::ONE_MAKE;
            }
        }

        if (entry_generate.generate_type != gtengine::GenerateType::NONE)
        {
            generateEntry(event, player_cp_list, gp.arcade);
        }
        else if (entry_set.entries.size == 0)
        {
            if (player_cp_list != nil)
            {
                var entry_num = player_cp_list.size;
                entry_set.entries.resize(entry_num);
                for (var i = 0; i < entry_num; i++)
                {
                    var entry = entry_set.entries[i];
                    entry.car = gtengine::MCarThin();
                    entry.player_no = i;
                }
            }
        }

        var rp = setupRaceParameter(gp);
        if (event.game_mode == gtengine::GameMode::ONLINE_BATTLE)
        {
            var cp = player_cp_list[0];
            var [cp, dp_list] = applyConstraintToCpDpList(event, rp, cp, player_dp_list);
            RaceOperator.makeReservation(cp, true, dp_list, dp_list[0], 0);
        }
        else if (event.game_mode != gtengine::GameMode::ONLINE_ROOM)
        {
            reserve_entry_set(event, rp, player_cp_list, player_dp_list, bspec_dp_list, online_id_list);
        }

        applyRaceParameter(gp, rp);
        
        if (entry_generate.generate_type != gtengine::GenerateType::NONE)
            gp.removeEntriesByEntryGenerate();

        var quality_low = false;

        if (event.game_mode == gtengine::GameMode::SPLIT_BATTLE ||
            event.game_mode == gtengine::GameMode::SPLIT_ONLINE_BATTLE ||
            event.game_mode == gtengine::GameMode::DRAG_RACE ||
            event.game_mode == gtengine::GameMode::ONLINE_ROOM)
        {
            var windowCount = entry_set.entries.size;
            if (event.game_mode == gtengine::GameMode::ONLINE_ROOM && GAME_STATUS.user_profile.option.lounge_split_screen)
                 windowCount = 2;
            
            if (windowCount >= 2)
            {
                RaceOperator.window_max = windowCount;
                RaceOperator.simul_view = GAME_STATUS.user_profile.option.simulview_2p_battle;
                ORG.window_max = windowCount;
                quality_low = true;
            }
        }
        else if (event.game_mode == gtengine::GameMode::DRIFT_ATTACK)
        {
            if (entry_set.entries.size > 1)
                quality_low = true;
        }

        if (gp.event.race_parameter.online_on) { }

        RaceOperator.game_parameter = gp;
        RaceOperator.game_parameter.reduceMemoryForRace();

        RaceOperator.with_ghost = gp.event.race_parameter.ghost_type != gtengine::GhostType::NONE;

        if (before_build_cb != nil)
            before_build_cb(gp);

        if (!gp.event.race_parameter.online_on)
        {
            if (ORG.isBuildComplete() == false)
            {
                RaceOperator.buildRace();
                do
                {
                    yield;
                } while (!ORG.isBuildComplete());
            }
        }

        if (quality_low)
        {
            ORG.setSceneQualityInRaceNoInterior(true);
            ORG.setSceneQualityInRaceNoCrowd(true);
        }

        return true;
    }

    function setupForReplay(gp)
    {
        var replay = gp.event.replay;
        ORG.replay_work_path = replay.local_path;

        RaceOperator.setReplayMode(true);
        ORG.prepareReplayPath(replay.local_path);
        
        var buf = ORG.getReplayHeaderFromWorkPath();
        var info = gtengine::MReplayInfo();
        var success = info.initialize(buf);

        RaceOperator.game_parameter = info.getGameParameter();
        RaceOperator.game_parameter.reduceMemoryForRace();
        RaceOperator.game_parameter.event.race_parameter.online_on = false;
        RaceOperator.game_parameter.event.replay.deepCopy(gp.event.replay);

        gp.event.track.course_code = info.getGameParameter().event.track.course_code;

        RaceOperator.buildRace();
        var rp = info.getRaceParameter();
        rp.online_on = false;
        RaceOperator.race_parameter = rp;

        do
        {
            yield;
        } while (!ORG.isBuildComplete());
    }

    function resolveInconsistency(gp, player_cp_list, player_dp_list, bspec_dp_list)
    {
        var event = gp.event;
        var rp = event.race_parameter;

        if (event.game_mode == gtengine::GameMode::ONLINE_ROOM ||
            event.game_mode == gtengine::GameMode::ONLINE_BATTLE ||
            event.game_mode == gtengine::GameMode::SPLIT_ONLINE_BATTLE)
            rp.online_on = true;
        else
            rp.online_on = false;

        if (rp.disable_recording_replay)
        {
            event.play_style.no_instant_replay = true;
            if (CheckVersion::Test(49710))
                event.play_style.replay_record_enable = false;
        }
    }

    function execute(without_bg = false)
    {
        if (launch_data == nil)
            return;

        var gp = launch_data.gp;

        if (gp.event.game_mode != gtengine::GameMode::ONLINE_ROOM)
        {
            resolveInconsistency(gp, launch_data.player_cp_list, launch_data.player_dp_list, launch_data.bspec_dp_list);
            var success = setup(gp, launch_data.player_cp_list, launch_data.player_dp_list, launch_data.bspec_dp_list, launch_data.online_id_list);
            
            !success; // Unused

            if (!without_bg)
            {
                var course_code = launch_data.gp.event.track.course_code;
                if (course_code == gtengine::COURSE_CODE_GENERATED)
                {
                    if (gp.event.track.edit_data != nil)
                        course_code = gp.event.track.getSceneryCourseCode();
                    else
                    {
                        var rp = main::ORG.getCurrentRaceParameter();
                        course_code = rp.scenery_code;
                    }
                }

                var it = gtengine::MSpecDB::getCourseRow(course_code);
                ORG.setLoadingImageFile("piece/loading_bg/%{it.LoadingBg}.img");
            }
        }

        launch_data = nil;
    }

    function getGT6CareerModeBridgeBGMCode(gp)
    {
        if (gp.folder_id == 42)
            return "quick_before_finalrace"; // Last champ - MOTC

        var category = CareerModeUtil_GetCategoryByFolderID(gp.folder_id);
        var bgm_code = category != nil ? sBridgeBGMMapByCategory[category] : nil;

        return bgm_code != nil ? bgm_code : "quick_before";
    }

    function CareerModeUtil_GetCategoryByFolderID(folder_id)
    {
        var type = MENUDB.executeQuery1R1C("SELECT Type FROM t_event_folder WHERE FolderID=?", [folder_id]);
        if (type == nil)
            return nil;

        var v = type.toInt() / 1000;
        return v >= 1 && v <= 9 ? v : nil;
    }

    static sBridgeBGMMapByCategory = [
        1 : "event_1",
        2 : "event_2",
        3 : "event_3",
        4 : "event_4",
        5 : "event_5",
        6 : "event_6",
        7 : "event_7",
        8 : "quick_before_moon",
        9 : "event_8",
    ];

    function clearResource()
    {
        var start_time = pdistd::GetSystemTimeMicroSecond();

        while (RaceOperator.clearResource() == false)
        {
            pdiext::ProcessUpdateIteration();
            if (RaceOperator.clearResource() == true)
                break;

            pdiext::ProcessUpdateIteration((16 * 1000) * 30);

            var now_time = pdistd::GetSystemTimeMicroSecond();
            if ((now_time - start_time) > (300 * 1000) * 1000)
            {
                nil[0]; // You ok PD?
            }
        }
    }
}