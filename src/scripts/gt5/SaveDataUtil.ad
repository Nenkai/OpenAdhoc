

//---------------------------------------------------------------------------------------
// SaveDataUtil.ad
//
// Utility module for saving
// 
//---------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------
// module
//---------------------------------------------------------------------------------------
module SaveDataUtil
{
    import main::DialogUtil;
    
    module MODE
    {
        static FIXED = 0;
        static AUTO = 1;
        static BG = 2;
        static LIST = 3;
        static COPYFIXED = 4;
        static COPYAUTO = 5;
        static COPYBG = 6;
        static COPYLIST = 7;
        static MULTILIST = 8;
        static SPECIAL = 9;
        static RECREATE = 10;
    }

    module INDICATOR_DISP_POS
    {
        static INDICATORPOS_LOWER_RIGHT = 0;
        static INDICATORPOS_LOWER_LEFT = 1;
        static INDICATORPOS_UPPER_RIGHT = 2;
        static INDICATORPOS_UPPER_LEFT = 3;
        static INDICATORPOS_CENTER = 4;
    }

    module INDICATOR_DISP_MSG_ALIGN
    {
        static INDICATORPOS_MSGALIGN_LEFT = 0 << 4;
        static INDICATORPOS_MSGALIGN_RIGHT = 1 << 4;
        static INDICATORPOS_MSGALIGN_CENTER = 2 << 4;
    }

    module INDICATOR_DISP_MODE
    {
        static INDICATORMODE_FIXED = 0;
        static INDICATORMODE_BLINK = 1;
        static INDICATORMODE_BLINK_FAST = 2;
        static INDICATORMODE_BLINK_SLOW = 3;
    }

    module RETCODE
    {
        static BUSY = 1;
        static SUCCESS = 0;
        static F_MALLOC = -1;
        static NOSPACE = -2;
        static NO_DIRNAME = -3;
        static NO_FILENAME = -4;
        static CORRUPT_DATA = -5;
        static CANCEL_BY_USER = -6;
        static FATAL_ERROR = -7;
        static NO_ENOUGH_BUFFER_TO_LOAD = -8;
        static BIND_ERROR = -9;
        static BIND_NEED_RECREATE = -10;
        static NEED_RETRY_LOAD = -11;
    }

    class DataForSave
    {
        attribute firstCB;
        attribute mode;
        attribute buf;
        attribute size;
        attribute dirName;
        attribute fileName;
        attribute listParam;
        attribute iconTitle;
        attribute title;
        attribute subtitle;
        attribute description;
        attribute iconPngName;
        attribute iconBuf;
        attribute bgPngName;
        attribute secure;
        attribute canCopy;
        attribute bindCheck;
        attribute compress;
        attribute encrypt;
        attribute indicatorMessage;
        attribute indicatorPosition;
        attribute indicatorAlign;
        attribute indicatorMode;
		attribute indicatorPngName;
    }

    class DataForLoad
    {
        attribute mode;
        attribute secure;
        attribute bindCheck;
        attribute compress;
        attribute encrypt;
        attribute dirName;
        attribute fileName;
        attribute buf;
        attribute complete_func;
        attribute indicatorMessage;
        attribute indicatorPosition;
        attribute indicatorAlign;
        attribute indicatorMode;
        attribute indicatorPngName;
    }

    class DataForImportExport
    {
        attribute mode;
        attribute dirName;
        attribute fileName;
    }

    ////////////////////////////////////
    ///////// SAVING ///////////////////
    ////////////////////////////////////
    static sSaveBGIssued = false;

    function _save(context, project, data, use_tsm)
    {
        if (data.firstCB != nil)
        {
            var success = data.firstCB(context, data, use_tsm);
            if (!success)
                return false;
        }

        var icon_png = data.iconPngName;
        var bg_png = data.bgPngName;

        var sutil = main::SaveUtil;
        var success = false;
        var loop = true;
        var retry_no_file_name = false;

        do
        {
            var result = nil;

            sutil.setErrorMessageInfo(
                manager.translate("SaveData", "ERROR_SAVE_NO_SPACE"),
                manager.translate("SaveData", "DO_YOU_DELETE_OTHER_FILES"),
                manager.translate("SaveData", "DO_YOU_ABORT_TO_SAVE"),
                manager.translate("SaveData", "ERROR_SAVE_OTHER"),
                manager.translate("SaveData", "DO_YOU_RETRY_TO_SAVE"),
                manager.translate("SaveData", "SAVE_NOT_DONE"),
            );

            switch (data.mode)
            {
                case MODE::FIXED:
                    result = sutil.fixedSave(
                        data.secure,
                        data.canCopy,
                        data.bindCheck,
                        data.compress,
                        data.encrypt,
                        data.dirName,
                        data.fileName,
                        data.title,
                        data.subtitle,
                        data.description,
                        data.listParam,
                        data.iconTitle,
                        data.buf,
                        data.size,
                        icon_png,
                        bg_png,
                    );
                    break;

                case MODE::COPYFIXED:
                    result = sutil.copyToFixedSave(
                        data.secure,
                        data.canCopy,
                        data.bindCheck,
                        data.compress,
                        data.encrypt,
                        data.dirName,
                        data.fileName,
                        data.title,
                        data.subtitle,
                        data.description,
                        data.listParam,
                        data.iconTitle,
                        data.buf,
                        data.size,
                        icon_png,
                        bg_png,
                    );
                    break;

                case MODE::BG:
                    sSaveBGIssued = true;

                    result = sutil.backgroundSave(
                        data.secure,
                        data.canCopy,
                        data.bindCheck,
                        data.compress,
                        data.encrypt,
                        data.dirName,
                        data.fileName,
                        data.title,
                        data.subtitle,
                        data.description,
                        data.listParam,
                        data.iconTitle,
                        data.buf,
                        data.size,
                        nil,
                        nil,
                        data.indicatorPosition,
                        data.indicatorAlign,
                        data.indicatorMode,
                        data.indicatorMessage,
                        data.indicatorPngName,
                    );
                    break;

                case MODE::COPYBG:
                    sSaveBGIssued = true;
    
                    result = sutil.copyToBackgroundSave(
                        data.secure,
                        data.canCopy,
                        data.bindCheck,
                        data.compress,
                        data.encrypt,
                        data.dirName,
                        data.fileName,
                        data.title,
                        data.subtitle,
                        data.description,
                        data.listParam,
                        data.iconTitle,
                        data.buf,
                        data.size,
                        nil,
                        nil,
                        data.indicatorPosition,
                        data.indicatorAlign,
                        data.indicatorMode,
                        data.indicatorMessage,
                        data.indicatorPngName,
                    );
                    break;

                case MODE::AUTO:
                    DialogUtil::setProgress(context, sutil.progress);
    
                    result = sutil.autoSave(
                        data.secure,
                        data.canCopy,
                        data.bindCheck,
                        data.compress,
                        data.encrypt,
                        data.dirName,
                        data.fileName,
                        data.title,
                        data.subtitle,
                        data.description,
                        data.listParam,
                        data.iconTitle,
                        data.buf,
                        data.size,
                        icon_png,
                        bg_png,
                    );
                    break;

                case MODE::COPYAUTO:
                    DialogUtil::setProgress(context, sutil.progress);
        
                    result = sutil.copyToAutoSave(
                        data.secure,
                        data.canCopy,
                        data.bindCheck,
                        data.compress,
                        data.encrypt,
                        data.dirName,
                        data.fileName,
                        data.title,
                        data.subtitle,
                        data.description,
                        data.listParam,
                        data.iconTitle,
                        data.buf,
                        data.size,
                        icon_png,
                        bg_png,
                    );
                    break;

                case MODE::LIST:
                    result = sutil.listSave(
                        data.secure,
                        data.canCopy,
                        data.bindCheck,
                        data.compress,
                        data.encrypt,
                        data.dirName,
                        data.fileName,
                        data.title,
                        data.subtitle,
                        data.description,
                        data.listParam,
                        data.iconTitle,
                        data.buf,
                        data.size,
                        icon_png,
                        bg_png,
                    );
                    break;

                case MODE::COPYLIST:
                    result = sutil.copyToListSave(
                        data.secure,
                        data.canCopy,
                        data.bindCheck,
                        data.compress,
                        data.encrypt,
                        data.dirName,
                        data.fileName,
                        data.title,
                        data.subtitle,
                        data.description,
                        data.listParam,
                        data.iconTitle,
                        data.buf,
                        data.size,
                        icon_png,
                        bg_png,
                    );
                    break;

                case MODE::MULTILIST:
                    result = sutil.multiFileListSave(
                        data.secure,
                        data.canCopy,
                        data.bindCheck,
                        data.compress,
                        data.encrypt,
                        data.dirName,
                        data.fileName,
                        data.title,
                        data.subtitle,
                        data.description,
                        data.listParam,
                        data.iconTitle,
                        data.buf,
                        data.size,
                        icon_png,
                        bg_png,
                    );
                    break;

                case MODE::RECREATE:
                    DialogUtil::setProgress(context, sutil.progress);

                    result = sutil.copyToRecreateAutoSave(
                        data.secure,
                        data.canCopy,
                        data.bindCheck,
                        data.compress,
                        data.encrypt,
                        data.dirName,
                        data.fileName,
                        data.title,
                        data.subtitle,
                        data.description,
                        data.listParam,
                        data.iconTitle,
                        data.buf,
                        data.size,
                        icon_png,
                        bg_png,
                    );
                    break;
            }

            switch (result)
            {
                case RETCODE::BUSY:
                    success = true;
                    loop = false;
                    break;

                case RETCODE::SUCCESS:
                    success = true;
                    loop = false;
                    break;

                case RETCODE::CANCEL_BY_USER:
                    loop = false;
                    break;

                case RETCODE::NOSPACE:
                    var need_size_text = sutil.needSizeKB;

                    if (data.mode == MODE::AUTO ||
                        data.mode == MODE::BG || 
                        data.mode == MODE::COPYAUTO ||
                        data.mode == MODE::COPYBG)
                    {
                        DialogUtil::openConfirmDialog(context, DialogUtil::ERROR, 
                            context.translate(project, "SaveData", "ERROR_SAVE_NO_SPACE").build(need_size_text));
                    }

                    var res = DialogUtil::openConfirmDialog(context, DialogUtil::QUERY, 
                        context.translate(project, "SaveData", "DO_YOU_DELETE_OTHER_FILES"));

                    if (!res)
                    {
                        var abort_to_save = DialogUtil::openConfirmDialog(context, DialogUtil::YESNO,
                            context.translate(project, "SaveData", "DO_YOU_ABORT_TO_SAVE"));

                        if (!abort_to_save)
                            res = true;
                    }

                    if (res)
                    {
                        import __projects__::CursorProject;
                        SequenceUtil::setupTransition(context, CursorProject::ColorTransition);
                        context.pageOutRootTransition();
                        context.syncOutRootTransition();

                        res = sutil.listDelete();

                        context.pageInRootTransition();

                        if (!res)
                            loop = false;
                    }
                    else
                        loop = false;
                    break;

                default:
                    loop = false;

                    DialogUtil::openConfirmDialog(context, DialogUtil::ERROR,
                        context.translate(project, "SaveData", "ERROR_SAVE_OTHER"));
                        
                    var res = DialogUtil::openConfirmDialog(context, DialogUtil::YESNO,
                        context.translate(project, "SaveData", "DO_YOU_RETRY_TO_SAVE"));

                    if (!res)
                    {
                        DialogUtil::openConfirmDialog(context, 0,
                            context.translate(project, "SaveData", "SAVE_NOT_DONE"));

                        loop = false;    
                    }
                    else
                        loop = true;

                    break;
            }

        } while (loop);

        if (data.lastCB != nil)
            data.lastCB(context, data);

        return success;
    }

    function _autoSaveGameCallback(context, success)
    {
        var skip = false;
        if (success)
        {
            main::sound.play("ok");
            context.wait(0.5);
            skip = true;
        }

        return skip;
    }

    function _autoSave(context, args)
    {
        var [project, data, use_tsm] = args;
        var success = _save(context, project, data, use_tsm);
        return [success, _autoSaveGameCallback];
    }

    function save(context, data, use_tsm)
    {
        if (AppOpt.defined("disable_savedata"))
            return true;

        var project = context.getCursorProject();
        var res = false;

        DialogUtil::setProgress(context, nil);

        var res;
        if (data.mode == main::pdiext::SaveDataUtilMode::SAVEDATAUTIL_AUTO ||
            data.mode == main::pdiext::SaveDataUtilMode::SAVEDATAUTIL_AUTO_CREATE)
        {
            res = DialogUtil::openProgressDialog(context, 
                context.translate(project, "SaveData", "NOW_SAVING"),
                context.translate(project, "SaveData", "SAVE_DONE"),
                context.translate(project, "SaveData", "SAVE_NOT_DONE"),
                _autoSave,
                [project, data, use_tsm]
            );
        }
        else
        {
            res = _save(context, project, data, use_tsm);
        }

        return res;
    }

    function getSaveBuffer()
    {
        return main::SaveUtil.getSaveBuffer();
    }

    function getBackgroundSaveResult()
    {
        var success = RETCODE::FATAL_ERROR;

        if (!sSaveBGIssued)
            return main::pdiext::SaveDataUtilError::SAVEDATAUTIL_SUCCESS;

        if (data.mode != MODE::BG && data.mode != MODE::COPYBG)
            return success;

        if (!sSaveBGIssued)
            return;
        else
            sSaveBGIssued = false;

        if (check_only)
            check_only = false;

        var icon_png = data.iconPngName;
        var bg_png = data.bgPngName;

        var project = context.getCursorProject();
        var sutil = main::SaveUtil();
        sutil.sync();
        var result = sutil.getStatus();

        if (check_only != nil && check_only == true)
        {
            if (result != RETCODE::SUCCESS)
                sSaveBGIssued = true;

            return result;
        }

        var retry = false;

        switch (result)
        {
            case RETCODE::SUCCESS:
                break;

            case RETCODE::CANCEL_BY_USER:
                break;

            case RETCODE::NOSPACE:
                var need_size_text = sutil.needSizeKB;

                DialogUtil::openConfirmDialog(context, DialogUtil::ERROR, 
                    context.translate(project, "SaveData", "ERROR_SAVE_NO_SPACE"));

                var res = DialogUtil::openConfirmDialog(context, DialogUtil::QUERY, 
                    context.translate(project, "SaveData", "DO_YOU_DELETE_OTHER_FILES"));

                if (!res)
                {
                    var abort_to_save = DialogUtil::openConfirmDialog(context, DialogUtil::YESNO,
                        context.translate(project, "SaveData", "DO_YOU_ABORT_TO_SAVE"));

                    if (!abort_to_save)
                        res = true;
                }

                if (res)
                {
                    import __projects__::CursorProject;
                    SequenceUtil::setupTransition(context, CursorProject::ColorTransition);
                    context.pageOutRootTransition();
                    context.syncOutRootTransition();

                    res = sutil.listDelete();

                    context.pageInRootTransition();

                    if (!res)
                        retry = false;
                }
                break;

            case RETCODE::BIND_ERROR:
                DialogUtil::openConfirmDialog(context, 2, 
                    context.translate(project, "SaveData", "ERROR_SAVE_BINDCHECK"));
                break;

            default:
                DialogUtil::openConfirmDialog(context, 2, 
                    context.translate(project, "SaveData", "ERROR_SAVE_OTHER"));

                var res = DialogUtil::openConfirmDialog(context, 1, 
                    context.translate(project, "SaveData", "DO_YOU_RETRY_TO_SAVE"));

                if (!res)
                {
                    var abort_to_save = DialogUtil::openConfirmDialog(context, DialogUtil::YESNO,
                        context.translate(project, "SaveData", "SAVE_NOT_DONE"));
                }
                else
                    retry = true;

        }

        if (retry)
        {
            if (data.mode == MODE::BG)
            {
                result = sutil.backgroundSave(
                    data.secure,
                    data.canCopy,
                    data.bindCheck,
                    data.compress,
                    data.encrypt,
                    data.dirName,
                    data.fileName,
                    data.title,
                    data.subtitle,
                    data.description,
                    data.listParam,
                    data.iconTitle,
                    data.buf,
                    data.size,
                    nil,
                    nil,
                    data.indicatorPosition,
                    data.indicatorAlign,
                    data.indicatorMode,
                    data.indicatorMessage,
                    data.indicatorPngName,
                );
            }
            
            if (data.mode == MODE::COPYBG)
            {
                result = sutil.copyToBackgroundSave(
                    data.secure,
                    data.canCopy,
                    data.bindCheck,
                    data.compress,
                    data.encrypt,
                    data.dirName,
                    data.fileName,
                    data.title,
                    data.subtitle,
                    data.description,
                    data.listParam,
                    data.iconTitle,
                    data.buf,
                    data.size,
                    nil,
                    nil,
                    data.indicatorPosition,
                    data.indicatorAlign,
                    data.indicatorMode,
                    data.indicatorMessage,
                    data.indicatorPngName);
            }

            sSaveBGIssued = true;
            success = result;
        }

        return success;
    }

    /////////////////////////////////////
    ///////// LOADING ///////////////////
    /////////////////////////////////////
    static sLoadResult;

    function _load(context, data)
    {
        var sutil = main::SaveUtil;

        switch (data.mode)
        {
            case MODE::FIXED:
                [result, buf] = sutil.fixedLoad(
                    data.secure,
                    data.bindCheck,
                    data.compress,
                    data.encrypt,
                    data.dirName,
                    data.fileName,
                    data.buf
                );
                break;

            case MODE::COPYFIXED:
                [result, buf] = sutil.copyFromFixedLoad(
                    data.secure,
                    data.bindCheck,
                    data.compress,
                    data.encrypt,
                    data.dirName,
                    data.fileName,
                    data.buf
                );
                break;

            case MODE::BG:
                sSaveBGIssued = true;

                [result, buf] = sutil.backgroundLoad(
                    data.secure,
                    data.canCopy,
                    data.bindCheck,
                    data.compress,
                    data.encrypt,
                    data.dirName,
                    data.buf,
                    data.indicatorPosition,
                    data.indicatorAlign,
                    data.indicatorMode,
                    data.indicatorMessage,
                    data.indicatorPngName,
                );
                break;

            case MODE::COPYBG:
                sSaveBGIssued = true;

                [result, buf] = sutil.copyFromBackgroundLoad(
                    data.secure,
                    data.canCopy,
                    data.bindCheck,
                    data.compress,
                    data.encrypt,
                    data.dirName,
                    data.fileName,
                    data.buf,
                    data.indicatorPosition,
                    data.indicatorAlign,
                    data.indicatorMode,
                    data.indicatorMessage,
                    data.indicatorPngName,
                );
                break;

            case MODE::AUTO:
                DialogUtil::setProgress(context, sutil.progress);

                [result, buf] = sutil.autoLoad(
                    data.secure,
                    data.bindCheck,
                    data.compress,
                    data.encrypt,
                    data.dirName,
                    data.fileName,
                    data.buf
                );
                break;

            case MODE::COPYAUTO:
                DialogUtil::setProgress(context, sutil.progress);

                [result, buf] = sutil.copyFromAutoLoad(
                    data.secure,
                    data.bindCheck,
                    data.compress,
                    data.encrypt,
                    data.dirName,
                    data.fileName,
                    data.buf
                );
                break;

            case MODE::LIST:
                [result, buf] = sutil.listLoad(
                    data.secure,
                    data.bindCheck,
                    data.compress,
                    data.encrypt,
                    data.dirName,
                    data.fileName,
                    data.buf
                );
                break;

            case MODE::COPYLIST:
                [result, buf] = sutil.copyFromListLoad(
                    data.secure,
                    data.bindCheck,
                    data.compress,
                    data.encrypt,
                    data.dirName,
                    data.fileName,
                    data.buf
                );
                break;

            case MODE::MULTILIST:
                [result, buf] = sutil.multiFileListLoad(
                    data.secure,
                    data.bindCheck,
                    data.compress,
                    data.encrypt,
                    data.dirName,
                    data.fileName,
                    data.buf
                );
                break;
        }

        switch (result)
        {
            case RETCODE::BUSY:
                sLoadResult = [result, nil, false, false];
                success = true;
                break;
            
            case RETCODE::SUCCESS:
                if (data.mode == MODE::COPYFIXED ||
                    data.mode == MODE::COPYBG ||
                    data.mode == MODE::COPYAUTO ||
                    data.mode == MODE::COPYLIST ||
                    data.mode == MODE::MULTILIST)
                {
                    sLoadResult = [result, nil, false, false];
                    break;
                }

                if (buf == nil)
                {
                    var project = context.getCursorProject();
                    DialogUtil::openConfirmDialog(context, DialogUtil::ERROR
                        context.translate(project, "SaveData", "LOADED_DATA_WAS_WRONG"));
                    DialogUtil::openConfirmDialog(context, DialogUtil::ERROR
                        context.translate(project, "SaveData", "LOAD_NOT_DONE"));
                    sLoadResult = [result, nil, true, false];
                }
                else
                {
                    sLoadResult = [result, buf, false, false];
                    if (data.complete_func != nil)
                        data.complete_func(context, buf, data);

                    success = true;
                }
                break;

            case RETCODE::CANCEL_BY_USER:
                sLoadResult = [result, nil, false, false];
                break;

            case RETCODE::FATAL_ERROR:
                sLoadResult = [result, nil, true, true];
                break;

            case RETCODE::F_MALLOC:
            case RETCODE::NO_ENOUGH_BUFFER_TO_LOAD:
                sLoadResult = [result, nil, false, true];
                break;

            case RETCODE::BIND_ERROR:
                var project = context.getCursorProject();
                DialogUtil::openConfirmDialog(context, DialogUtil::ERROR,
                    context.translate(project, "SaveData", "ERROR_LOAD_BINDCHECK"));
                sLoadResult = [result, nil, true, false];
                break;

            case RETCODE::BIND_NEED_RECREATE:
                if (data.mode == MODE::COPYFIXED ||
                    data.mode == MODE::COPYBG ||
                    data.mode == MODE::COPYAUTO ||
                    data.mode == MODE::COPYLIST ||
                    data.mode == MODE::MULTILIST)
                {
                    sLoadResult = [result, nil, false, false];
                    break;
                }

                if (buf == nil)
                {
                    var project = context.getCursorProject();
                    DialogUtil::openConfirmDialog(context, DialogUtil::ERROR
                        context.translate(project, "SaveData", "LOADED_DATA_WAS_WRONG"));
                    DialogUtil::openConfirmDialog(context, DialogUtil::ERROR
                        context.translate(project, "SaveData", "LOAD_NOT_DONE"));
                    sLoadResult = [result, nil, true, false];
                }
                else
                {
                    sLoadResult = [result, buf, false, false];
                    if (data.complete_func != nil)
                        data.complete_func(context, buf, data);

                    success = true;
                }
                break;

            case RETCODE::NO_DIRNAME:
            case RETCODE::NO_FILENAME:
            default:
                sLoadResult = [result, nil, true, false];
                break;
        }

        return success;
    }

    function _autoLoadGameCallback(context, success)
    {
        var skip = false;
        if (success)
        {
            main::sound.play("ok");
            context.wait(0.5);
            skip = true;
        }

        return skip;
    }

    function _autoLoad(context, args)
    {
        var [data] = args;
        var success = _load(context, data);

        return [success, _autoLoadGameCallback];
    }

    function load(context, data)
    {
        if (AppOpt.defined("disable_loaddata"))
            return [nil, false, false];
        
        var res = false;

        if (data.mode == MODE::AUTO || data.mode == MODE::COPYAUTO)
        {
            var project = context.getCursorProject();

            res = DialogUtil::openProgressDialog(context, 
                context.translate(project, "SaveData", "NOW_LOADING"),
                context.translate(project, "SaveData", "LOAD_DONE"),
                context.translate(project, "SaveData", "LOAD_NOT_DONE"),
                _autoLoad,
                [data]
            );
        }
        else
        {
            res = _load(context, data);
        }

        var result = sLoadResult;
        sLoadResult = nil;
        return result;
    }

    function getBackgroundLoadResult(context, need_recovery = true)
    {
        if (AppOpt.defined("disable_loaddata"))
            return [RETCODE::CORRUPT_DATA, nil, false, false];

        var success = false;
        var sutil = main::SaveUtil;
        sutil.sync();
        var result = sutil.getStatus();
        var buf = sutil.getLoadBuffer();

        switch (result)
        {
            case RETCODE::SUCCESS:
                sLoadResult = [result, nil, false, false];
                success = true;
                break;

            case RETCODE::CANCEL_BY_USER:
                sLoadResult = [result, nil, false, false];
                break;

            case RETCODE::FATAL_ERROR:
                var project = context.getCursorProject();
                DialogUtil::openConfirmDialog(context, DialogUtil::ERROR
                    context.translate(project, "SaveData", "LOADED_DATA_WAS_WRONG"));
                DialogUtil::openConfirmDialog(context, DialogUtil::ERROR
                    context.translate(project, "SaveData", "LOAD_NOT_DONE"));
                sLoadResult = [result, nil, true, false];
                sLoadResult = [result, nil, true, true]; // Don't ask

                break;

            case RETCODE::F_MALLOC:
            case RETCODE::NO_ENOUGH_BUFFER_TO_LOAD:
                var project = context.getCursorProject();
                DialogUtil::openConfirmDialog(context, DialogUtil::ERROR
                    context.translate(project, "SaveData", "LOADED_DATA_WAS_WRONG"));
                DialogUtil::openConfirmDialog(context, DialogUtil::ERROR
                    context.translate(project, "SaveData", "LOAD_NOT_DONE"));
                sLoadResult = [result, nil, true, false];
                sLoadResult = [result, nil, false, true];
                break;

            case RETCODE::BIND_ERROR:
                var project = context.getCursorProject();
                DialogUtil::openConfirmDialog(context, DialogUtil::ERROR
                    context.translate(project, "SaveData", "ERROR_LOAD_BINDCHECK"));
                sLoadResult = [result, nil, true, false];
                break;

            case RETCODE::BIND_NEED_RECREATE:
                sLoadResult = [result, nil, false, false];
                success = true;
                break;

            case RETCODE::NO_DIRNAME:
            case RETCODE::NO_FILENAME:
                sLoadResult = [result, nil, true, false];
                break;

            default:
                var project = context.getCursorProject();
                var res = DialogUtil::openConfirmDialog(context, DialogUtil::YESNO
                    context.translate(project, "SaveData", "CORRUPTED_DO_YOU_RETRY_TO_LOAD"));

                if (!res)
                {
                    DialogUtil::openConfirmDialog(context, DialogUtil::ERROR
                        context.translate(project, "SaveData", "LOAD_NOT_DONE"));
                    sLoadResult = [result, true, true];
                }
                else
                {
                    sLoadResult = [main::pdiext::SaveDataUtilError::SAVEDATAUTIL_NEED_RETRY_LOAD, true, true];
                }
                break;
        }  

        result = sLoadResult;
        sLoadResult = nil;
        return result;
    }

    function _export(context, data)
    {
        var sutil = main::SaveUtil;
        var result;

        switch (data.mode)
        {
            case MODE::FIXED:
                result = sutil.fixedExport(data.dirName, data.fileName);
                break;

            case MODE::AUTO:
            case MODE::BG:
                break;
            
            case MODE::LIST:
                result = sutil.listExport(data.dirName, data.fileName);
                break;
        }

        var success = false;
        switch (result)
        {
            case RETCODE::SUCCESS:
                success = true;
                break;

            default: 
                break;
        }

        return success;
    }

    function export(context, data)
    {
        return _export(context, data);
    }

    function _import(context, data)
    {
        var project = context.getCursorProject();
        var sutil = main::SaveUtil;
        var success = false;
        var loop = true;
        
        do
        {
            var result = nil;

            switch (data.mode)
            {
                case MODE::FIXED:
                    result = sutil.fixedImport(data.dirName, data.fileName);
                    break;

                case MODE::AUTO:
                case MODE::BG:
                    break;

                case MODE::LIST:
                    result = sutil.listImport(data.dirName, data.fileName);
                break;
            }

            return true;

            // Unreachable code
            switch (result)
            {
                case RETCODE::SUCCESS:
                    success = true;
                    loop = false;
                    break;

                case RETCODE::CANCEL_BY_USER:
                    loop = false;
                    break;

                case main::pdiext::SaveDataUtilError::SAVEDATAUTIL_NOMORE_SPACE:
                    var need_size_text = sutil.needSizeKB;

                    if (data.mode == MODE::AUTO ||
                        data.mode == MODE::BG)
                    {
                        DialogUtil::openConfirmDialog(context, DialogUtil::ERROR, 
                            context.translate(project, "SaveData", "ERROR_SAVE_NO_SPACE").build(need_size_text));
                    }

                    var res = DialogUtil::openConfirmDialog(context, DialogUtil::QUERY, 
                        context.translate(project, "SaveData", "DO_YOU_DELETE_OTHER_FILES"));

                    if (!res)
                    {
                        var abort_to_save = DialogUtil::openConfirmDialog(context, DialogUtil::YESNO,
                            context.translate(project, "SaveData", "DO_YOU_ABORT_TO_SAVE"));

                        if (!abort_to_save)
                            res = true;
                    }

                    if (res)
                    {
                        import __projects__::CursorProject;
                        SequenceUtil::setupTransition(context, CursorProject::ColorTransition);
                        context.pageOutRootTransition();
                        context.syncOutRootTransition();

                        res = sutil.listDelete();

                        context.pageInRootTransition();

                        if (!res)
                            loop = false;
                    }
                    else
                        loop = false;
                    break;

                default:
                    loop = false;
                    DialogUtil::openConfirmDialog(context, DialogUtil::ERROR, 
                        context.translate(project, "SaveData", "ERROR_SAVE_OTHER"));

                    res = DialogUtil::openConfirmDialog(context, 1, 
                        context.translate(project, "SaveData", "DO_YOU_RETRY_TO_SAVE"));

                    if (!res)
                    {
                        DialogUtil::openConfirmDialog(context, DialogUtil::ERROR, 
                            context.translate(project, "SaveData", "SAVE_NOT_DONE"));
                        loop = false;
                    }
                    else
                        loop = true;
                    break;
                    
            }
        } while (loop);

        return success;
    }

    function import(context, data)
    {
        return _import(context, data);
    }

    function listDelete(context)
    {
        var sutil = main::SaveUtil;
        sutil.listDelete();
    }

    function _fixedDelete(context, data)
    {
        var project = context.getCursorProject();
        var sutil = main::SaveUtil;
        var success = false;
        var loop = true;
        var reuslt = nil;

        import __projects__::CursorProject;

        context.pageOutRootTransition();
        context.syncOutRootTransition();

        while (loop)
        {
            var result = sutil.fixedDelete(data.dirName);

            context.pageInRootTransition();

            switch (result)
            {
                case RETCODE::SUCCESS:
                    success = true;
                    loop = false;
                    break;

                case RETCODE::CANCEL_BY_USER:
                    loop = false;
                    break;

                default:
                    loop = false;
                        DialogUtil::openConfirmDialog(context, DialogUtil::ERROR, 
                            context.translate(project, "SaveData", "ERROR_DELETE_OTHER"));

                        res = DialogUtil::openConfirmDialog(context, 1, 
                            context.translate(project, "SaveData", "DO_YOU_RETRY_TO_DELETE"));

                        if (!res)
                        {
                            DialogUtil::openConfirmDialog(context, DialogUtil::ERROR, 
                                context.translate(project, "SaveData", "DELETE_NOT_DONE"));
                            loop = false;
                        }
                        else
                            loop = true;
                        break;
            }
        }

        return success;
    }
}