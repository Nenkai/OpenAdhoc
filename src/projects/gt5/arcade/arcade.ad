













module PROJECT
{
    import main::SequenceUtil;
    import main::DialogUtil;
    import main::SoundUtil;
    import main::WatcherUtil;
    import main::CourseData;
    import main::GameParameterUtil;
    import main::SceneFaceUtil;
    import main::SpecDatabaseUtil;
    import main::CursorUtil;
    import main::LeaveDetectUtil;

    PROJECT.load("/scripts/gt5/util/ProjectHistoryUtil");

    static additional_projects;
    static gEnableStandardCars;
    static gEnablePremiumCars;
    static gEnableDirtSnowCars;
    static gEnableRacingKarts;
    static gEnableCourses;
    static gEnableCourseDataMap;
    static gDifficultySetting;
    static gAbortSequence = false;
    static gLeaveDetectTime;
    static gDrivingOption;


    module ArcadeModeEnum
    {
        static SINGLE_RACE = 0;
        static TIME_ATTACK = 1;
        static DRIFT_ATTACK = 2;
        static SPLIT_BATTLE = 3;
        static MY_GAME = 4;
    }

    module DifficultyEnum
    {
        static NONE = -1;
        static EASY = 0;
        static NORMAL = 1;
        static PRO = 2;
    }

    module Function {
        module CourseMaker 
        {
            #include "projects/gt5/race_course_edit/CourseMakerFunction.ad"
        }
    }

    class CourseParameter
    {
        attribute course_code_;
        attribute start_datetime_;
        attribute time_progress_speed_;
        attribute is_day_;
        attribute rain_situation_;
        attribute snow_situation_;
        attribute weather_changeable_;
        attribute time_changeable_;
        attribute decisive_weather_;

        method __init__(course_code, start_datetime, time_progress_speed, decisive_weather)
        {
            self.course_code_ = course_code;
            var course_info = CourseData::getCourseInfo(course_code);

            self.start_datetime_ = start_datetime;
            if (start_datetime_.hour != nil && start_datetime_.hour > -1)
                self.is_day_ = 6 <= start_datetime.hour && start_datetime.hour < 18;
            else
                self.is_day_ = true;
            self.time_progress_speed_ = time_progress_speed;
            self.time_changeable_ = course_info.basetime_min < course_info.basetime_max;

            if (decisive_weather == gtengine::DecisiveWeather::NONE)
            {
                var rain_situation = course_info.rain_situation;
                var snow_situation = rain_situation && course_info.celsius_base0 < 0;
                if (snow_situation)
                {

                    self.rain_situation_ = false;
                    self.snow_situation_ = true;
                }
                else if (rain_situation)
                {

                    self.rain_situation_ = true;
                    self.snow_situation_ = false;
                }
                else
                {

                    self.rain_situation_ = false;
                    self.snow_situation_ = false;
                    self.decisive_weather_ == gtengine::DecisiveWeather::SUNNY;
                }
                self.weather_changeable_ = snow_situation || rain_situation;
            }
            else if (decisive_weather == gtengine::DecisiveWeather::SUNNY)
            {
                self.snow_situation_ = false;
                self.rain_situation_ = false;
                self.weather_changeable_ = false;
            }
            else if (decisive_weather == gtengine::DecisiveWeather::RAINY)
            {
                self.snow_situation_ = false;
                self.rain_situation_ = true;
                self.weather_changeable_ = false;
            }
            else if (decisive_weather == gtengine::DecisiveWeather::SNOWY)
            {
                self.snow_situation_ = true;
                self.rain_situation_ = false;
                self.weather_changeable_ = false;
            }
            self.decisive_weather_ = decisive_weather;
        }
    }

    class CourseDataHolder
    {
        attribute is_edit_course_;
        attribute course_parameter_;
        attribute course_pathway_;
        attribute edit_course_data_;
        method __init__(course_parameter, course_pathway, edit_course_data)
        {
            self.course_parameter_ = course_parameter;
            self.course_pathway_ = course_pathway;
            self.edit_course_data_ = edit_course_data;
            if (self.edit_course_data_ != nil && self.course_pathway_ != nil)
                self.is_edit_course_ = true;
            else
                self.is_edit_course_ = false;
        }
        method getCourseCode()
        {
            if (self.is_edit_course_)
                return self.course_pathway_.TemplateCourseCode;
            else if (self.course_parameter_ != nil)
                return self.course_parameter_.course_code_;
            else
                return main::gtengine::MSpecDB::NO_CODE64;
        }
        method getDecisiveWeather()
        {
            if (self.is_edit_course_)
                return self.edit_course_data_.weather;
            else
                return self.course_parameter_.decisive_weather_;
        }
    }

    class ArcadeSequence
    {
        class Page
        {
            attribute page_;
            attribute next_;
            attribute prev_;
            method __init__(page, next, prev)
            {
                self.page_ = page;
                self.next_ = next;
                self.prev_ = prev;
            }
        }

        static mode_sequence = [ArcadeModeEnum::SINGLE_RACE: [CourseRoot, CarRoot],
                                ArcadeModeEnum::TIME_ATTACK: [CourseRoot, CarRoot],
                                ArcadeModeEnum::DRIFT_ATTACK: [CourseRoot, CarRoot],
                                ArcadeModeEnum::SPLIT_BATTLE: [CourseRoot, CarSplitBaseRoot],
                                ArcadeModeEnum::MY_GAME: [MyGameSelectRoot, CourseRoot, CarRoot]
        ];

        attribute mode_;
        attribute tmp_index_;
        attribute index_;
        attribute pages_;
        attribute gp_;
        attribute selected_course_;

        method __init__(page, next, prev)
        {
            mode_ = nil;
            index_ = 0;
            tmp_index_ = 0;
            pages_ = Array();
            pages_.push(Page(RaceModeRoot));
            gp_ = nil;
            selected_course_ = nil;
        }

        method setArcadeMode(mode) {
            mode_ = mode;
            var sequence = mode_sequence[mode_];
            pages_ = Array();
            sequence = [RaceModeRoot] + sequence;
            for (var i = 0; i < sequence.size; i++)
            {
                var page; var next; var prev;
                page = sequence[i];
                if (i + 1 < sequence.size)
                    next = sequence[i + 1];
                if (0 < i)
                    prev = sequence[i - 1];
                pages_.push(Page(page, next, prev));
            }
            index_ = 0;
            tmp_index_ = 0;
            gp_ = nil;
        }

        method getArcadeMode() {return mode_;}

        method setGP(gp) {gp_ = gp;}
        method getGP() {return gp_;}

        method getNextPage(i) {return pages_[i].next_;}

        method getCurrentPage(i) {return pages_[i].page_;}

        method getPrevPage(i) {return pages_[i].prev_;}

        method setSelectedCourse(course_parameter, course_pathway, edit_course_data) {
            self.selected_course_ = CourseDataHolder(course_parameter, course_pathway, edit_course_data);
        }

        method getSelectedCourse() 
        {
            return selected_course_;
        }

        method moveNextPage(context) 
        {
            var next_page = getNextPage(tmp_index_);
            if (next_page != nil)
            {
                tmp_index_++;

                var result = next_page.open(context, true);
                if (result)
                {
                    var close_page = self.getCurrentPage(index_);
                    close_page.close(context);
                    index_ = tmp_index_;
                } else 
                {
                    tmp_index_ = index_;
                }
                return result;
            } 
            else 
            {
                var course_data_holder = getSelectedCourse();
                if (gp_ != nil)
                {
                    var gp = main::gtengine::MGameParameter();
                    gp.deepCopy(gp_);

                    return goRaceSequence(context, gp.event.game_mode, gp, course_data_holder);
                }
                else if (self.mode_ != nil)
                {
                    switch (self.mode_)
                    {
                        case ArcadeModeEnum::TIME_ATTACK:
                            return goRaceSequence(context, gtengine::GameMode::TIME_ATTACK, nil, course_data_holder);
                        case ArcadeModeEnum::SINGLE_RACE:
                            return goRaceSequence(context, gtengine::GameMode::SINGLE_RACE, nil, course_data_holder);
                        case ArcadeModeEnum::DRIFT_ATTACK:
                            return goRaceSequence(context, gtengine::GameMode::DRIFT_ATTACK, nil, course_data_holder);
                        case ArcadeModeEnum::SPLIT_BATTLE:
                            return goRaceSequence(context, gtengine::GameMode::SPLIT_BATTLE, nil, course_data_holder);
                        default:
                    }
                }

                main::sound.play("disable");
                return false;
            }
        }

        method movePrevPage(context) 
        {
            var prev_page = getPrevPage(tmp_index_);
            if (prev_page != nil)
            {
                tmp_index_--;

                var result = prev_page.open(context, false);
                if (result)
                {
                    var close_page = self.getCurrentPage(index_);
                    close_page.close(context);
                    index_ = tmp_index_;
                } 
                else 
                {
                    tmp_index_ = index_;
                }
                return result;
            } 
            else 
            {
                SequenceUtil::startProject(context, "gttop");
            }
        }
    }

    static gArcadeSequence = ArcadeSequence();

    function parseCarXML(xml_data)
    {
        var premium_cars = [];
        var standard_cars = [];
        var dirt_snow_cars = [];
        var racing_karts = [];

        var xml = main::pdistd::MXml();
        xml.parse(xml_data);
        var dom = xml.result;
        var xml_nodes = dom["CarData"];
        if (xml_nodes.size <= 0)
            return [premium_cars, standard_cars, dirt_snow_cars, racing_karts];

        var xml_node = xml_nodes[0];
        var premium_car_nodes = xml_node["premium_car"];
        if (premium_car_nodes != nil)
        {
            premium_cars = Array(premium_car_nodes.size);
            for (var i = 0; i < premium_car_nodes.size; i++)
            {
                var car_node = premium_car_nodes[i];
                var car_label = car_node.getAttribute("code");
                var car_color = car_node.getAttribute("color");
                premium_cars[i] = [gtengine::MSpecDB::getCarCode(car_label), car_color];
            }
        }
        /*standard_car_nodes = xml_node["standard_car"];
        if (standard_car_nodes != nil)
        {
            standard_cars = Array(standard_car_nodes.size);
            for (var i = 0; i < standard_car_nodes.size; i++)
            {
                car_node = standard_car_nodes[i];
                car_label = car_node.getAttribute("code");
                car_color = car_node.getAttribute("color");
                standard_cars[i] = [gtengine::MSpecDB::getCarCode(car_label), car_color];
            }
        }*/
        var dirt_snow_car_nodes = xml_node["dirt_car"];
        if (dirt_snow_car_nodes != nil)
        {
            dirt_snow_cars = Array(dirt_snow_car_nodes.size);
            for (var i = 0; i < dirt_snow_car_nodes.size; i++)
            {
                var car_node = dirt_snow_car_nodes[i];
                var car_label = car_node.getAttribute("code");
                var car_color = car_node.getAttribute("color");
                dirt_snow_cars[i] = [gtengine::MSpecDB::getCarCode(car_label), car_color];
            }
        }
        var racing_kart_nodes = xml_node["racing_kart"];
        if (racing_kart_nodes != nil)
        {
            racing_karts = Array(racing_kart_nodes.size);
            for (var i = 0; i < racing_kart_nodes.size; i++)
            {
                var car_node = racing_kart_nodes[i];
                var car_label = car_node.getAttribute("code");
                var car_color = car_node.getAttribute("color");
                racing_karts[i] = [gtengine::MSpecDB::getCarCode(car_label), car_color];
            }
        }

        return [premium_cars, standard_cars, dirt_snow_cars, racing_karts];
    }

    function loadArcadeCarXml(context, carlist_file)
    {
        var s0 = main::pdistd::GetSystemTimeMicroSecond();

        var standard_cars = [];
        var premium_cars = [];
        var dirt_snow_cars = [];
        var racing_karts = [];

        var fst = main::pdistd::ReadFile(carlist_file);
        var buf = fst["buffer"];
        if (buf != nil)
        {
            |premium_cars, standard_cars, dirt_snow_cars, racing_karts| = parseCarXML(buf);
        }

        gEnableStandardCars = [];
        for (var i = 0; i < standard_cars.size; i++)
        {
            |var car_code, var car_color| = standard_cars[i];
            if (car_code == gtengine::MSpecDB::NO_CODE64)
                continue;

            var cp = main::gtengine::MCarThin(car_code);
            cp.color = car_color == nil ? 0 : car_color;
            gEnableStandardCars.push(cp);
        }

        gEnablePremiumCars = [];
        for (var i = 0; i < premium_cars.size; i++)
        {
            |var car_code, var car_color| = premium_cars[i];
            if (car_code == gtengine::MSpecDB::NO_CODE64)
                continue;

            var cp = main::gtengine::MCarThin(car_code);
            cp.color = car_color == nil ? 0 : car_color;
            gEnablePremiumCars.push(cp);
        }

        gEnableDirtSnowCars = [];
        for (var i = 0; i < dirt_snow_cars.size; i++)
        {
            |var car_code, var car_color| = dirt_snow_cars[i];
            if (car_code == gtengine::MSpecDB::NO_CODE64)
                continue;

            var cp = main::gtengine::MCarThin(car_code);
            cp.color = car_color == nil ? 0 : car_color;
            gEnableDirtSnowCars.push(cp);
        }

        gEnableRacingKarts = [];
        for (var i = 0; i < racing_karts.size; i++)
        {
            |var car_code, var car_color| = racing_karts[i];
            if (car_code == gtengine::MSpecDB::NO_CODE64)
                continue;

            var cp = main::gtengine::MCarThin(car_code);
            cp.color = car_color == nil ? 0 : car_color;
            gEnableRacingKarts.push(cp);
        }

        var s1 = main::pdistd::GetSystemTimeMicroSecond();
    }

    function parseCourseXML(xml_data)
    {
        var coursedata_list = [];

        var xml = main::pdistd::MXml();
        xml.parse(xml_data);
        var dom = xml.result;
        var xml_nodes = dom["CourseData"];
        if (xml_nodes.size <= 0)
            return coursedata_list;

        var xml_node = xml_nodes[0];
        var course_nodes = xml_node["course"];
        if (course_nodes != nil)
        {
            coursedata_list = Array(course_nodes.size);
            for (var i = 0; i < course_nodes.size; i++)
            {
                var course_node = course_nodes[i];
                var course_label = course_node.getAttribute("code");
                var decisive_weather_str = course_node.getAttribute("decisive_weather");
                if (decisive_weather_str == nil)
                    decisive_weather_str = "NONE";
                var decisive_weather = gtengine::DecisiveWeather[decisive_weather_str];
                var datetime_str = course_node.getAttribute("start_datetime");
                |var h, var m| = datetime_str.split(":");
                var datetime = pdistd::MTime::getCurrentTime();
                datetime.hour = h.toInt();
                datetime.minute = m.toInt();

                var time_progress_speed = course_node.getAttribute("time_progress_speed").toFloat();
                coursedata_list[i] = [gtengine::MSpecDB::getCourseCode(course_label), 
                                    datetime, 
                                    time_progress_speed, 
                
                                    decisive_weather];
            }
        }

        return coursedata_list;
    }

    function loadArcadeCourseXml(context, courselist_file)
    {
        var coursedata_list = [];

        var fst = main::pdistd::ReadFile(courselist_file);
        var buf = fst["buffer"];
        if (buf != nil)
        {
            coursedata_list = parseCourseXML(buf);
        }
        gEnableCourses = [];
        for (var i = 0; i < coursedata_list.size; i++)
        {
            |var course_code, var start_datetime, var time_progress_speed, var decisive_weather| = coursedata_list[i];
            if (course_code == gtengine::MSpecDB::NO_CODE64)
                continue;

            var crs_param = PROJECT::CourseParameter(course_code,
                                                           start_datetime,
                                                           time_progress_speed,
                                                           decisive_weather);
            gEnableCourses.push(crs_param);
        }
    }

    method onLoad(context)
    {

        context.createRenderContext(1);
        var render_context = context.getRenderContext(0);

        ProjectHistoryUtil::DefineVariables(PROJECT,
                [['RaceModeRoot::SelectedArcadeMode', nil]]);

        main::CommandAlias::begin();

        loadProjects();

        if ("demo" == GetVersionBranch())
        {
            loadArcadeCarXml(context, "/textdata/gt5/arcade_carlist_e3.xml");
        }

        loadArcadeCourseXml(context, "/textdata/gt5/arcade_courselist.xml");

        var difficulty = main::pdiapp::XmlUtil::load_map_and_array("/textdata/gt5/arcade_difficulty.xml", "DifficultyData", "difficulty", "name");
        gDifficultySetting = difficulty.map;

        gLeaveDetectTime = GAME_STATUS.user_profile.option.timeout_count_to_topmenu;

        SequenceUtil::startPage(render_context, ArcadeRoot, [RaceModeRoot, OverLapRoot]);
    }

    method onUnload(update_context)
    {
        main::CommandAlias::end();

        ignorePadEvent(false, true);

        unloadProjects();
    }

    function loadProjects()
    {
        additional_projects = Array();
        foreach (var project_name in [])
        {
            var project = main::manager.loadProject("%{main::PROJECT_ROOT_DIR}/%{project_name}/%{project_name}");
            additional_projects.push(project);
        }
    }

    function unloadProjects()
    {
        foreach (var project in additional_projects)
        {
            main::manager.unloadProject(project);
        }
        additional_projects = nil;
    }

    function getArcadeModeEnable(arcade_mode)
    {
        switch (arcade_mode)
        {
            case ArcadeModeEnum::SINGLE_RACE:
                return GAME_STATUS.user_profile.option.visible_icon_singlerace;
            case ArcadeModeEnum::TIME_ATTACK:
                return GAME_STATUS.user_profile.option.visible_icon_timetrial;
            case ArcadeModeEnum::DRIFT_ATTACK:
                return GAME_STATUS.user_profile.option.visible_icon_drifttrial;
            case ArcadeModeEnum::SPLIT_BATTLE:
                return GAME_STATUS.user_profile.option.visible_icon_split;
            case ArcadeModeEnum::MY_GAME:
                return GAME_STATUS.user_profile.option.visible_icon_usercustom;
        }
        return true;
    }

    static counter = 0;
    function ignorePadEvent(bool, conter_reset=false)
    {
        if (conter_reset)
            counter = 0;

        if (bool)
        {
            if (counter == 0)
            {
                CursorUtil::setCursor(ContextMain, "wait");
                ContextMain.event_mask = 5;
                ContextMain.disableInput();
                ContextMain.filterKeyEvent();

                CursorUtil::setCursor(Context1P, "wait");
                Context1P.event_mask = 5;
                Context1P.disableInput();
                Context1P.filterKeyEvent();

                CursorUtil::setCursor(Context2P, "wait");
                Context2P.event_mask = 10;
                Context2P.disableInput();
                Context2P.filterKeyEvent();
            }
            counter++;

        } 
        else 
        {
            if (0 < counter) {
                counter--;
            }
            if (counter == 0)
            {
                CursorUtil::setCursor(ContextMain, "cursor_chrome");
                ContextMain.event_mask = 5;
                ContextMain.enableInput();

                CursorUtil::setCursor(Context1P, "cursor_chrome");
                Context1P.event_mask = 5;
                Context1P.enableInput();

                CursorUtil::setCursor(Context2P, "cursor_chrome");
                Context2P.event_mask = 10;
                Context2P.enableInput();
            }
        }
    }

    function checkBSpecCommand(context)
    {
        if ("presentation" == GAME_STATUS.user_profile.option.demo_version_code)
        {
            var state = context.getUpdateContext().getPadButtonState(0);

            return state & 2048 && state & 512;
        }

        return false;
    }

    function setup_driving_option(context, gp, cp, dp, player_no)
    {
        var rp = gp.event.race_parameter;
        var constraint = gp.event.constraint;
        var difficulty = GAME_STATUS.user_profile.context.arcade_difficulty;
        var difficulty_name = ["easy", "normal", "pro"];
        var course_code = gp.event.track.course_code;

        if ("demo" == GetVersionBranch())
        {
            var dp2 = main::Residence::create_player(true, player_no);
            if (constraint.driving_line == -1)
                dp.display_driving_line = dp2.display_driving_line;
            if (constraint.simulation == -1)
                dp.physics_pro = dp2.physics_pro;
            if (constraint.transmission == -1)
                dp.manual = dp2.manual;
            if (constraint.active_steering == -1)
                dp.active_steering = dp2.active_steering;
            if (constraint.asm == -1)
                dp.assist_asm = dp2.assist_asm;
            if (constraint.tcs == -1)
                dp.assist_tcs = dp2.assist_tcs;
            if (constraint.tcs == -1)
                cp.quicktune_tcs = 5;

            if (gp.event.game_mode == gtengine::GameMode::SINGLE_RACE)
            {
                var map = gDifficultySetting[difficulty_name[difficulty]];
                dp.manual = map["manual"];
                dp.physics_pro = map["simulation"];
                dp.display_driving_line = map["line"];
            }
        }

        var result;
        if (difficulty == PROJECT::DifficultyEnum::EASY)
        {
            if (cp.isATOnly())
            {
                main::sound.play("next");
                result = true;
            }
            else if (gp.event.game_mode != gtengine::GameMode::SPLIT_BATTLE)
            {
                OverLapRoot.onEasyModeOption(context);

                result = EasyModeOptionRoot.open(context, cp, dp);
            }
        }
        else
        {

            if (gp.event.game_mode != gtengine::GameMode::SPLIT_BATTLE)
            {
                OverLapRoot.onDrivingOption(context);
                OverLapRoot::ButtonHelpGT5.hide();
            }

            var data = SettingProject::DrivingOptionRoot::Data(cp, dp, rp, constraint);
            switch (gp.event.game_mode)
            {
                case gtengine::GameMode::SINGLE_RACE:

                    data.visible_laps = true;
                    data.visible_consumption = true;
                    data.visible_low_mu_type = true;
                    data.visible_behavior_damage_type = true;
                    break;

                case gtengine::GameMode::SPLIT_BATTLE:
                    if (player_no == 0) {
                        data.visible_laps = true;
                        data.laps_min = 1;
                        data.visible_low_mu_type = true;
                        data.visible_behavior_damage_type = true;
                    }
                    data.split_battle = true;
                    data.window_id = player_no;


                    if (cp.rentacar)
                        cp.ownArcadePartsAll();
                    break;

                case gtengine::GameMode::DRIFT_ATTACK:

                    data.visible_low_mu_type = true;
                    data.visible_behavior_damage_type = true;

                    if (gp.event.track.course_pathway == nil)
                        data.visible_drift_type = true;
                    break;

                case gtengine::GameMode::TIME_ATTACK:

                    if ("sls" == GAME_STATUS.user_profile.option.demo_version_code ||
                        "86gp_final" == GAME_STATUS.user_profile.option.demo_version_code)
                    {
                        data.visible_low_mu_type = false;
                        data.visible_behavior_damage_type = false;
                    } 
                    else 
                    {
                        data.visible_low_mu_type = true;
                        data.visible_behavior_damage_type = true;
                    }
                    break;

            }

            data.course_code = course_code;
            data.activate_sound = "next";

            gDrivingOption = data;
            var result = SettingProject::DrivingOptionRoot.OpenDialog(context, data);
            gDrivingOption = nil;

            var info = CourseData::getCourseInfo(course_code);
            if (info.rain_situation && rp.race_limit_laps >= 10)
            {
                rp.enable_pit = true;
            }
            else if (rp.consume_tire == false && rp.consume_fuel == false)
            {
                rp.enable_pit = false;
            }

            if (!result && gp.event.game_mode != gtengine::GameMode::SPLIT_BATTLE)
                OverLapRoot::ButtonHelpGT5.appear();

        }
        if (result)
        {

            if (checkBSpecCommand(context))
                gp.event.play_style.bspec_type = gtengine::BSpecType::ONLY_B;


            if (GAME_STATUS.user_profile.context.arcade_onemake_race)
                gp.event.entry_set.entry_generate.generate_type = main::gtengine::GenerateType::ONE_MAKE;
        
        }

        return result;
    }



    function applyDifficulty(context, gp)
    {
        var difficulty_name = ["easy", "normal", "pro"];
        var map = gDifficultySetting[difficulty_name[GAME_STATUS.user_profile.context.arcade_difficulty]];

        var event = gp.event;
        var rp = event.race_parameter;
        var entry_set = event.entry_set;

        entry_set.entry_generate.ai_roughness = GAME_STATUS.user_profile.option.arcade_ai_roughness;

        entry_set.entry_generate.ai_skill_accelerating = map["ai_skill_a"];
        entry_set.entry_generate.ai_skill_breaking = map["ai_skill_b"];
        entry_set.entry_generate.ai_skill_cornering = map["ai_skill_c"];

        rp.setBoostParams(map["boost_f"], map["boost_r"], map["boost_fmax"], map["boost_rmax"], map["boost_fmin"], map["boost_rmin"]);
        rp.replace_at_courseout = map["replace_at_courseout"];
    }


    function applyArcadeSpecialSetting(context, gp, course_data_holder)
    {
        var course = GAME_STATUS.user_profile.context.arcade_course;

        var oval = false;
        var course_info = CourseData::getCourseInfo(course);
        if (course_info != nil)
        {
            oval = course_info.oval;
        }

        var event = gp.event;
        var entry_set = event.entry_set;
        var entry_generate = entry_set.entry_generate;
        var rp = event.race_parameter;

        if (oval)
        {
            entry_generate.player_pos = entry_generate.entry_num - 1;

            rp.start_type = gtengine::StartType::ROLLING_DL;


            var difficulty_name = ["nascar_easy", "nascar_normal", "nascar_pro"];
            var map = gDifficultySetting[difficulty_name[GAME_STATUS.user_profile.context.arcade_difficulty]];

            entry_set.entry_generate.ai_skill = map["ai_skill"];

            rp.setBoostParams(map["boost_f"], map["boost_r"], map["boost_fmax"], map["boost_rmax"], map["boost_fmin"], map["boost_rmin"]);
        }
        else
        {
            if (course_data_holder.is_edit_course_)
                rp.start_type = gtengine::StartType::GRID;
            else
                rp.start_type = gtengine::StartType::ROLLING2;

            switch (GAME_STATUS.user_profile.context.arcade_difficulty)
            {
                case PROJECT::DifficultyEnum::EASY:
                    rp.rolling_player_grid = entry_generate.player_pos;
                    break;
                case PROJECT::DifficultyEnum::NORMAL:
                case PROJECT::DifficultyEnum::PRO:
                    if (entry_generate.entry_num >= 12)
                        entry_generate.player_pos = 11;
                    else
                        entry_generate.player_pos = entry_generate.entry_num - 1;

                    rp.rolling_player_grid = entry_generate.player_pos;
                    break;
            }
        }

        var cp0 = GAME_STATUS.user_profile.context.getArcadeCar(0);
        var re = Regexp(".*nascar.*");
        var label = main::gtengine::MSpecDB::getCarLabel(cp0.getCarCode());
        if (re.match(label) && oval)
        {
            gp.event.race_parameter.flagset = gtengine::RaceFlagSet::FLAGSET_NASCAR;
        }
    }


    function createSingleRace(context, course_code, course_data_holder, is_racing_kart)
    {
        var gp;
        var entry_max = CourseData::getEntryMax(course_code);
        var laps = GAME_STATUS.user_profile.option.arcade_laps;
        if ("campo" == gtengine::MSpecDB::getCourseLabel(course_code))
            laps *= 3;

        if (course_data_holder.is_edit_course_)
        {
            var course_pathway = course_data_holder.course_pathway_;
            var edit_course_data = course_data_holder.edit_course_data_;

            var old_edit_course_entry_max = 12;
            if (edit_course_data.online_race == 0 && entry_max > old_edit_course_entry_max)
            {
                entry_max = old_edit_course_entry_max;
            }

            gp = GameParameterUtil::createSingleRaceWithCustomCourse(course_code,
                                                                    course_pathway,
                                                                    entry_max,
                                                                    laps,
                                                                    nil,
                                                                    nil,
                                                                    nil,
                                                                    nil,
                                                                    nil,
                                                                    is_racing_kart);

            var data = CursorProject::LoadingRoot::EditCourseData(gp, course_pathway.title);
            CursorProject::LoadingRoot.setData(data);
        }
        else if (is_racing_kart)
        {
            gp = GameParameterUtil::createSingleRaceRacingKart(course_code,
                                                            entry_max,
                                                            laps,
                                                            nil,
                                                            nil,
                                                            nil,
                                                            nil,
                                                            nil,
                                                            true);
        }
        else
        {
            gp = GameParameterUtil::createSingleRace(course_code,
                                                    entry_max,
                                                    laps,
                                                    nil,
                                                    nil,
                                                    nil,
                                                    nil,
                                                    nil,
                                                    false);
        }

        return gp;
    }


    function createTimeAttack(context, course_code, course_data_holder, is_racing_kart)
    {
        var gp;
        if (course_data_holder.is_edit_course_)
        {
            var course_pathway = course_data_holder.course_pathway_;
            gp = GameParameterUtil::createTimeAttack(course_code);

            var course_pathway_bin;
            if (course_pathway.isInstanceOf(gtengine::MCoursePathway))
                course_pathway_bin = course_pathway.serialize();
            else
                course_pathway_bin = course_pathway;
            gp.event.track.course_pathway = course_pathway_bin;

            var data = CursorProject::LoadingRoot::EditCourseData(gp, course_pathway.title);
            CursorProject::LoadingRoot.setData(data);
        }
        else
        {
            gp = GameParameterUtil::createTimeAttack(course_code);
        }

        var rp = gp.event.race_parameter;
        var timetrial_laps = GAME_STATUS.user_profile.option.arcade_timetrial_laps;
        if (timetrial_laps > 0)
        {
            rp.complete_type = gtengine::CompleteType::BYLAPS;
            rp.finish_type = gtengine::FinishType::TARGET;
            rp.time_to_finish = 3000;
            rp.race_limit_laps = timetrial_laps;
        }
        
        return gp;
    }

    function createDriftAttack(context, course_code, course_data_holder, is_racing_kart)
    {
        var gp;
        if (course_data_holder.is_edit_course_)
        {
            var course_pathway = course_data_holder.course_pathway_;
            var gp = GameParameterUtil::createDriftAttack(course_code, 0, 0);
            gp.event.race_parameter.endless = true;
            
            var course_pathway_bin;
            if (course_pathway.isInstanceOf(gtengine::MCoursePathway))
                course_pathway_bin = course_pathway.serialize();
            else
                course_pathway_bin = course_pathway;
            gp.event.track.course_pathway = course_pathway_bin;

            var data = CursorProject::LoadingRoot::EditCourseData(gp, course_pathway.title);
            CursorProject::LoadingRoot.setData(data);
        }
        else
        {
            gp = GameParameterUtil::createDriftAttack(course_code, 0, 0);
        }
        return gp;
    }

    function createSplitBattle(context, course_code, course_data_holder)
    {
        var gp;
        var cp0 = GAME_STATUS.user_profile.context.getArcadeCar(0);
        var dp0 = GAME_STATUS.user_profile.residence.getArcadePlayer(0);

        var cp1 = GAME_STATUS.user_profile.context.getArcadeCar(1);
        var dp1 = GAME_STATUS.user_profile.residence.getArcadePlayer(1);

        dp0.display_name = dp0.display_name + "[1]";

        if (course_data_holder.is_edit_course_)
        {
            var course_pathway = course_data_holder.course_pathway_;
            var gp = GameParameterUtil::createSplitBattle(course_code, [cp0, cp1], [dp0, dp1]);

            var course_pathway_bin;
            if (course_pathway.isInstanceOf(gtengine::MCoursePathway))
                course_pathway_bin = course_pathway.serialize();
            else
                course_pathway_bin = course_pathway;
            gp.event.track.course_pathway = course_pathway_bin;




            var data = CursorProject::LoadingRoot::EditCourseData(gp, course_pathway.title);
            CursorProject::LoadingRoot.setData(data);
        }
        else
        {
            gp = GameParameterUtil::createSplitBattle(course_code, [cp0, cp1], [dp0, dp1]);
        }

        gp.event.race_parameter.low_mu_type = GAME_STATUS.user_profile.context.arcade_low_mu_type;
        gp.event.race_parameter.behavior_damage_type = GAME_STATUS.user_profile.context.arcade_behavior_damage_type;

        return gp;
    }


    function goRaceSequence(context, game_mode, gp, course_data_holder)
    {
        var course_code = course_data_holder.getCourseCode();
        var course_label = main::gtengine::MSpecDB::getCourseLabel(course_code);
        GAME_STATUS.user_profile.context.arcade_course = course_label;

        var driving_option = setup_driving_option;

        GameParameterUtil::begin();

        var cp0;
        switch (game_mode)
        {
            case gtengine::GameMode::TIME_ATTACK:

                cp0 = GAME_STATUS.user_profile.context.getArcadeCar(0);
                var is_racing_kart = gtengine::MSpecDB::checkGenericFlag("is_racing_kart", cp0.getCarCode());

                if (gp == nil)
                    gp = createTimeAttack(context, course_code, course_data_holder, is_racing_kart);
                break;

            case gtengine::GameMode::SINGLE_RACE:

                cp0 = GAME_STATUS.user_profile.context.getArcadeCar(0);
                var is_racing_kart = gtengine::MSpecDB::checkGenericFlag("is_racing_kart", cp0.getCarCode());

                if (gp == nil)
                    gp = createSingleRace(context, course_code, course_data_holder, is_racing_kart);

                applyDifficulty(context, gp);
                applyArcadeSpecialSetting(context, gp, course_data_holder);
                break;

            case gtengine::GameMode::DRIFT_ATTACK:

                cp0 = GAME_STATUS.user_profile.context.getArcadeCar(0);
                var is_racing_kart = gtengine::MSpecDB::checkGenericFlag("is_racing_kart", cp0.getCarCode());


                if (gp == nil)
                    gp = createDriftAttack(context, course_code, course_data_holder, is_racing_kart);
                break;

            case gtengine::GameMode::SPLIT_BATTLE:
                driving_option = nil;
                if (gp == nil)
                    gp = createSplitBattle(context, course_code, course_data_holder);

                if (GAME_STATUS.user_profile.option.simulview_2p_battle &&
                    pdiext::MSystemConfiguration::isSimulViewAvailable())
                {
                    var warning = context.translate(context.getCursorProject(), "SystemMessage", "SCE_SIMULVIEW_WARNING");
                    CursorProject::LoadingRoot::setData(CursorProject::LoadingRoot::WarningTextData(warning, 10));
                    SoundUtil::BGMFadeout(3.0);
                }
                break;
        }

        var edit_course_data_id;
        if (course_data_holder.is_edit_course_)
        {
            var edit_course_data = course_data_holder.edit_course_data_;
            var rp = gp.event.race_parameter;

            var start_datetime = pdistd::MTime();
            start_datetime.setBySecond(edit_course_data.start_datetime);

            Function::CourseMaker::setupWeatherAndTimeChange(
                rp,
                edit_course_data.weather_value0,
                edit_course_data.initial_retention,
                edit_course_data.weather_accel,
                start_datetime,
                edit_course_data.time_progress_speed
            );

            edit_course_data_id = edit_course_data.id;
        }
        else
        {
            var course_parameter = course_data_holder.course_parameter_;
            var rp = gp.event.race_parameter;
            

            if (course_parameter.weather_changeable_)
            {
                rp.decisive_weather = gtengine::DecisiveWeather::NONE;
            
                if ("demo" == GetVersionBranch())
                {
                    rp.weather_no_precipitation = false;
                    if (course_parameter.rain_situation_)
                    {
                        rp.weather_prec_rain_only = true;
                        rp.weather_prec_snow_only = false;
                    }
                    else if (course_parameter.snow_situation_)
                    {
                        rp.weather_prec_rain_only = false;
                        rp.weather_prec_snow_only = true;
                    }
                    rp.weather_random = true;
                    rp.weather_no_schedule = false;

                    rp.weather_point_num = 4;
                    rp.weather_value0 = -1.0;
                    rp.weather_value1 = 1.0;
                    rp.weather_value2 = 0.5;
                    rp.weather_value3 = 0.0;
                    rp.weather_rate_sec1 = 480;
                    rp.weather_rate_sec2 = 780;
                    rp.weather_total_sec = 1080;
                    rp.weather_accel100 = 1000;
                }
                else
                {
                    rp.weather_no_precipitation = false;
                    if (course_parameter.rain_situation_)
                    {
                        rp.weather_prec_rain_only = true;
                        rp.weather_prec_snow_only = false;
                    }
                    else if (course_parameter.snow_situation_)
                    {
                        rp.weather_prec_rain_only = false;
                        rp.weather_prec_snow_only = true;
                    }
                    rp.weather_random = true;
                    rp.weather_no_schedule = false;
                    rp.weather_point_num = 4;
                    rp.weather_value0 = 0.0;
                    rp.weather_value1 = 0.0;
                    rp.weather_value2 = 0.0;
                    rp.weather_value3 = 0.0;
                    rp.weather_rate_sec1 = 60;
                    rp.weather_rate_sec2 = 120;
                    rp.weather_total_sec = 180;
                    rp.weather_accel100 = 1000;
                }
            } 
            else 
            {
                rp.decisive_weather = course_parameter.decisive_weather_;
            }

            rp.time_progress_speed = course_parameter.time_progress_speed_;
            rp.datetime = course_parameter.start_datetime_;

            edit_course_data_id = -1;

        }

        gp.event.race_parameter.accumulation = true;
        gp.event.race_parameter.enable_damage = GAME_STATUS.user_profile.option.arcade_enable_damage;

        main::GAME_STATUS.user_profile.option.edit_course_data_id = edit_course_data_id;

        var result = GameParameterUtil::executeArcade(context, gp, GAME_STATUS, driving_option);

        GameParameterUtil::end();

        if (!result)
        {
            CursorProject::LoadingRoot.setData(nil);

            if (gAbortSequence)
                return nil;
        }
        else
        {
            if (LoginUtil::isOnline())
            {
                cp0 = GAME_STATUS.user_profile.context.getArcadeCar(0);
                var car_label = main::gtengine::MSpecDB::getCarLabel(cp0.getCarCode());

                var strlog = "FM=%d:FS=%s:FC=%s:FD:%d:FU=%s".format(game_mode, course_label, car_label, GAME_STATUS.user_profile.context.arcade_difficulty, main::PDINetwork.getClientName());
                main::Grim2.requestPutLog(strlog);
            }
        }

        return result;
    }


    method abort(context)
    {
        gAbortSequence = true;
        if (gDrivingOption != nil)
            gDrivingOption.modal_page.popup_page.abort(context);
        EasyModeOptionRoot.abort(context);
    }

    method onLeaveDetect(context)
    {


        abort(context);
        SequenceUtil::startProject(context, "gttop");
    }
}