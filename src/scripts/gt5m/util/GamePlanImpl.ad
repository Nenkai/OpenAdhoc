//---------------------------------------------------------------------------------------
// GamePlanImpl.ad
//
//
// 
//---------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------
// module
//---------------------------------------------------------------------------------------

function createRaceParameter(gp, event_idx)
{
    if (gp.events == nil)
        return;

    if (event_idx == nil)
        event_idx = 0;

    if (event_idx >= gp.events.size)
        return;

    var rp = main::gtengine::MRaceParameter();
    var event = gp.events[event_idx];
    var race = event.race;
    if (race != nil)
    {
        if (race.race_type != nil)
            rp.race_type = race.race_type;
        if (race.start_type != nil)
            rp.start_type = race.start_type;
        if (race.complete_type != nil)
            rp.complete_type = race.complete_type;
        if (race.finish_type != nil)
            rp.finish_type = race.finish_type;
        if (race.race_limit_laps != nil)
            rp.race_limit_laps = race.race_limit_laps;
        if (race.race_limit_minute != nil)
            rp.race_limit_minute = race.race_limit_minute;
        if (race.time_to_start != nil)
            rp.time_to_start = race.time_to_start * 1000;
        if (race.time_to_finish != nil)
            rp.time_to_finish = race.time_to_finish * 1000;
        if (race.racers_max != nil)
            rp.racers_max = race.racers_max;
        if (race.immediate_finish != nil)
            rp.immediate_finish = race.immediate_finish;
        if (race.grid_sort_type != nil)
            rp.grid_sort_type = race.grid_sort_type;
        if (race.endless != nil)
            rp.endless = race.endless;
        if (race.with_ghost != nil)
        {
            rp.with_ghost = race.with_ghost;
            rp.entry_max = race.racers_max + 1;
        }
        if (race.disable_collision != nil)
            rp.disable_collision = race.disable_collision;
        if (race.penalty_level != nil)
            rp.penalty_level = race.penalty_level;
        if (race.accumulation != nil)
            rp.accumulation = race.accumulation;

        if (race.boost_lv != nil)
        {
            race.boost_lv > 5; // Presumably something half-commented?

            switch (race.boost_lv)
            {
                case 0: 
                default:
                    break;

                case 1: rp.setBoostParams(0, 8, 30, 30, 5, 5); break;
                case 2: rp.setBoostParams(5, 6, 50, 50, 10, 10); break;
                case 3: rp.setBoostParams(6, 5, 50, 50, 10, 10); break;
                case 4: rp.setBoostParams(8, 5, 30, 30, 10, 10); break;
                case 5: rp.setBoostParams(10, 8, 20, 20, 10, 10); break;
            }
        }


        if (race.lucky_player != nil)
            rp.lucky_slot_id = race.lucky_player;
    }

    var track = event.track;
    if (track != nil)
    {
        rp.course_code = track.course_code;
        if (track.course_layout_no != nil)
            rp.course_layout_no = track.course_layout_no;
        if (track.goal_position != nil)
        {
            rp.setEventV(0, track.goal_position);
            if (track.goal_width != nil)
                rp.setEventV(1, track.goal_position + track.goal_width);

            if (track.goal_width != nil && track.goal_width < 0)
                rp.setEventV(1, -1);
        }
        else
        {
            rp.setEventV(0, -1);
            rp.setEventV(1, -1);
        }
    }

    var entry_set = event.entry_set;
    if (entry_set != nil && entry_set.entries != nil)
    {
        var use_initial_position = false;
        for (var i = 0; i < entry_set.entries.size; i++)
        {

            var entry = entry_set.entries[i];
            if (entry.initial_position != nil)
            {
                use_initial_position = true;
                rp.setLaunchPosition(i, entry.initial_position);
            } 
            else 
                rp.setLaunchPosition(i, 0);

            if (entry.initial_velocity != nil)
                rp.setLaunchSpeed(i, entry.initial_velocity);
            else 
                rp.setLaunchSpeed(i, 0);

            if (entry.delay != nil)
                rp.setDelayStartSecond(i, entry.delay);
        }


        rp.useLaunchData(use_initial_position);
    }
    
    return rp;
}

function create_node_value(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {
        var node = main::pdistd::MDomNode();
        node.addAttribute("value", attr);
        gnode.addNode(attrname, node);
    }
}

function create_node_hex(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {
        var node = main::pdistd::MDomNode();
        if (attr.isInstanceOf(ULong))
            node.addAttribute("value", "0x%lx".format(attr.toULong()));
        else
            node.addAttribute("value", "0x%lx".format(attr.toLong()));

        gnode.addNode(attrname, node);
    }
}

function create_node_int(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {
        var node = main::pdistd::MDomNode();
        node.addAttribute("value", "%d".format(attr.toInt()));
        gnode.addNode(attrname, node);
    }
}

function create_node_minmax(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {
        var node = main::pdistd::MDomNode();
        var pair = attr;
        node.addAttribute("min", pair[0]);
        node.addAttribute("max", pair[1]);
        gnode.addNode(attrname, node);
    }
}

function create_node_array(gnode, group, plural_attrname, attrname)
{
    var attr = group.getObjectAttribute(plural_attrname);
    if (attr != nil)
    {
        var node = main::pdistd::MDomNode();
        foreach (var elem in attr)
        {
            var node0 = main::pdistd::MDomNode();
            node0.addAttribute("value", elem);
            node.addNode(attrname, node0);
        }
        gnode.addNode(plural_attrname, node);
    }
}

function create_node_int_array(gnode, group, plural_attrname, attrname)
{
    var attr = group.getObjectAttribute(plural_attrname);
    if (attr != nil)
    {
        var node = main::pdistd::MDomNode();
        foreach (var elem in attr)
        {
            var node0 = main::pdistd::MDomNode();
            node0.addAttribute("value", elem.toInt());
            node.addNode(attrname, node0);
        }
        gnode.addNode(plural_attrname, node);
    }
}

function create_node_cars(gnode, group)
{
    var attr = group.getObjectAttribute("cars");
    if (attr != nil)
    {
        var node = main::pdistd::MDomNode();
        foreach (var car in attr)
        {
            var node0 = main::pdistd::MDomNode();
            node0.addAttribute("code", "0x%x".format(car.code));
            if (car.color != nil)
                node0.addAttribute("color", car.color);
            node.addNode("car", node0);
        }
        gnode.addNode("cars", node);
    }
}

function create_node_bin(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {
        var compressed = main::pdistd::Deflate(attr);
        var value = main::pdistd::EncodeBase64(compressed);
        var node = main::pdistd::MDomNode();
        node.addAttribute("value", value);
        gnode.addNode(attrname, node);
    }
}

function createXML(gp, for_race)
{
    if (for_race == nil)
        for_race = false;

    var gp_node = main::pdistd::MDomNode();
    gp_node.addAttribute("version", GamePlan::VERSION.toString());

    var events = gp.events;
    if (events != nil)
    {
        var events_node = main::pdistd::MDomNode();

        for (var i = 0; i < events.size; i++)
        {
            var event = events[i];
            var event_node = createEventXML(event);
            events_node.addNode("event", event_node);
        }

        gp_node.addNode("events", events_node);
    }

    var online_room = gp.online_room;
    if (online_room != nil)
    {
        var online_room_node = main::pdistd::MDomNode();
        create_node_value(online_room_node, online_room, "comment");
        create_node_value(online_room_node, online_room, "password");
        create_node_hex(online_room_node, online_room, "modifiable");
        create_node_int(online_room_node, online_room, "policy");
        create_node_int(online_room_node, online_room, "chat_type");
        create_node_int(online_room_node, online_room, "room_max");
        create_node_int(online_room_node, online_room, "racer_max");
        create_node_int(online_room_node, online_room, "auto_grant_ownership");
        create_node_int(online_room_node, online_room, "nat_restriction");
        create_node_int(online_room_node, online_room, "allow_only_friend");
        create_node_int(online_room_node, online_room, "exclude_blocklist");
        create_node_int(online_room_node, online_room, "voice_chat");
        create_node_int(online_room_node, online_room, "voice_quality");
        create_node_int(online_room_node, online_room, "race_quality");
        create_node_int(online_room_node, online_room, "network_topology");
        gp_node.addNode("online_room", online_room_node);
    }

    var reward = gp.series_reward;
    if (reward != nil)
    {
        var reward_node = createRewardXML(reward);
        gp_node.addNode("series_reward", reward_node);
    }

    var information = gp.series_information;
    if (information != nil)
    {
        var information_node = createInformationXML(information);
        gp_node.addNode("series_information", information_node);
    }

    if (!for_race)
    {
        var replay_list = gp.replay_list;
        if (replay_list != nil)
        {
            var replay_list_node = main::pdistd::MDomNode();
            for (var i = 0; i < replay_list.size; i++)
            {
                var replay = replay_list[i];
                var replay_node = createReplayXML(replay);
                replay_list_node.addNode("replay", replay_node);
            }
            gp_node.addNode("replay_list", replay_list_node);
        }
    }

    var editor_info = gp.editor_info;
    if (editor_info != nil)
    {
        var editor_info_node = main::pdistd::MDomNode();
        create_node_int(editor_info_node, editor_info, "psp_mode");

        gp_node.addNode("editor_info", editor_info_node);
    }

    var xml_data = gp_node.serialize("GamePlan");

    return xml_data;
}

function createEventXML(event)
{
    var event_node = main::pdistd::MDomNode();

    create_node_value(event_node, event, "game_mode");

    var play_style = event.play_style;
    if (play_style != nil)
    {
        var play_style_node = main::pdistd::MDomNode();
        create_node_int(play_style_node, play_style, "bspec_type");
        create_node_int(play_style_node, play_style, "play_type");
        create_node_int(play_style_node, play_style, "trackday_type");
        create_node_int(play_style_node, play_style, "no_quickmenu");
        create_node_int(play_style_node, play_style, "no_instant_replay");
        create_node_int(play_style_node, play_style, "window_num");
        create_node_int(play_style_node, play_style, "time_limit");
        create_node_int(play_style_node, play_style, "leave_limit");
        event_node.addNode("play_style", play_style_node);
    }

    create_node_int(event_node, event, "event_type");
    create_node_value(event_node, event, "inheritance");

    var regulation = event.regulation;
    if (regulation != nil)
    {
        var regulation_node = main::pdistd::MDomNode();

        create_node_minmax(regulation_node, regulation, "pp");
        create_node_minmax(regulation_node, regulation, "tire");
        create_node_int(regulation_node, regulation, "car_type");
        create_node_cars(regulation_node, regulation);
        create_node_value(regulation_node, regulation, "license");
        create_node_minmax(regulation_node, regulation, "power");
        create_node_minmax(regulation_node, regulation, "torque");
        create_node_minmax(regulation_node, regulation, "displacement");
        create_node_minmax(regulation_node, regulation, "weight");
        create_node_int(regulation_node, regulation, "drivetrain");
        create_node_int(regulation_node, regulation, "aspiration");
        create_node_minmax(regulation_node, regulation, "year");
        create_node_array(regulation_node, regulation, "tuners", "tuner");
        create_node_array(regulation_node, regulation, "countries", "country");

        event_node.addNode("regulation", regulation_node);
    }

    var constraint = event.constraint;
    if (constraint != nil)
    {
        var constraint_node = main::pdistd::MDomNode();
        create_node_int(constraint_node, constraint, "mission");
        create_node_int(constraint_node, constraint, "driving_line");
        create_node_int(constraint_node, constraint, "asm");
        create_node_int(constraint_node, constraint, "tcs");
        create_node_int(constraint_node, constraint, "abs");
        create_node_int(constraint_node, constraint, "simulation");
        create_node_int(constraint_node, constraint, "tire_f");
        create_node_int(constraint_node, constraint, "tire_r");
        create_node_int(constraint_node, constraint, "active_steering");
        create_node_cars(constraint_node, constraint);

        event_node.addNode("constraint", constraint_node);
    }

    var race = event.race;
    if (race != nil)
    {
        var race_node = main::pdistd::MDomNode();

        create_node_int(race_node, race, "race_type");
        create_node_int(race_node, race, "start_type");
        create_node_int(race_node, race, "complete_type");
        create_node_int(race_node, race, "finish_type");
        create_node_int(race_node, race, "race_limit_laps");
        create_node_int(race_node, race, "race_limit_minute");
        create_node_int(race_node, race, "time_to_start");
        create_node_int(race_node, race, "time_to_finish");
        create_node_int(race_node, race, "racers_max");
        create_node_int(race_node, race, "immediate_finish");
        create_node_int(race_node, race, "grid_sort_type");
        create_node_int(race_node, race, "endless");
        create_node_int(race_node, race, "with_ghost");
        create_node_int(race_node, race, "disable_collision");
        create_node_int(race_node, race, "penalty_level");
        create_node_int(race_node, race, "accumulation");
        create_node_int(race_node, race, "boost_lv");
        create_node_int(race_node, race, "lucky_player");

        event_node.addNode("race", race_node);
    }

    var track = event.track;
    if (track != nil)
    {
        var track_node = main::pdistd::MDomNode();
        create_node_hex(track_node, track, "course_code");
        create_node_int(track_node, track, "course_layout_no");
        create_node_int(track_node, track, "goal_position");
        create_node_int(track_node, track, "goal_width");

        event_node.addNode("track", track_node);
    }

    if (event.gadgets != nil)
    {
        var gadgets = event.gadgets;
        var num = gadgets.size;
        for (var i = 0; i < num; i++)
        {
            var gadget_node = main::pdistd::MDomNode();
            var gadget = gadgets[i];

            create_node_value(gadget_node, gadget, "kind");
            create_node_int(gadget_node, gadget, "id");
            create_node_array(gadget_node, gadget, "positions", "pos");
            create_node_array(gadget_node, gadget, "posture", "value");

            event_node.addNode("gadget", gadget_node);
        }
    }

    var entry_set = event.entry_set;
    if (entry_set != nil)
    {
        var entry_set_node = main::pdistd::MDomNode();

        if (entry_set.entry_generate != nil)
        {
            var entry_generate_node = main::pdistd::MDomNode();
            var entry_generate = entry_set.entry_generate;
            create_node_int(entry_generate_node, entry_generate, "entry_num");
            create_node_int(entry_generate_node, entry_generate, "player_pos");
            create_node_int(entry_generate_node, entry_generate, "generate_type");
            create_node_int(entry_generate_node, entry_generate, "ai_skill");
            create_node_int(entry_generate_node, entry_generate, "ai_skill_breaking");
            create_node_int(entry_generate_node, entry_generate, "ai_skill_cornaring");
            create_node_int(entry_generate_node, entry_generate, "enemy_lv");
            create_node_cars(entry_generate_node, entry_generate);
            create_node_int_array(entry_generate_node, entry_generate, "delays", "delay");

            entry_set_node.addNode("entry_generate", entry_generate_node);
        }

        if (entry_set.entries != nil)
        {
            var entries = entry_set.entries;
            var num = entries.size;
            for (var i = 0; i < num; i++)
            {
                var entry_node = main::pdistd::MDomNode();

                var entry = entries[i];

                create_node_int(entry_node, entry, "player_no");
                if (entry.car != nil)
                {
                    var node = main::pdistd::MDomNode();
                    node.addAttribute("code", "0x%x".format(entry.car.code));
                    if (entry.car.color != nil)
                        node.addAttribute("color", entry.car.color);
                    entry_node.addNode("car", node);
                }

                create_node_value(entry_node, entry, "driver_name");
                if (entry.car_parameter != nil)
                {
                    var node = main::pdistd::MDomNode();
                    var map = entry.car_parameter.getArchiveTree();
                    var version = map["version"];
                    var bytedata = map["data"];
                    var compressed = main::pdistd::Deflate(bytedata);
                    node.value = main::pdistd::EncodeBase64(compressed);
                    node.addAttribute("version", version);
                    entry_node.addNode("car_parameter", node);
                }
                if (entry.driver_parameter != nil)
                {
                    var node = main::pdistd::MDomNode();
                    var bytedata = entry.driver_parameter.getArchiveTree();
                    var compressed = main::pdistd::Deflate(bytedata);
                    node.value = main::pdistd::EncodeBase64(compressed);
                    entry_node.addNode("driver_parameter", node);
                }
                create_node_int(entry_node, entry, "initial_position");
                create_node_int(entry_node, entry, "initial_velocity");

                entry_set_node.addNode("entry", entry_node);
            }
        }


        event_node.addNode("entry_set", entry_set_node);
    }

    var eval_condition = event.eval_condition;
    if (eval_condition != nil)
    {
        var eval_condition_node = main::pdistd::MDomNode();

        create_node_int(eval_condition_node, eval_condition, "type");
        create_node_int_array(eval_condition_node, eval_condition, "data", "item");

        event_node.addNode("eval_condition", eval_condition_node);
    }

    var achieve_condition = event.achieve_condition;
    if (achieve_condition != nil)
    {
        var achieve_condition_node = main::pdistd::MDomNode();

        create_node_int(achieve_condition_node, achieve_condition, "type");
        create_node_int_array(achieve_condition_node, achieve_condition, "data", "item");

        event_node.addNode("achieve_condition", achieve_condition_node);
    }


    var failure_condition = event.failure_condition;
    if (failure_condition != nil)
    {
        var failure_condition_node = main::pdistd::MDomNode();

        create_node_int_array(failure_condition_node, failure_condition, "type", "item");
        create_node_int_array(failure_condition_node, failure_condition, "data", "item");

        event_node.addNode("failure_condition", failure_condition_node);
    }

    var reward = event.reward;
    if (reward != nil)
    {
        var reward_node = createRewardXML(reward);
        event_node.addNode("reward", reward_node);
    }

    var information = event.information;
    if (information != nil)
    {
        var information_node = createInformationXML(information);
        event_node.addNode("information", information_node);
    }

    return event_node;
}

function createRewardXML(reward)
{
    var reward_node = main::pdistd::MDomNode();

    create_node_int_array(reward_node, reward, "prize_table", "prize");
    create_node_int_array(reward_node, reward, "point_table", "point");
    create_node_cars(reward_node, reward);
    create_node_value(reward_node, reward, "special_reward_code");

    return reward_node;
}

function createInformationXML(information)
{
    var information_node = main::pdistd::MDomNode();

    create_node_value(information_node, information, "title");
    create_node_value(information_node, information, "description");
    create_node_int(information_node, information, "narration_id");
    create_node_value(information_node, information, "logo_image_path");
    create_node_bin(information_node, information, "logo_image");
    create_node_value(information_node, information, "logo_image_url");
    create_node_value(information_node, information, "flier_image_path");
    create_node_bin(information_node, information, "flier_image");
    create_node_value(information_node, information, "flier_image_url");
    create_node_value(information_node, information, "race_label");

    return information_node;
}


function createReplayXML(replay)
{
    var replay_node = main::pdistd::MDomNode();

    create_node_bin(replay_node, replay, "buffer");
    create_node_value(replay_node, replay, "url");
    if (replay.information != nil)
    {
        var information_node = createInformationXML(replay.information);
        replay_node.addNode("information", information_node);
    }

    return replay_node;
}

function apply_attr_value(gnode, group, attrname)
{
    var node = gnode[attrname];
    if (node != nil)
    {
        group.setObjectAttribute(attrname, node[0].getAttribute("value", 0));
    }
}

function apply_attr_hex(gnode, group, attrname, isULong)
{
    var node = gnode[attrname];
    if (node != nil)
    {
        var value;
        if (isULong != nil)
            value = node[0].getAttribute("value", 0).toULong();
        else
            value = node[0].getAttribute("value", 0).toLong();

        if (value < 0xFFFFFFFF)
            value = value.toInt();
        group.setObjectAttribute(attrname, value);
    }
}

function apply_attr_int(gnode, group, attrname)
{
    var node = gnode[attrname];
    if (node != nil)
    {
        var value = node[0].getAttribute("value", 0).toInt();
        if (value < 0xFFFFFFFF)
            value = value.toInt();
        group.setObjectAttribute(attrname, value);
    }
}

function apply_attr_minmax(gnode, group, attrname, min_default, max_default)
{
    var node = gnode[attrname];
    if (node != nil)
    {
        var pair = Array(2);
        pair[0] = node[0].getAttribute("min", min_default);
        pair[1] = node[0].getAttribute("max", max_default);
        group.setObjectAttribute(attrname, pair);
    }
}

function apply_attr_array(gnode, group, plural_attrname, attrname)
{
    var node = gnode[plural_attrname];
    if (node != nil)
    {
        var node0 = node[0][attrname];
        if (node0 != nil)
        {
            var num = node0.size;
            var array = Array(num);
            for (var i = 0; i < num; i++)
            {
                array[i] = node0[i].getAttribute("value");
            }
            group.setObjectAttribute(plural_attrname, array);
        }
    }
}

function apply_attr_int_array(gnode, group, plural_attrname, attrname)
{
    var node = gnode[plural_attrname];
    if (node != nil)
    {
        var node0 = node[0][attrname];
        if (node0 != nil)
        {
            var num = node0.size;
            var array = Array(num);
            for (var i = 0; i < num; i++)
                array[i] = node0[i].getAttribute("value").toInt();

            group.setObjectAttribute(plural_attrname, array);
        }
    }
}

function apply_attr_cars(gnode, group)
{
    var node = gnode["cars"];
    if (node != nil)
    {
        var node0 = node[0]["car"];
        if (node0 != nil)
        {
            var num = node0.size;
            var array = Array(num);
            for (var i = 0; i < num; i++)
            {
                array[i] = main::gtengine::MCarThin(node0[i].getAttribute("code").toULong(),
                                                    node0[i].getAttribute("color"));
            }
            group.setObjectAttribute("cars", array);
        }
    }
}

function apply_attr_bin(gnode, group, attrname)
{
    var node = gnode[attrname];
    if (node != nil)
    {
        var value = node[0].getAttribute("value");
        if (value == nil)
            return;

        var compressed = main::pdistd::DecodeBase64(value);
        var bytedata = main::pdistd::Inflate(compressed);
        group.setObjectAttribute(attrname, bytedata);
    }
}

function parseEventXML(event_node)
{
    var event = GamePlan::Event();

    apply_attr_int(event_node, event, "game_mode");

    var play_style_node = event_node["play_style"];
    if (play_style_node != nil)
    {
        play_style_node = play_style_node[0];
        var play_style = GamePlan::PlayStyle();
        apply_attr_int(play_style_node, play_style, "bspec_type");
        apply_attr_int(play_style_node, play_style, "play_type");
        apply_attr_int(play_style_node, play_style, "trackday_type");
        apply_attr_int(play_style_node, play_style, "no_quickmenu");
        apply_attr_int(play_style_node, play_style, "no_instant_replay");
        apply_attr_int(play_style_node, play_style, "window_num");
        apply_attr_int(play_style_node, play_style, "time_limit");
        apply_attr_int(play_style_node, play_style, "leave_limit");
        event.play_style = play_style;
    }

    apply_attr_int(event_node, event, "event_type");
    apply_attr_int(event_node, event, "inheritance");

    var regulation_node = event_node["regulation"];
    if (regulation_node != nil)
    {
        var regulation = GamePlan::Regulation();
        event.regulation = regulation;

        regulation_node = regulation_node[0];
        
        apply_attr_minmax(regulation_node, regulation, "pp", 0, 0xFFFF);
        apply_attr_minmax(regulation_node, regulation, "tire", 0, 0xFFFF);
        apply_attr_int(regulation_node, regulation, "car_type");
        apply_attr_cars(regulation_node, regulation);
        apply_attr_int(regulation_node, regulation, "license");
        apply_attr_minmax(regulation_node, regulation, "power", 0, 0xFFFF);
        apply_attr_minmax(regulation_node, regulation, "torque", 0, 0xFFFF);
        apply_attr_minmax(regulation_node, regulation, "displacement", 0, 0xFFFF);
        apply_attr_minmax(regulation_node, regulation, "weight", 0, 0xFFFF);
        apply_attr_int(regulation_node, regulation, "drivetrain");
        apply_attr_int(regulation_node, regulation, "aspiration");
        apply_attr_minmax(regulation_node, regulation, "year", 0, 0xFFFF);
        apply_attr_array(regulation_node, regulation, "tuners", "tuner");
        apply_attr_array(regulation_node, regulation, "countries", "country");
    }

    var constraint_node = event_node["constraint"];
    if (constraint_node != nil)
    {
        var constraint = GamePlan::Constraint();
        event.constraint = constraint;

        constraint_node = constraint_node[0];

        apply_attr_int(constraint_node, constraint, "mission");
        apply_attr_int(constraint_node, constraint, "driving_line");
        apply_attr_int(constraint_node, constraint, "asm");
        apply_attr_int(constraint_node, constraint, "tcs");
        apply_attr_int(constraint_node, constraint, "abs");
        apply_attr_int(constraint_node, constraint, "simulation");
        apply_attr_int(constraint_node, constraint, "tire_f");
        apply_attr_int(constraint_node, constraint, "tire_r");
        apply_attr_int(constraint_node, constraint, "active_steering");
        apply_attr_cars(constraint_node, constraint);
    }

    var race_node = event_node["race"];
    if (race_node != nil)
    {
        var race = GamePlan::Race();
        event.race = race;

        race_node = race_node[0];

        apply_attr_int(race_node, race, "race_type");
        apply_attr_int(race_node, race, "start_type");
        apply_attr_int(race_node, race, "complete_type");
        apply_attr_int(race_node, race, "finish_type");
        apply_attr_int(race_node, race, "race_limit_laps");
        apply_attr_int(race_node, race, "race_limit_minute");
        apply_attr_int(race_node, race, "time_to_start");
        apply_attr_int(race_node, race, "time_to_finish");
        apply_attr_int(race_node, race, "racers_max");
        apply_attr_int(race_node, race, "immediate_finish");
        apply_attr_int(race_node, race, "grid_sort_type");
        apply_attr_int(race_node, race, "endless");
        apply_attr_int(race_node, race, "with_ghost");
        apply_attr_int(race_node, race, "disable_collision");
        apply_attr_int(race_node, race, "penalty_level");
        apply_attr_int(race_node, race, "accumulation");
        apply_attr_int(race_node, race, "boost_lv");
        apply_attr_int(race_node, race, "lucky_player");
    }

    var track_node = event_node["track"];
    if (track_node != nil)
    {
        var track = GamePlan::Track();
        event.track = track;

        track_node = track_node[0];
        
        apply_attr_hex(track_node, track, "course_code", true);
        apply_attr_hex(track_node, track, "course_layout_no");
        apply_attr_hex(track_node, track, "goal_position");
        apply_attr_hex(track_node, track, "goal_width");
    }

    var gadgets_node = event_node["gadget"];
    if (gadgets_node != nil)
    {
        var num = gadgets_node.size;
        event.gadgets = Array(num);

        for (var i = 0; i < num; i++)
        {
            var gadget = GamePlan::Gadget();
            event.gadgets[i] = gadget;

            var gadget_node = gadgets_node[i];
            apply_attr_value(gadget_node, gadget, "kind");
            apply_attr_int(gadget_node, gadget, "id");
            apply_attr_array(gadget_node, gadget, "positions", "pos");
            apply_attr_array(gadget_node, gadget, "posture", "value");
        }
    }

    var entry_set_node = event_node["entry_set"];
    if (entry_set_node != nil)
    {
        var entry_set = GamePlan::EntrySet();
        event.entry_set = entry_set;

        entry_set_node = entry_set_node[0];

        var entry_generate_node = entry_set_node["entry_generate"];
        if (entry_generate_node != nil)
        {
            var entry_generate = GamePlan::EntryGenerate();
            entry_set.entry_generate = entry_generate;
    
    
            entry_generate_node = entry_generate_node[0];
            apply_attr_int(entry_generate_node, entry_generate, "entry_num");
            apply_attr_int(entry_generate_node, entry_generate, "player_pos");
            apply_attr_int(entry_generate_node, entry_generate, "generate_type");
            apply_attr_int(entry_generate_node, entry_generate, "ai_skill");
            apply_attr_int(entry_generate_node, entry_generate, "ai_skill_breaking");
            apply_attr_int(entry_generate_node, entry_generate, "ai_skill_cornaring");
            apply_attr_int(entry_generate_node, entry_generate, "enemy_lv");
            apply_attr_cars(entry_generate_node, entry_generate);
            apply_attr_int_array(entry_generate_node, entry_generate, "delays", "delay");
        }

        var entries_node = entry_set_node["entry"];
        if (entries_node != nil)
        {
            var num = entries_node.size;
            entry_set.entries = Array(num);
            for (var i = 0; i < num; i++)
            {
                var entry = GamePlan::Entry();
                entry_set.entries[i] = entry;
    
                var entry_node = entries_node[i];
                
                apply_attr_int(entry_node, entry, "player_no");

                {
                    var car_node = entry_node["car"];
                    if (car_node != nil)
                    {
                        car_node = car_node[0];
                        entry.car = main::gtengine::MCarThin(car_node.getAttribute("code").toULong(), car_node.getAttribute("color"));
                    }
                }

                apply_attr_value(entry_node, entry, "driver_name");

                var car_parameter_node = entry_node["car_parameter"];
                if (car_parameter_node != nil)
                {
                    car_parameter_node = car_parameter_node[0];
                    var version = car_parameter_node.getAttribute("version");
                    var value = car_parameter_node.value;
                    var compressed = main::pdistd::DecodeBase64(value);
                    var bytedata = main::pdistd::Inflate(compressed);
                    var map = [ "version" : version, "data" : bytedata ];
                    var car_parameter = main::gtengine::MCarParameter();
                    car_parameter.setArchiveTree(map);
                    entry.car_parameter = car_parameter;
                }

                var driver_parameter_node = entry_node["driver_parameter"];
                if (driver_parameter_node != nil)
                {
                    driver_parameter_node = driver_parameter_node[0];
                    var version = driver_parameter_node.getAttribute("version");
                    var value = driver_parameter_node.value;
                    var compressed = main::pdistd::DecodeBase64(value);
                    var bytedata = main::pdistd::Inflate(compressed);
                    var driver_parameter = main::gtengine::MCarDriverParameter();
                    driver_parameter.setArchiveTree(bytedata);
                    entry.driver_parameter = driver_parameter;
                }

                apply_attr_int(entry_node, entry, "initial_position");
                apply_attr_int(entry_node, entry, "initial_velocity");
            }
        }
    }

    var eval_condition_node = event_node["eval_condition"];
    if (eval_condition_node != nil)
    {
        var eval_condition = GamePlan::EvalCondition();
        event.eval_condition = eval_condition;

        eval_condition_node = eval_condition_node[0];

        apply_attr_int(eval_condition_node, eval_condition, "type");
        apply_attr_int_array(eval_condition_node, eval_condition, "data", "item");
    }


    var achieve_condition_node = event_node["achieve_condition"];
    if (achieve_condition_node != nil)
    {
        var achieve_condition = GamePlan::AchieveCondition();
        event.achieve_condition = achieve_condition;

        achieve_condition_node = achieve_condition_node[0];

        apply_attr_int(achieve_condition_node, achieve_condition, "type");
        apply_attr_int_array(achieve_condition_node, achieve_condition, "data", "item");
    }


    var failure_condition_node = event_node["failure_condition"];
    if (failure_condition_node != nil)
    {
        var failure_condition = GamePlan::FailureCondition();
        event.failure_condition = failure_condition;

        failure_condition_node = failure_condition_node[0];

        apply_attr_int_array(failure_condition_node, failure_condition, "type", "item");
        apply_attr_int_array(failure_condition_node, failure_condition, "data", "item");
    }


    var reward_node = event_node["reward"];
    if (reward_node != nil)
    {
        event.reward = parseRewardXML(reward_node[0]);
    }


    var information_node = event_node["information"];
    if (information_node != nil)
    {
        event.information = parseInformationXML(information_node[0]);
    }

    return event;
}

function parseXML(gp, xml_data)
{
    var xml = main::pdistd::MXml();
    xml.parse(xml_data);
    var dom = xml.result;
    var gp_node = dom["GamePlan"];
    if (gp_node == nil)
        return false;

    gp_node = gp_node[0];


    var events_node = gp_node["events"];
    if (events_node != nil)
    {
        events_node = events_node[0];

        var event_node = events_node["event"];
        if (event_node != nil)
        {
            var num = event_node.size;
            gp.events = Array(num);
            for (var i = 0; i < num; i++)
            {
                gp.events[i] = parseEventXML(event_node[i]);
            }
        }
    }

    var online_room_node = gp_node["online_room"];
    if (online_room_node != nil)
    {
        online_room_node = online_room_node[0];

        var online_room = GamePlan::OnlineRoom();
        apply_attr_value(online_room_node, online_room, "comment");
        apply_attr_value(online_room_node, online_room, "password");
        apply_attr_hex(online_room_node, online_room, "modifiable");
        apply_attr_int(online_room_node, online_room, "policy");
        apply_attr_int(online_room_node, online_room, "chat_type");
        apply_attr_int(online_room_node, online_room, "room_max");
        apply_attr_int(online_room_node, online_room, "racer_max");
        apply_attr_int(online_room_node, online_room, "auto_grant_ownership");
        apply_attr_int(online_room_node, online_room, "nat_restriction");
        apply_attr_int(online_room_node, online_room, "allow_only_friend");
        apply_attr_int(online_room_node, online_room, "exclude_blocklist");
        apply_attr_int(online_room_node, online_room, "voice_chat");
        apply_attr_int(online_room_node, online_room, "voice_quality");
        apply_attr_int(online_room_node, online_room, "race_quality");
        apply_attr_int(online_room_node, online_room, "network_topology");
        gp.online_room = online_room;
    }

    var reward_node = gp_node["series_reward"];
    if (reward_node != nil)
    {
        gp.series_reward = parseRewardXML(reward_node[0]);
    }

    var information_node = gp_node["series_information"];
    if (information_node != nil)
    {
        gp.series_information = parseInformationXML(information_node[0]);
    }


    var replay_list_node = gp_node["replay_list"];
    if (replay_list_node != nil)
    {
        replay_list_node = replay_list_node[0];

        var replay_node = replay_list_node["replay"];
        if (replay_node != nil)
        {
            var num = replay_node.size;
            gp.replay_list = Array(num);
            for (var i = 0; i < num; i++)
            {
                gp.replay_list[i] = parseReplayXML(replay_node[i]);
            }
        }
    }

    var editor_info_node = gp_node["editor_info"];
    if (editor_info_node != nil)
    {

        editor_info_node = editor_info_node[0];
        var editor_info = GamePlan::RaceEditorInfo();
        apply_attr_int(editor_info_node, editor_info, "psp_mode");

        gp.editor_info = editor_info;
    }

    return true;
}

function parseRewardXML(reward_node)
{
    var reward = GamePlan::Reward();

    apply_attr_int_array(reward_node, reward, "prize_table", "prize");
    apply_attr_int_array(reward_node, reward, "point_table", "point");
    apply_attr_cars(reward_node, reward);
    apply_attr_value(reward_node, reward, "special_reward_code");

    return reward;
}

function parseInformationXML(information_node)
{

    var information = GamePlan::Information();

    apply_attr_value(information_node, information, "title");
    apply_attr_value(information_node, information, "description");
    apply_attr_int(information_node, information, "narration_id");
    apply_attr_value(information_node, information, "logo_image_path");
    apply_attr_bin(information_node, information, "logo_image");
    apply_attr_value(information_node, information, "logo_url");
    apply_attr_value(information_node, information, "flier_image_path");
    apply_attr_bin(information_node, information, "flier_image");
    apply_attr_value(information_node, information, "flier_url");
    apply_attr_value(information_node, information, "race_label");

    return information;
}

function parseReplayXML(replay_node)
{
    var replay = GamePlan::Replay();

    apply_attr_bin(replay_node, replay, "buffer");
    apply_attr_value(replay_node, replay, "url");


    var information_node = replay_node["information"];
    if (information_node != nil)
    {
        replay.information = parseInformationXML(information_node[0]);
    }

    return replay;
}

function sample()
{
    var gp = main::GamePlan();

    var event = main::GamePlan::Event();
    gp.events = [event];

    event.game_mode = main::gtengine::GameMode::SINGLE_RACE;
    event.play_style = main::GamePlan::PlayStyle();
    event.play_style.bspec_type = main::GamePlan::BSpecType::BOTH_A_AND_B;
    event.play_style.play_type = main::GamePlan::PlayType::RACE;
    event.play_style.trackday_type = main::GamePlan::TrackDayType::BOTH;
    event.play_style.no_quickmenu = false;
    event.play_style.no_instant_replay = false
    event.play_style.window_num = 2;

    event.event_type = 0;
    event.inheritance = true;

    event.regulation = main::GamePlan::Regulation();
    event.regulation.pp = [100, 200];
    event.regulation.tire = [1, 4];
    event.regulation.car_type = 4;
    event.regulation.cars = [
        main::gtengine::MCarThin("_135i_07", 1),
        main::gtengine::MCarThin("_147_ti_20_ts_06"),
        main::gtengine::MCarThin("_207_gti_07", 3)
    ];
    event.regulation.license = 5;
    event.regulation.power = [10, 500];
    event.regulation.torque = [100, 5000];
    event.regulation.displacement = [1000, 2000];
    event.regulation.weight = [100, 200];
    event.regulation.drivetrain = 5;
    event.regulation.aspiration = 6;
    event.regulation.year = [1980, 1989];
    event.regulation.tuners = [1, 2, 3, 4, 5];
    event.regulation.countries = [9, 5, 8, 3, 2];

    event.constraint = main::GamePlan::Constraint();
    event.constraint.driving_line = true;
    event.constraint.asm = true;
    event.constraint.tcs = 5;
    event.constraint.simulation = 1;
    event.constraint.active_steering = 2;
    event.constraint.cars = [
        main::gtengine::MCarThin("is_f_07", 1),
        main::gtengine::MCarThin("gtr_07", 1)
    ];

    event.race = main::GamePlan::Race();
    event.race.race_type = 1;
    event.race.start_type = 1;
    event.race.complete_type = 1;
    event.race.finish_type = 1;
    event.race.race_limit_laps = 1;
    event.race.race_limit_minute = 1;
    event.race.time_to_start = 1;
    event.race.time_to_finish = 1;
    event.race.racers_max = 1;
    event.race.immediate_finish = 1;
    event.race.grid_sort_type = 1;
    event.race.endless = 1;
    event.race.with_ghost = 1;
    event.race.disable_collision = 1;
    event.race.penalty_level = 1;
    event.race.accumulation = 1;

    event.track = main::GamePlan::Track();
    event.track.course_code = main::gtengine::MSpecDB::getCourseCode("tsukuba");
    event.track.course_layout_no = 18;
    event.track.goal_position = 100;
    event.track.goal_width = 10;

    event.entry_set = main::GamePlan::EntrySet();

    event.entry_set.entry_generate = main::GamePlan::EntryGenerate();
    event.entry_set.entry_generate.entry_num = 16;
    event.entry_set.entry_generate.player_pos = 7;
    event.entry_set.entry_generate.enemy_lv = 0;
    event.entry_set.entry_generate.cars = [
        main::gtengine::MCarThin("is_f_07", 1),
        main::gtengine::MCarThin("gtr_07", 1)
    ];
    event.entry_set.entry_generate.generate_type = main::GamePlan::GenerateType::ONE_MAKE;

    event.entry_set.entries = Array(1);

    {
        var entry = main::GamePlan::Entry();
        entry.player_no = 0;
        entry.car = main::gtengine::MCarThin("is_f_07", 0);
        entry.driver_name = "John Doe";
        entry.car_parameter = main::gtengine::MCarParameter("is_f_07");
        entry.driver_parameter = main::gtengine::MCarDriverParameter();
        entry.initial_position = 100;
        entry.initial_velocity = 1000;
        event.entry_set.entries[0] = entry;
    }

    event.eval_condition = main::GamePlan::EvalCondition();
    event.eval_condition.type = main::gtengine::EvalType::TIME;
    event.eval_condition.args = [1, 2, 3, 4];

    event.achieve_condition = main::GamePlan::AchieveCondition();
    event.achieve_condition.type = main::gtengine::AchieveType::STOP;
    event.achieve_condition.args = [1, 2, 3, 4];

    event.failure_condition = main::GamePlan::FailureCondition();
    event.failure_condition.type = [main::gtengine::FailureType::SPIN_FULL];
    event.failure_condition.args = [1, 2, 3, 4];

    event.reward = main::GamePlan::Reward();
    event.reward.prize_table = [10000, 9000, 8000, 7000];
    event.reward.point_table = [10, 9, 8, 7];
    event.reward.cars = [
        main::gtengine::MCarThin("is_f_07", 1),
        main::gtengine::MCarThin("gtr_07", 1)
    ];
    event.reward.special_reward_code = 100;
    {
        event.information = main::GamePlan::Information();
        event.information.title = "hogehoge";
        event.information.description = "piyopiyopiyopiyopiyopiyopiyopiyo";
        event.information.narration_id = 101;
        event.information.logo_image_path = "/image/hoge.png";
        event.information.logo_image = "ksdfaeaiufpsiodfpasijd";
        event.information.flier_image_path = "/image/hoge.png";
        event.information.flier_image = "ksdfaeaiufpsiodfpasijd";
    }

    gp.online_room = main::GamePlan::OnlineRoom();
    gp.online_room.password = "password";
    gp.online_room.modifiable = 0xF1F1;
    gp.online_room.policy = "policy hogehoge";
    gp.online_room.chat_type = 1;
    gp.online_room.room_max = 32;
    gp.online_room.racer_max = 12;
    gp.online_room.auto_grant_ownership = false;
    gp.online_room.nat_restriction = false;
    gp.online_room.allow_only_friend = false;
    gp.online_room.exclude_blocklist = false;
    gp.online_room.voice_chat = false;
    gp.online_room.voice_quality = 2;
    gp.online_room.race_quality = 100;
    gp.online_room.network_topology = 1;

    gp.reward = main::GamePlan::Reward();
    gp.reward.prize_table = [10000, 9000, 8000, 7000];
    gp.reward.point_table = [10, 9, 8, 7];
    gp.reward.cars = [
        main::gtengine::MCarThin("is_f_07", 1),
        main::gtengine::MCarThin("gtr_07", 1)
    ];
    gp.reward.special_reward_code = 100;

    gp.information = main::GamePlan::Information();
    gp.information.title = "foofoo";
    gp.information.description = "barbarbarbarbarbarbarbar";
    gp.information.narration_id = 101;
    gp.information.logo_image_path = "/image/hoge.png";
    gp.information.logo_image = "ksdfaeaiufpsiodfpasijd";
    gp.information.flier_image_path = "/image/hoge.png";
    gp.information.flier_image = "ksdfaeaiufpsiodfpasijd";

    var xml = gp.createXML();
    main::pdistd::WriteFile("/preview/ps3/programmer/yasuhara/test.xml", xml);

    var ra = main::GamePlan();
    gp.parseXML(xml);
    xml = gp.createXML();
    main::pdistd::WriteFile("/preview/ps3/programmer/yasuhara/test2.xml", xml);
}

function generateEntry_SHUFFLE(event, player_cp_list, entry_generate, entry_num, player_num)
{
    var car_num = entry_num - player_num;
    var car_list = Array(car_num);

    if (entry_generate.cars == nil)
        return;

    var cars = Array(entry_generate.cars.size);
    for (var i = 0; i < entry_generate.cars.size; i++)
    { cars[i] = entry_generate.cars[i].code; }
    var list = CarSetUtil::getCarSetShuffle(cars, car_num);
    for (var i = 0; i < list.size; i++)
    {
        car_list[i] = main::gtengine::MCarThin(list[i][0], list[i][1]);
    }

    return car_list;
}

function generateEntry_ONE_MAKE(event, player_cp_list, entry_generate, entry_num, player_num)
{
    var car_num = entry_num - player_num;
    var car_list = Array(car_num);

    var cp = player_cp_list[0];
    var car_code = cp.getCarCode();
    var num = main::gtengine::MSpecDB::getCarVariation(car_code);
    for (var i = 0; i < car_list.size; i++)
    {
        var col = main::pdistd::MRandom::GetValue(0, num);
        car_list[i] = main::gtengine::MCarThin(car_code, col);
    }

    return car_list;
}

function generateEntry_ENEMY_LIST(event, player_cp_list, entry_generate, entry_num, player_num)
{
    var car_num = entry_num - player_num;

    var cp = player_cp_list[0];
    cp.beginInfo();
    var pp = cp.getPP1000();

    cp.endInfo();

    var listfile;
    {
        var is_normal_car = main::gtengine::MSpecDB::getCarCategory(cp.getCarCode()) == main::gtengine::CarCategory::NORMAL;
        var is_dirt = main::gtengine::MSpecDB::isDirt(event.track.course_code);

        if (is_normal_car)
        {
            if (is_dirt)
                listfile = "enemy_normalcar_dirt.xml";
            else
                listfile = "enemy_normalcar.xml";
        }
        else
        {
            if (is_dirt)
                listfile = "enemy_racecar_dirt.xml";
            else
                listfile = "enemy_racecar.xml";
        }
    }

    var car_list;
    main::gtengine::EnemySetUtil::beginWithXml("/textdata/gt5m/" + listfile, "EnemyData", "car", "code", "pp");
    {
        var range = 10;
        car_list = main::gtengine::EnemySetUtil::getWithValueRange(pp - range, pp + range, car_num);
    }
    main::gtengine::EnemySetUtil::end();

    return car_list;
}


function generateEntry_SPEC_DB(event, player_cp_list, entry_generate, entry_num, player_num)
{
    var car_num = entry_num - player_num;
    var car_list = Array(car_num);

    var is_dirt = 0;
    var course_condition = main::gtengine::MSpecDB::getCourseCondition(event.track.course_code);
    if (course_condition == main::gtengine::CourseCondition::DIRT ||
        course_condition == main::gtengine::CourseCondition::SNOW)
        is_dirt = 1;

    main::gtengine::MSpecDB::loadMenuInfo();
    self finally {
        main::gtengine::MSpecDB::unloadMenuInfo();
    };

    var cp = player_cp_list[0];
    var enemy_lv = 0;
    if (entry_generate.enemy_lv != nil)
        enemy_lv = entry_generate.enemy_lv;

    var race_code = main::gtengine::MSpecDB::getRaceCodeFromCar(cp.getCarCode(), is_dirt, enemy_lv);
    if (race_code == nil)
    {
        return generateEntry_ENEMY_LIST(event, player_cp_list, entry_generate, entry_num, player_num);
    }

    var race_label = main::gtengine::MSpecDB::getRaceLabel(race_code);

    if (event.information != nil)
        event.information.race_label = race_label;

    return main::gtengine::MSpecDB::getOpponentCars(race_code, car_num);
}

function generateEntry(event, player_cp_list)
{
    var entry_set = event.entry_set;
    if (entry_set == nil)
        return;

    var entry_generate = entry_set.entry_generate;
    if (entry_generate == nil)
        return;

    var player_num = 0;
    if (player_cp_list != nil)
        player_num = player_cp_list.size;

    var entry_num = entry_generate.entry_num;

    var car_list;
    switch (entry_generate.generate_type)
    {
        case main::GamePlan::GenerateType::SHUFFLE:
            car_list = generateEntry_SHUFFLE(event, player_cp_list, entry_generate, entry_num, player_num);
            break;

        case main::GamePlan::GenerateType::ONE_MAKE:
            car_list = generateEntry_ONE_MAKE(event, player_cp_list, entry_generate, entry_num, player_num);
            break;

        case main::GamePlan::GenerateType::ENEMY_LIST:
            car_list = generateEntry_ENEMY_LIST(event, player_cp_list, entry_generate, entry_num, player_num);
            break;

        case main::GamePlan::GenerateType::SPEC_DB:
            car_list = generateEntry_SPEC_DB(event, player_cp_list, entry_generate, entry_num, player_num);
            break;
    }

    entry_set.entries = Array(entry_num);
    var j = 0;
    for (var i = 0; i < entry_num; i++)
    {
        var entry = main::GamePlan::Entry();
        entry_set.entries[i] = entry;
        if (i == entry_generate.player_pos)
        {
            entry.car = nil;
            entry.player_no = 0;
        }
        else
        {
            entry.car = car_list[j];
            j++;
        }

        var delays = entry_generate.delays;
        if (delays != nil && i < delays.size)
            entry.delay = delays[i];
    }
}

function reserve_entry_set(event, entry_set, player_cp_list, player_dp_list)
{
    if (entry_set.entries != nil)
    {

        var ai_driver = main::gtengine::MCarDriverParameter(main::gtengine::DriverType::GROVE);
        var ai_skill = 100;
        if (entry_set.entry_generate != nil &&
            entry_set.entry_generate.ai_skill != nil)
            ai_skill = entry_set.entry_generate.ai_skill;

        ai_driver.setGroveAIParameter("max_ai", ai_skill);

        if (entry_set.entry_generate != nil &&
            (entry_set.entry_generate.ai_skill_breaking != nil ||
             entry_set.entry_generate.ai_skill_cornaring != nil))
        {
            var b_skill = entry_set.entry_generate.ai_skill_breaking;
            var c_skill = entry_set.entry_generate.ai_skill_cornaring;

            if (b_skill == nil) b_skill = 100;
            if (c_skill == nil) c_skill = 100;
            ai_driver.setAISkill(b_skill, c_skill);
        }

        for (var i = 0; i < entry_set.entries.size; i++)
        {
            var target = false;
            var cp;
            var entry = entry_set.entries[i];
            if (entry.car_parameter != nil)
            {

                target = entry.car_parameter.target;
                cp = entry.car_parameter;
            }
            else if (entry.player_no != nil)
            {
                target = true;
                var player_no = entry.player_no;

                if (entry.car == nil)
                {
                    if (player_cp_list.size <= player_no)
                    {

                        player_no = 0;
                    }
                    cp = player_cp_list[player_no];
                }
                else
                {
                    cp = main::gtengine::MCarParameter(entry.car.code);
                    cp.color = entry.car.color;
                }
            }
            else if (entry.car != nil)
            {
                cp = main::gtengine::MCarParameter(entry.car.code);
                cp.color = entry.car.color;
            }
            else
            {
            }

            var dp;

            if (entry.driver_parameter != nil)
            {
                dp = entry.driver_parameter;
            }
            else if (entry.player_no != nil)
            {
                var player_no = entry.player_no;
                if (player_no >= 0 &&
                    (event.play_style == nil || event.play_style.play_type == PlayType::RACE))
                {
                    if (player_dp_list != nil && player_no < player_dp_list.size)
                    {
                        dp = player_dp_list[player_no];
                    }
                    else
                    {


                        dp = main::gtengine::MCarDriverParameter();
                        dp.setDefault();
                        dp.setPlayer(0);
                    }
                }
                else
                {
                    dp = ai_driver;
                    if (entry.driver_name != nil)
                        dp.display_name = entry.driver_name;
                }
            }
            else
            {
                dp = ai_driver;
            }

            setupConstraintForEntry(event, cp, dp);
            cp.setSuitableTires(event.track.course_code,
                                TireUtil::DirtTire,
                                TireUtil::SnowTire);


            main::RaceOperator.makeReservation(cp, target, dp);
        }
    }
}

function setupConstraintForEntry(event, cp, dp)
{
    var cons = event.constraint;
    if (cons == nil)
        return;

    if (cons.mission != nil)
        dp.manual = cons.mission != 0;

    if (cons.driving_line != nil)
        main::ORG.setDrivingLineDispFlag(0, cons.driving_line);

    if (cons.asm != nil)
        dp.assist_asm = cons.asm;

    if (cons.tcs != nil)
    {
        dp.assist_tcs = cons.tcs != 0;
        cp.quicktune_tcs = cons.tcs;
    }

    if (cons.abs != nil)
        cp.ABSCorneringControlLevel = cons.abs;

    if (cons.tire_f != nil)
    {
        cp.beginPartsChange();
        cp.setFrontTireCategory(TireUtil::convMenuIndexToTireIndex(TireUtil::CategoryAll, cons.tire_f));
        cp.endPartsChange();
    }

    if (cons.tire_r != nil)
    {
        cp.beginPartsChange();
        cp.setRearTireCategory(TireUtil::convMenuIndexToTireIndex(TireUtil::CategoryAll, cons.tire_r));
        cp.endPartsChange();
    }

    if (cons.simulation != nil)
        dp.physics_pro = cons.simulation != 0;

    if (cons.active_steering != nil)
        dp.active_steering = cons.active_steering;
}

function setupRaceOperator(gp, event_idx, player_cp_list, player_dp_list)
{
    if (event_idx == nil)
        event_idx = 0;

    if (gp.replay_list != nil)
    {
        if (event_idx < gp.replay_list.size)
        {
            var replay = gp.replay_list[event_idx];
            if (replay.buffer != nil)
            {
                setupRaceOperatorForReplay(replay.buffer);
                return true;
            }
            else
                return false;
        }
        else
            return false;
    }

    if (gp.events == nil)
        return false;

    var event = gp.events[event_idx];

    var play_style = event.play_style;
    if (play_style == nil)
        return false;

    main::RaceOperator.clear();

    var entry_set = event.entry_set;
    if (entry_set != nil)
    {
        var entry_generate = entry_set.entry_generate;
        if (entry_set.entries == nil && entry_generate != nil)
            generateEntry(event, player_cp_list);

        reserve_entry_set(event, entry_set, player_cp_list, player_dp_list);
    }

    {
        var game_condition = main::gtengine::MGameCondition();
        game_condition.game_mode = event.game_mode;
        var eval_condition = event.eval_condition;
        if (eval_condition != nil)
            game_condition.eval_condition = [eval_condition.type, eval_condition.data];

        var achieve_condition = event.achieve_condition;
        if (achieve_condition != nil)
            game_condition.achieve_condition = [achieve_condition.type, achieve_condition.data];

        var failure_condition = event.failure_condition;
        if (failure_condition != nil)
            game_condition.failure_condition = [failure_condition.type, failure_condition.data];

        main::RaceOperator.game_condition = game_condition;
    }

    {
        var gadget_condition = main::gtengine::MGadgetCondition();
        if (event.gadgets != nil)
        {
            var num = event.gadgets.size;
            gadget_condition.initialize(num);
            for (var i = 0; i < num; i++)
            {
                var gadget = event.gadgets[i];
                var gadget_id = gadget_condition.getGadgetDBIDFromName(gadget.kind);
                if (gadget_id >= 0)
                    gadget_condition.setUnit(i, gadget_id, gadget.positions, gadget.posture);
            }
        }
        main::RaceOperator.gadget_condition = gadget_condition;
    }

    {
        var rp = createRaceParameter(gp, event_idx);
        main::RaceOperator.race_parameter = rp;
        main::RaceOperator.with_ghost = rp.with_ghost;
    }

    main::GameSequence::setGamePlan(gp);
    main::RaceOperator.buildRace();

    return true;
}

function setupRaceOperatorForReplay(buf)
{
    var info = main::gtengine::MReplayInfo();

    var success = info.initialize(buf);
    var result = info.checkVersion();

    main::RaceOperator.race_parameter = info.getRaceParameter();
    main::RaceOperator.setReplayMode(true);

    main::GameSequence::fillReplayBuffer(buf);
}

function execute(context, gp, event_idx, player_cp_list, player_dp_list)
{
    var success = setupRaceOperator(gp, event_idx, player_cp_list, player_dp_list);
    if (!success)
        return false;

    main::GameSequence::setGamePlan(gp);
    SequenceUtil::startSequence(context, main::GameSequence::RACE);

    return true;
}

function executeOutOfSequence(gp, player_cp_list, player_dp_list)
{
    var success = setupRaceOperator(gp, 0, player_cp_list, player_dp_list);
    if (!success)
        return false;

    main::GameSequence::setGamePlan(gp);
    main::GameSequence::setNextSequence(main::GameSequence::RACE);

    return true;
}

function createSingleRace(course_code, entry_num, arcade_laps, ai_skill, enemy_lv, boost_lv, penalty_level, prize_table, one_make)
{
    var gp = main::GamePlan();
    var event = main::GamePlan::Event();
    gp.events = [event];

    event.game_mode = main::gtengine::GameMode::SINGLE_RACE;

    var play_style = main::GamePlan::PlayStyle();
    event.play_style = play_style;
    play_style.play_type = main::GamePlan::PlayType::RACE;

    var entry_set = main::GamePlan::EntrySet();
    event.entry_set = entry_set;
    var entry_generate = main::GamePlan::EntryGenerate();
    entry_set.entry_generate = entry_generate;
    entry_generate.entry_num = entry_num;
    entry_generate.player_pos = entry_num - 1;
    entry_generate.ai_skill = ai_skill;
    entry_generate.enemy_lv = enemy_lv;

    if (one_make != nil && one_make)
        entry_generate.generate_type = main::GamePlan::GenerateType::ONE_MAKE;
    else
        entry_generate.generate_type = main::GamePlan::GenerateType::ENEMY_LIST;

    var race = main::GamePlan::Race();
    event.race = race;
    race.battle_type = main::GamePlan::BattleType::RACE;
    race.race_type = main::gtengine::RaceType::COMPETITION;
    race.start_type = main::gtengine::StartType::GRID;
    race.complete_type = main::gtengine::CompleteType::BYLAPS;
    race.finish_type = main::gtengine::FinishType::TARGET;
    race.race_limit_laps = arcade_laps;
    race.racers_max = entry_num;
    race.penalty_level = penalty_level;
    race.boost_lv = boost_lv;

    var track = main::GamePlan::Track();
    event.track = track;
    track.course_code = course_code;

    var reward = main::GamePlan::Reward();

    reward.prize_table = prize_table;
    event.reward = reward;

    var information = main::GamePlan::Information();
    event.information = information;

    return gp;
}

function createAutoDemo(course_code, entry_num)
{
    var gp = main::GamePlan();

    var event = main::GamePlan::Event();
    gp.events = [event];

    event.game_mode = main::gtengine::GameMode::SINGLE_RACE;

    var play_style = main::GamePlan::PlayStyle();
    event.play_style = play_style;
    play_style.play_type = main::GamePlan::PlayType::DEMO;
    play_style.no_quickmenu = true;
    play_style.time_limit = 120;

    var entry_set = main::GamePlan::EntrySet();
    event.entry_set = entry_set;

    var entry_generate = main::GamePlan::EntryGenerate();
    entry_set.entry_generate = entry_generate;
    entry_generate.entry_num = entry_num;
    entry_generate.player_pos = 0;
    entry_generate.ai_skill = 100;
    entry_generate.enemy_lv = 0;

    entry_generate.generate_type = main::GamePlan::GenerateType::ONE_MAKE;

    var race = main::GamePlan::Race();
    event.race = race;
    race.battle_type = main::GamePlan::BattleType::RACE;
    race.race_type = main::gtengine::RaceType::COMPETITION;
    race.start_type = main::gtengine::StartType::GRID;
    race.complete_type = main::gtengine::CompleteType::BYLAPS;
    race.finish_type = main::gtengine::FinishType::TARGET;
    race.race_limit_laps = 1;
    race.racers_max = entry_num;

    var track = main::GamePlan::Track();
    event.track = track;
    track.course_code = course_code;

    return gp;
}

function createTimeAttack(course_code)
{
    var gp = main::GamePlan();

    var event = main::GamePlan::Event();
    gp.events = [event];

    event.game_mode = main::gtengine::GameMode::TIME_ATTACK;

    var play_style = main::GamePlan::PlayStyle();
    event.play_style = play_style;
    play_style.play_type = main::GamePlan::PlayType::RACE;
    play_style.no_quickmenu = false;

    var entry_set = main::GamePlan::EntrySet();
    event.entry_set = entry_set;

    var entry = main::GamePlan::Entry();
    entry_set.entries = [entry];
    entry.player_no = 0;

    var race = main::GamePlan::Race();
    event.race = race;
    race.battle_type = main::GamePlan::BattleType::RACE;
    race.race_type = main::gtengine::RaceType::TIMEATTACK;
    race.start_type = main::gtengine::StartType::ATTACK;
    race.complete_type = main::gtengine::CompleteType::NONE;
    race.with_ghost = true;
    race.penalty_level = main::gtengine::PenaltyLevelTypes::NO_TIME;
    race.racers_max = 1;

    var track = main::GamePlan::Track();
    event.track = track;
    track.course_code = course_code;

    return gp;
}

function createDriftAttack(course_code, layout, endless)
{
    var gp = main::GamePlan();

    var event = main::GamePlan::Event();
    gp.events = [event];

    event.game_mode = main::gtengine::GameMode::DRIFT_ATTACK;

    var play_style = main::GamePlan::PlayStyle();
    event.play_style = play_style;
    play_style.play_type = main::GamePlan::PlayType::RACE;
    play_style.no_quickmenu = false;

    var entry_set = main::GamePlan::EntrySet();
    event.entry_set = entry_set;

    var entry = main::GamePlan::Entry();
    entry_set.entries = [entry];
    entry.player_no = 0;

    var race = main::GamePlan::Race();
    event.race = race;
    race.battle_type = main::GamePlan::BattleType::RACE;
    race.race_type = main::gtengine::RaceType::DRIFTATTACK;

    if (endless)
        race.start_type = main::gtengine::StartType::ATTACK;
    else
        race.start_type = main::gtengine::StartType::COURSEINFO;

    race.complete_type = main::gtengine::CompleteType::NONE;
    race.with_ghost = false;
    race.racers_max = 1;
    race.endless = endless;

    var track = main::GamePlan::Track();
    event.track = track;
    track.course_code = course_code;
    if (layout != nil)
        track.course_layout_no = layout;

    return gp;
}

function createReplay(buf)
{
    var gp = main::GamePlan();
    var replay = main::GamePlan::Replay();
    gp.replay_list = [replay];
    replay.buffer = buf;

    var info = main::gtengine::MReplayInfo();

    var success = info.initialize(buf);
    if (!success)
        return nil;

    var result = info.checkVersion();
    if (result != main::gtengine::VersionCheckResult::OK)
        return nil;

    var event = GamePlan::Event();
    gp.events = [event];


    var play_style = GamePlan::PlayStyle();
    event.play_style = play_style;
    play_style.no_quickmenu = true;
    
    var gc = info.getGameCondition();
    event.game_mode = gc.game_mode;

    return gp;
}

function createLicense(couse_code) // NOTE: Typo in original
{
    var gp = main::GamePlan();

    var event = main::GamePlan::Event();
    gp.events = [event];
    event.game_mode = main::gtengine::GameMode::LICENSE;

    var play_style = main::GamePlan::PlayStyle();
    event.play_style = play_style;
    play_style.play_type = main::GamePlan::PlayType::RACE;

    var entry_set = main::GamePlan::EntrySet();
    event.entry_set = entry_set;

    var entry = main::GamePlan::Entry();
    entry_set.entries = [entry];
    entry.player_no = 0;

    var race = main::GamePlan::Race();
    event.race = race;
    race.battle_type = main::GamePlan::BattleType::RACE;
    race.race_type = main::gtengine::RaceType::COMPETITION;
    race.start_type = main::gtengine::StartType::STANDING;
    race.complete_type = main::gtengine::CompleteType::NONE;
    race.finish_type = main::gtengine::FinishType::TARGET;
    race.race_limit_laps = 0;
    race.racers_max = 1;

    var track = main::GamePlan::Track();
    event.track = track;
    track.course_code = couse_code;

    var eval_condition = main::GamePlan::EvalCondition();
    event.eval_condition = eval_condition;
    eval_condition.type = main::gtengine::EvalType::TIME;
    eval_condition.data = [59000, 59000, 59000];

    return gp;
}

function createAdhocBattle(game_mode, course_code, entry_num, laps, prize_table)
{
    var gp = main::GamePlan();

    var event = main::GamePlan::Event();
    gp.events = [event];
    event.game_mode = game_mode;

    var play_style = main::GamePlan::PlayStyle();
    event.play_style = play_style;
    play_style.play_type = main::GamePlan::PlayType::RACE;

    var race = main::GamePlan::Race();
    event.race = race;
    race.battle_type = main::GamePlan::BattleType::RACE;
    race.race_type = main::gtengine::RaceType::COMPETITION;
    race.start_type = main::gtengine::StartType::GRID;
    race.complete_type = main::gtengine::CompleteType::BYLAPS;
    race.finish_type = main::gtengine::FinishType::TARGET;
    race.race_limit_laps = laps;
    race.racers_max = entry_num;

    var track = main::GamePlan::Track();
    event.track = track;
    track.course_code = course_code;

    var reward = main::GamePlan::Reward();

    reward.prize_table = prize_table;
    event.reward = reward;

    event.eval_condition = nil;
    event.achieve_condition = nil;
    event.failure_condition = nil;

    return gp;
}