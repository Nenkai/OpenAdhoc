













/*************************************/
/*************************************/
/*             WRITING               */
/*************************************/
/*************************************/

function create_node_value(gnode, group, attrname, need_escape)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {
        if (need_escape != nil && need_escape)
        {

            attr.replaceAll("&", "&amp;");
            
            attr.replaceAll("\"", "&quot;");
            attr.replaceAll(">", "&gt;");
            attr.replaceAll("<", "&lt;");
        }

        var node = pdistd::MDomNode();
        node.addAttribute("value", attr);
        gnode.addNode(attrname, node);
    }
}

function create_node_hex(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {
        var node = pdistd::MDomNode();

        if (attr.isInstanceOf(ULong))
            node.addAttribute("value", "0x%lx".format(attr.toULong()));
        else
            node.addAttribute("value", "0x%lx".format(attr.toLong()));

        gnode.addNode(attrname, node);
    }
}

function create_node_int(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {
        var node = pdistd::MDomNode();
        node.addAttribute("value", "%d".format(attr.toInt()));
        gnode.addNode(attrname, node);
    }
}

function create_node_uint(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {
        var node = pdistd::MDomNode();
        node.addAttribute("value", "%d".format(attr.toUInt()));
        gnode.addNode(attrname, node);
    }
}

function create_node_long(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {
        var node = pdistd::MDomNode();
        node.addAttribute("value", "%lld".format(attr.toLong()));
        gnode.addNode(attrname, node);
    }
}

function create_node_ulong(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {
        var node = pdistd::MDomNode();
        node.addAttribute("value", "%llu".format(attr.toULong()));
        gnode.addNode(attrname, node);
    }
}


function create_node_float(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {
        var node = pdistd::MDomNode();
        node.addAttribute("value", "%f".format(attr.toFloat()));
        gnode.addNode(attrname, node);
    }
}

function create_node_enum(gnode, group, attrname, mdl)
{
    var attr = group.getObjectAttribute(attrname);
    var value = attr.toInt();
    var res = mdl.find_static(function(pair) { return pair[1] == value; });
    if (res.size > 0)
    {
        var name = res[0][0];
        var node = pdistd::MDomNode();
        node.addAttribute("value", name);
        gnode.addNode(attrname, node);
    }
}

function create_node_minmax(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {
        var node = pdistd::MDomNode();
        var pair = attr;
        node.addAttribute("min", pair[0]);
        node.addAttribute("max", pair[1]);
        gnode.addNode(attrname, node);
    }
}

function create_node_array(gnode, group, plural_attrname, attrname)
{
    var attr = group.getObjectAttribute(plural_attrname);
    if (attr != nil && attr.size > 0)
    {
        var node = pdistd::MDomNode();
        for (var i = 0; i < attr.size; i++)
        {
            var elem = attr[i];
            var node0 = pdistd::MDomNode();
            node0.addAttribute("value", elem);
            node.addNode(attrname, node0);
        }
        gnode.addNode(plural_attrname, node);
    }
}

function create_node_int_array(gnode, group, plural_attrname, attrname, no_output_value)
{
    var attr = group.getObjectAttribute(plural_attrname);
    if (attr != nil && attr.size > 0)
    {
        var node = pdistd::MDomNode();
        for (var i = 0; i < attr.size; i++)
        {
            var elem = attr[i];
            var val = elem.toInt();
            if (no_output_value == nil || val != no_output_value)
            {
                var node0 = pdistd::MDomNode();
                node0.addAttribute("value", val);
                node.addNode(attrname, node0);
            }
        }
        gnode.addNode(plural_attrname, node);
    }
}

function create_node_enum_array(gnode, group, plural_attrname, attrname, mdl)
{
    var attr = group.getObjectAttribute(plural_attrname);
    if (attr != nil && attr.size > 0)
    {
        var node = pdistd::MDomNode();
        for (var i = 0; i < attr.size; i++)
        {
            var elem = attr[i];
            var value = elem.toInt();
            var res = mdl.find_static(function(pair) { return pair[1] == value; });
            if (res.size > 0)
            {
                var name = res[0][0];
                var node0 = pdistd::MDomNode();
                node0.addAttribute("value", name);
                node.addNode(attrname, node0);
            }
        }
        gnode.addNode(plural_attrname, node);
    }
}

function create_node_func_array(gnode, group, plural_attrname, attrname, func)
{
    var attr = group.getObjectAttribute(plural_attrname);
    if (attr != nil && attr.size > 0)
    {
        var node = pdistd::MDomNode();
        for (var i = 0; i < attr.size; i++)
        {
            var elem = attr[i];
            var value = elem.toInt();
            var name = func(value);
        
            var node0 = pdistd::MDomNode();
            node0.addAttribute("value", name);
            node.addNode(attrname, node0);
            
        }
        gnode.addNode(plural_attrname, node);
    }
}

function create_node_cars(gnode, group, name)
{
    var node_name = "cars";
    if (name != nil)
        node_name = name;

    var attr = group.getObjectAttribute(node_name);
    if (attr != nil && attr.size > 0)
    {
        var node = pdistd::MDomNode();
        for (var i = 0; i < attr.size; i++)
        {
            var car = attr[i];
            var node0 = pdistd::MDomNode();
            if (car.code != gtengine::MSpecDB::NO_CODE)
            {
                node0.addAttribute("label", gtengine::MSpecDB::getCarLabel(car.code));
                if (car.color != nil)
                    node0.addAttribute("color", car.color);
                node.addNode("car", node0);
            }
        }
        gnode.addNode(node_name, node);
    }
}

function create_node_present(gnode, group, attr_present = "present")
{
    var attr = group.getObjectAttribute(attr_present);


    if (attr != nil && attr.size > 0)
    {
        var node = pdistd::MDomNode();
        for (var i = 0; i < attr.size; i++)
        {
            var gi = attr[i];
            var node0 = pdistd::MDomNode();
            if (gi.itemtype != nil && gi.itemcategory != nil)
            {
                node0.addAttribute("type_id", gi.itemtype);
                node0.addAttribute("category_id", gi.itemcategory);
                node0.addAttribute("argument1", gi.argument1);
                node0.addAttribute("argument2", gi.argument2);
                node0.addAttribute("argument3", gi.argument3);
                node0.addAttribute("argument4", gi.argument4);
                node0.addAttribute("f_name", gi.f_name);
            }
            node.addNode("item", node0);
        }
        gnode.addNode(attr_present, node);
    }
}


function create_node_bin(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {
        var compressed = pdistd::Deflate(attr);
        var value = pdistd::EncodeBase64(compressed);
        var node = pdistd::MDomNode();
        node.addAttribute("value", value);
        gnode.addNode(attrname, node);
    }
}

function create_node_course(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {
        var node = pdistd::MDomNode();
        var label = gtengine::MSpecDB::getCourseLabel(attr);
        node.addAttribute("label", label);
        gnode.addNode(attrname, node);
    }
}

function create_node_mtime(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {
        var node = pdistd::MDomNode();
        var str = attr.toString();
        node.addAttribute("datetime", str);
        gnode.addNode(attrname, node);
    }
}

function createDriverParameterXML(dp)
{
    if (dp.isVacant())
        return nil;

    var node = pdistd::MDomNode();
    create_node_enum(node, dp, "type", gtengine::DriverType);
    create_node_int(node, dp, "port");
    create_node_value(node, dp, "display_name");
    create_node_value(node, dp, "region");

    create_node_int(node, dp, "physics_pro");
    create_node_int(node, dp, "head_code");
    create_node_int(node, dp, "body_code");
    create_node_int(node, dp, "head_color_code");
    create_node_int(node, dp, "body_color_code");
    create_node_int(node, dp, "braking_skill");
    create_node_int(node, dp, "cornering_skill");
    create_node_int(node, dp, "accelerating_skill");
    create_node_int(node, dp, "starting_skill");
    create_node_int(node, dp, "ai_roughness");
    create_node_enum(node, dp, "special_ai_type", gtengine::SpecialAIType);
    create_node_int(node, dp, "display_driving_line");
    return node;
}

function create_node_aiscripter(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);
    if (attr != nil)
    {

        attr.replaceAll("&", "&amp;");
            
        attr.replaceAll("\"", "&quot;");
        attr.replaceAll(">", "&gt;");
        attr.replaceAll("<", "&lt;");
        
        var node = pdistd::MDomNode();
        node.addAttribute("value", attr);
        gnode.addNode(attrname, node);
    }
}

function createXML(gp_list)
{
    var xml_node = pdistd::MDomNode();
    foreach (var gp in gp_list)
    {
        var gp_node = createGameParameterXML(gp);
        xml_node.addNode("GameParameter", gp_node);
    }


    var xml_head = "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n";
    var xml_data = xml_node.serialize("xml");

    return xml_head + xml_data;
}

function createOnlineSeriesXML(series)
{
    var node = pdistd::MDomNode();

    if (series.course_code != gtengine::MSpecDB::NO_CODE)
    {
        create_node_course(node, series, "course_code");
        create_node_uint(node, series, "laps");
        create_node_uint(node, series, "time_progress_speed");
        create_node_mtime(node, series, "datetime");
    }

    return node;
}


function createQualityControlParameterXML(qcp)
{
    var node = pdistd::MDomNode();

    create_node_int(node, qcp, "template_type");
    return node;
}

function createOnlineRoomXML(online_room)
{
    if (online_room.isDefault())
        return nil;
    
    var online_room_node = pdistd::MDomNode();
    create_node_value(online_room_node, online_room, "comment", true);
    create_node_value(online_room_node, online_room, "password");
    create_node_enum(online_room_node, online_room, "room_type", gtengine::RoomType);
    create_node_enum(online_room_node, online_room, "room_policy", gtengine::RoomPolicy);
    create_node_enum(online_room_node, online_room, "scope", gtengine::Scope);
    create_node_enum(online_room_node, online_room, "chat_type", gtengine::ChatType);
    create_node_enum(online_room_node, online_room, "voice_quality", gtengine::VoiceQuality);
    create_node_enum(online_room_node, online_room, "voice_chat_mode", gtengine::VoiceChatMode);
    create_node_enum(online_room_node, online_room, "car_shuffle_method", gtengine::CarShuffleMethod);
    create_node_enum(online_room_node, online_room, "car_select_method", gtengine::CarSelectMethod);
    create_node_enum(online_room_node, online_room, "car_filter_type", gtengine::CarFilterType);
    create_node_enum(online_room_node, online_room, "course_select_method", gtengine::CourseSelectMethod);
    create_node_enum(online_room_node, online_room, "topology", pdistd::TopologyType);
    create_node_enum(online_room_node, online_room, "matching_space", gtengine::MatchingSpace);
    create_node_int(online_room_node, online_room, "room_max");
    create_node_int(online_room_node, online_room, "racer_max");
    create_node_int(online_room_node, online_room, "race_countdown");
    create_node_int(online_room_node, online_room, "auto_grant_ownership");
    create_node_int(online_room_node, online_room, "nat_restriction");
    create_node_int(online_room_node, online_room, "exclude_blocklist");
    create_node_int(online_room_node, online_room, "voice_chat");
    create_node_int(online_room_node, online_room, "is_lan");
    create_node_int(online_room_node, online_room, "fill_vacancy");
    create_node_int(online_room_node, online_room, "overwrite_user_name");
    create_node_int(online_room_node, online_room, "overwrite_user_region");
    create_node_int(online_room_node, online_room, "show_hidden_config");
    create_node_int(online_room_node, online_room, "use_custom_grid");
    create_node_int(online_room_node, online_room, "use_custom_countdown");
    create_node_int(online_room_node, online_room, "is_autocratic");
    create_node_int(online_room_node, online_room, "is_automated");
    create_node_int(online_room_node, online_room, "is_only_garage_car");
    create_node_int(online_room_node, online_room, "is_only_rental_car");
    create_node_int(online_room_node, online_room, "is_saved_course");
    create_node_int(online_room_node, online_room, "theme_color_index");
    create_node_enum(online_room_node, online_room, "room_game_mode", gtengine::RoomGameMode);
    create_node_enum(online_room_node, online_room, "trackday_mode", gtengine::TrackDayMode);
    create_node_enum(online_room_node, online_room, "battle_mode", gtengine::BattleMode);
    create_node_enum(online_room_node, online_room, "trial_start_type", gtengine::StartType);
    create_node_enum(online_room_node, online_room, "qualifier_race_type", gtengine::RaceType);
    create_node_int(online_room_node, online_room, "qualifier_begin");
    create_node_int(online_room_node, online_room, "qualifier_period");

    var seriesList = online_room.online_series;
    var seriesListNode = pdistd::MDomNode();

    for (var i = 0; i < seriesList.size; ++i)
    {
        var series = seriesList[i];
        var seriesNode = createOnlineSeriesXML(series);
        seriesListNode.addNode("series", seriesNode);
    }
    online_room_node.addNode("online_series", seriesListNode);

    create_node_enum(online_room_node, online_room, "series_point_type", gtengine::OnlineSeriesPointType);
    create_node_array(online_room_node, online_room, "series_point_table", "point");
    create_node_int(online_room_node, online_room, "booby_point");
    create_node_int(online_room_node, online_room, "matching_world_offset");
    create_node_int(online_room_node, online_room, "freerun_penalty");
    create_node_int(online_room_node, online_room, "freerun_collision");
    create_node_int(online_room_node, online_room, "shuffle_base");
    create_node_int(online_room_node, online_room, "shuffle_ratio");
    create_node_enum(online_room_node, online_room, "weather", gtengine::TrackDayWeather);
    create_node_int(online_room_node, online_room, "game_region_code");
    create_node_int(online_room_node, online_room, "alarm_time");
    create_node_int(online_room_node, online_room, "alarm_time_value");
    create_node_int(online_room_node, online_room, "club_id");
    create_node_int(online_room_node, online_room, "club_event_id");
    create_node_uint(online_room_node, online_room, "event_setting_version");
    create_node_uint(online_room_node, online_room, "event_setting_hash");
    create_node_uint(online_room_node, online_room, "scenery_course_code");


    var qcp = online_room.quality_control_parameter;
    var qcpNode = createQualityControlParameterXML(qcp);
    online_room_node.addNode("quality_control_parameter", qcpNode);

    return online_room_node;
}


function create_node_int_for_entry_base(gnode, group, attrname)
{
    var attr = group.getObjectAttribute(attrname);

    if (attr != nil && attr.toInt() >= 0)
    {
        var node = pdistd::MDomNode();
        node.addAttribute("value", "%d".format(attr.toInt()));
        gnode.addNode(attrname, node);
    }
}


function create_entry_base(entry_base, base_node)
{
    var node0 = pdistd::MDomNode();

    if (entry_base.car.code != gtengine::MSpecDB::NO_CODE)
    {
        var node = pdistd::MDomNode();
        node.addAttribute("label", entry_base.car.label);
        node.addAttribute("color", entry_base.car.color);
        node0.addNode("car", node);
    }
    create_node_value(node0, entry_base, "driver_name");
    create_node_value(node0, entry_base, "driver_region");

    create_node_int(node0, entry_base, "race_class_id");
    create_node_int(node0, entry_base, "proxy_driver_model");

    create_node_int_array(node0, entry_base, "boost_race_ratio", "race_ratio");
    create_node_int_array(node0, entry_base, "boost_ratio", "ratio");

    create_node_int(node0, entry_base, "ai_skill_breaking");
    create_node_int(node0, entry_base, "ai_skill_cornering");
    create_node_int(node0, entry_base, "ai_skill_accelerating");
    create_node_int(node0, entry_base, "ai_skill_starting");
    create_node_int(node0, entry_base, "ai_roughness");
    create_node_int(node0, entry_base, "ai_reaction");

    create_node_enum(node0, entry_base, "engine_na_tune_stage", gtengine::PARTS_NATUNE);
    create_node_enum(node0, entry_base, "engine_turbo_kit", gtengine::PARTS_TURBINEKIT);
    create_node_enum(node0, entry_base, "engine_computer", gtengine::PARTS_COMPUTER);
    create_node_int_for_entry_base(node0, entry_base, "power_limiter");
    create_node_enum(node0, entry_base, "muffler", gtengine::PARTS_MUFFLER);
    create_node_enum(node0, entry_base, "suspension", gtengine::PARTS_SUSPENSION);
    create_node_enum(node0, entry_base, "transmission", gtengine::PARTS_GEAR);
    create_node_int_for_entry_base(node0, entry_base, "gear_max_speed");
    create_node_int_for_entry_base(node0, entry_base, "ballast_weight");
    create_node_int_for_entry_base(node0, entry_base, "ballast_position");
    create_node_int_for_entry_base(node0, entry_base, "wheel");
    create_node_int_for_entry_base(node0, entry_base, "wheel_color");
    create_node_int_for_entry_base(node0, entry_base, "wheel_inch_up");
    create_node_enum(node0, entry_base, "tire_f", gtengine::PARTS_TIRE);
    create_node_enum(node0, entry_base, "tire_r", gtengine::PARTS_TIRE);
    create_node_int_for_entry_base(node0, entry_base, "aero_wing");
    create_node_int_for_entry_base(node0, entry_base, "aero_1");
    create_node_int_for_entry_base(node0, entry_base, "aero_2");
    create_node_int_for_entry_base(node0, entry_base, "aero_3");
    create_node_int_for_entry_base(node0, entry_base, "downforce_f");
    create_node_int_for_entry_base(node0, entry_base, "downforce_r");
    create_node_int_for_entry_base(node0, entry_base, "paint_id");
    create_node_int_for_entry_base(node0, entry_base, "decken_number");
    create_node_int_for_entry_base(node0, entry_base, "decken_type");
    create_node_int_for_entry_base(node0, entry_base, "decken_custom_id");
    create_node_int_for_entry_base(node0, entry_base, "decken_custom_type");

    base_node.addNode("entry_base", node0);
}


function create_node_entry_base_array(gnode, group, name)
{
    var node_name = "entry_base_array";
    if (name != nil)
        node_name = name;
    
    var attr = group.getObjectAttribute(node_name);
    if (attr != nil && attr.size > 0)
    {
        var node = pdistd::MDomNode();
        for (var i = 0; i < attr.size; i++)
        {
            var base = attr[i];
            create_entry_base(base, node);
        }
        gnode.addNode(node_name, node);
    }
}


function createGameParameterXML(gp)
{
    var gp_node = pdistd::MDomNode();
    gp_node.addAttribute("version", gtengine::MGameParameter::VERSION.toString());


    create_node_long(gp_node, gp, "folder_id");



    var events = gp.events;
    var events_node = pdistd::MDomNode();

    for (var i = 0; i < events.size; i++)
    {
        var event = events[i];
        var event_node = createEventXML(event);
        events_node.addNode("event", event_node);
    }

    gp_node.addNode("events", events_node);

    var online_room_node = createOnlineRoomXML(gp.online_room);
    if (online_room_node != nil)
        gp_node.addNode("online_room", online_room_node);

    var reward = gp.series_reward;
    var reward_node = createRewardXML(reward, !gp.championship);
    if (reward_node != nil)
        gp_node.addNode("series_reward", reward_node);

    var information = gp.series_information;
    if (!information.isDefault())
    {
        var information_node = createInformationXML(information);
        if (information_node != nil)
            gp_node.addNode("series_information", information_node);
    }

    var editor_info = gp.editor_info;
    if (!editor_info.isDefault())
    {
        var editor_info_node = pdistd::MDomNode();
        create_node_int(editor_info_node, editor_info, "psp_mode");
        gp_node.addNode("editor_info", editor_info_node)
    }

    create_node_int(gp_node, gp, "championship");

    create_node_int(gp_node, gp, "arcade");
    return gp_node;
}


function createEventXML(event)
{
    var event_node = pdistd::MDomNode();

    create_node_long(event_node, event, "event_id");

    create_node_enum(event_node, event, "game_mode", gtengine::GameMode);

    var play_style = event.play_style;
    if (!play_style.isDefault())
    {
        var play_style_node = pdistd::MDomNode();
        create_node_enum(play_style_node, play_style, "bspec_type", gtengine::BSpecType);
        create_node_enum(play_style_node, play_style, "play_type", gtengine::PlayType);
        create_node_int(play_style_node, play_style, "no_quickmenu");
        create_node_int(play_style_node, play_style, "no_instant_replay");
        create_node_int(play_style_node, play_style, "replay_record_enable");
        create_node_int(play_style_node, play_style, "rentcar_setting_enable");
        create_node_int(play_style_node, play_style, "window_num");
        create_node_int(play_style_node, play_style, "time_limit");
        create_node_int(play_style_node, play_style, "leave_limit");
        event_node.addNode("play_style", play_style_node);
    }

    create_node_enum(event_node, event, "event_type", gtengine::EventType);

    create_node_int(event_node, event, "inheritance");
    create_node_int(event_node, event, "is_seasonal_event");

    var regulation = event.regulation;
    if (!regulation.isDefault())
    {
        var regulation_node = pdistd::MDomNode();
        create_node_int(regulation_node, regulation, "limit_pp");
        create_node_int(regulation_node, regulation, "need_pp");
        create_node_int(regulation_node, regulation, "limit_tire_f");
        create_node_int(regulation_node, regulation, "need_tire_f");
        create_node_int(regulation_node, regulation, "limit_tire_r");
        create_node_int(regulation_node, regulation, "need_tire_r");
        create_node_enum_array(regulation_node, regulation, "car_categories", "category", gtengine::CarCategory);
        create_node_cars(regulation_node, regulation);
        create_node_cars(regulation_node, regulation, "ban_cars");
        create_node_value(regulation_node, regulation, "need_license");
        create_node_int(regulation_node, regulation, "limit_power");
        create_node_int(regulation_node, regulation, "need_power");
        create_node_int(regulation_node, regulation, "limit_weight");
        create_node_int(regulation_node, regulation, "need_weight");
        create_node_int(regulation_node, regulation, "limit_length");
        create_node_int(regulation_node, regulation, "need_length");
        create_node_int(regulation_node, regulation, "need_drivetrain");
        create_node_int(regulation_node, regulation, "need_aspiration");
        create_node_int(regulation_node, regulation, "tuning");
        create_node_int(regulation_node, regulation, "NOS");
        create_node_int(regulation_node, regulation, "kart_permitted");
        create_node_int(regulation_node, regulation, "car_tag_id");
        create_node_int(regulation_node, regulation, "restrictor_limit");
        create_node_int(regulation_node, regulation, "limit_year");
        create_node_int(regulation_node, regulation, "need_year");
        create_node_enum_array(regulation_node, regulation, "tuners", "tuner", gtengine::Tuner);
        create_node_enum_array(regulation_node, regulation, "countries", "country", gtengine::Country);
        create_node_int(regulation_node, regulation, "limit_aspec_level");
        create_node_int(regulation_node, regulation, "need_aspec_level");
        create_node_int(regulation_node, regulation, "limit_bspec_level");
        create_node_int(regulation_node, regulation, "need_bspec_level");
        create_node_int(regulation_node, regulation, "limit_bspec_driver_count");
        create_node_int(regulation_node, regulation, "need_bspec_driver_count");
        create_node_value(regulation_node, regulation, "need_entitlement");
        event_node.addNode("regulation", regulation_node);
    }

    var constraint = event.constraint;
    if (!constraint.isDefault())
    {
        var constraint_node = pdistd::MDomNode();
        create_node_int(constraint_node, constraint, "transmission");
        create_node_int(constraint_node, constraint, "driving_line");
        create_node_int(constraint_node, constraint, "asm");
        create_node_int(constraint_node, constraint, "tcs");
        create_node_int(constraint_node, constraint, "suggest_tcs");
        create_node_int(constraint_node, constraint, "abs");
        create_node_int(constraint_node, constraint, "simulation");
        create_node_int(constraint_node, constraint, "limit_tire_f");
        create_node_int(constraint_node, constraint, "need_tire_f");
        create_node_int(constraint_node, constraint, "suggest_tire_f");
        create_node_int(constraint_node, constraint, "limit_tire_r");
        create_node_int(constraint_node, constraint, "need_tire_r");
        create_node_int(constraint_node, constraint, "suggest_tire_r");
        create_node_int(constraint_node, constraint, "active_steering");
        create_node_int(constraint_node, constraint, "drift_type");
        create_node_int(constraint_node, constraint, "suggested_gear");
        create_node_int(constraint_node, constraint, "in_car_view");
        create_node_int(constraint_node, constraint, "enemy_tire");
        create_node_cars(constraint_node, constraint);
        event_node.addNode("constraint", constraint_node);
    }

    var rp = event.race_parameter;
    var race_node = pdistd::MDomNode();
    create_node_enum(race_node, rp, "race_type", gtengine::RaceType);
    create_node_enum(race_node, rp, "start_type", gtengine::StartType);
    create_node_enum(race_node, rp, "complete_type", gtengine::CompleteType);
    create_node_enum(race_node, rp, "finish_type", gtengine::FinishType);
    create_node_int(race_node, rp, "race_limit_laps");
    create_node_int(race_node, rp, "race_limit_minute");
    create_node_int(race_node, rp, "time_to_start");
    create_node_int(race_node, rp, "time_to_finish");
    create_node_int(race_node, rp, "entry_max");
    create_node_int(race_node, rp, "racers_max");
    create_node_int(race_node, rp, "keep_load_ghost");
    create_node_int(race_node, rp, "immediate_finish");
    create_node_enum(race_node, rp, "grid_sort_type", gtengine::GridSortType);
    create_node_int(race_node, rp, "autostart_pitout");
    create_node_int(race_node, rp, "endless");
    create_node_enum(race_node, rp, "ghost_type", gtengine::GhostType);
    create_node_int(race_node, rp, "disable_collision");
    create_node_int(race_node, rp, "penalty_level");
    create_node_int(race_node, rp, "accumulation");
    create_node_int(race_node, rp, "bspec_vitality10");
    create_node_int(race_node, rp, "consume_fuel");
    create_node_int(race_node, rp, "consume_tire");
    create_node_int(race_node, rp, "temperature_tire");
    create_node_int(race_node, rp, "temperature_brake");
    create_node_int(race_node, rp, "temperature_engine");
    create_node_int(race_node, rp, "goal_time_use_lap_total");
    create_node_int(race_node, rp, "start_time_offset");
    create_node_int(race_node, rp, "start_signal_type");
    create_node_int(race_node, rp, "consideration_type");

    create_node_int(race_node, rp, "academy_event");
    create_node_enum(race_node, rp, "lighting_mode", gtengine::LightingMode);

    create_node_array(race_node, rp, "boost_params", "param");

    create_node_int(race_node, rp, "boost_level");
    create_node_int(race_node, rp, "boost_type");
    create_node_int(race_node, rp, "boost_flag");

    create_node_mtime(race_node, rp, "datetime");
    create_node_float(race_node, rp, "time_progress_speed");
    create_node_int(race_node, rp, "lucky_player");
    create_node_int(race_node, rp, "enable_pit");
    create_node_int(race_node, rp, "pit_constraint");
    create_node_int(race_node, rp, "course_out_penalty_margine");
    create_node_int(race_node, rp, "behavior_fallback");
    create_node_int(race_node, rp, "need_tire_change");
    create_node_int(race_node, rp, "disable_recording_replay");
    create_node_enum(race_node, rp, "flagset", gtengine::RaceFlagSet);
    create_node_int(race_node, rp, "online_on");
    create_node_int(race_node, rp, "auto_standing_delay");
    create_node_int(race_node, rp, "allow_codriver");
    create_node_int(race_node, rp, "pace_note");
    create_node_int(race_node, rp, "enable_damage");
    create_node_int(race_node, rp, "replace_at_courseout");
    create_node_int(race_node, rp, "mu_ratio100");
    create_node_int(race_node, rp, "penalty_no_reset");
    create_node_enum(race_node, rp, "low_mu_type", gtengine::LowMuType);
    create_node_enum(race_node, rp, "behavior_damage_type", gtengine::BehaviorDamageType);
    create_node_enum(race_node, rp, "behavior_slip_stream_type", gtengine::BehaviorSlipStreamType);
    create_node_enum(race_node, rp, "ghost_presence_type", gtengine::GhostPresenceType);
    create_node_int(race_node, rp, "line_ghost_play_max");
    create_node_enum(race_node, rp, "line_ghost_record_type", gtengine::LineGhostRecordType);
    create_node_enum(race_node, rp, "attack_separate_type", gtengine::AttackSeparateType);
    
    var out_of_order = false;
    var grid_list = rp.grid_list;
    for (var i = 0; i < grid_list.size; i++)
    {
        if (grid_list[i] != i)
        {
            out_of_order = true;
            break;
        }
    }

    if (out_of_order)
        create_node_array(race_node, rp, "grid_list", "grid");



    out_of_order = false;
    var event_v_list = rp.event_v_list;
    for (var i = 0; i < event_v_list.size; i++)
    {
        if (event_v_list[i] != i)
        {
            out_of_order = true;
            break;
        }
    }
    if (out_of_order)
        create_node_array(race_node, rp, "event_v_list", "v");

    create_node_int(race_node, rp, "event_start_v");
    create_node_int(race_node, rp, "event_goal_v");
    create_node_int(race_node, rp, "event_goal_width");
    create_node_int(race_node, rp, "fixed_retention");
    create_node_int(race_node, rp, "initial_retention10");
    create_node_enum(race_node, rp, "decisive_weather", gtengine::DecisiveWeather);
    create_node_int(race_node, rp, "weather_point_num");
    create_node_float(race_node, rp, "weather_total_sec");
    create_node_int(race_node, rp, "weather_random_seed");
    create_node_int(race_node, rp, "weather_no_precipitation");
    create_node_int(race_node, rp, "weather_no_wind");
    create_node_int(race_node, rp, "weather_prec_rain_only");
    create_node_int(race_node, rp, "weather_prec_snow_only");
    create_node_int(race_node, rp, "weather_no_schedule");
    create_node_int(race_node, rp, "weather_random");
    create_node_int(race_node, rp, "weather_accel10");
    create_node_int(race_node, rp, "weather_accel_water_retention10");

    create_node_int(race_node, rp, "weather_base_celsius");
    create_node_int(race_node, rp, "weather_max_celsius");
    create_node_int(race_node, rp, "weather_min_celsius");


    create_node_int(race_node, rp, "weather_accel100");
    create_node_float(race_node, rp, "weather_rate_sec1");
    create_node_float(race_node, rp, "weather_rate_sec2");
    create_node_float(race_node, rp, "weather_value0");
    create_node_float(race_node, rp, "weather_value1");
    create_node_float(race_node, rp, "weather_value2");
    create_node_float(race_node, rp, "weather_value3");

    event_node.addNode("race", race_node);




    var track = event.track;
    var track_node = pdistd::MDomNode();
    create_node_course(track_node, track, "course_code");
    create_node_ulong(track_node, track, "generated_course_id");
    create_node_int(track_node, track, "course_layout_no");
    
    var gadgets = track.gadgets;
    var num = gadgets.size;
    for (var i = 0; i < num; i++)
    {
        var gadget_node = pdistd::MDomNode();
        var gadget = gadgets[i];

        create_node_value(gadget_node, gadget, "kind_db_id");
        create_node_float(gadget_node, gadget, "x");
        create_node_float(gadget_node, gadget, "y");
        create_node_float(gadget_node, gadget, "z");
        create_node_array(gadget_node, gadget, "posture", "value");

        track_node.addNode("gadget", gadget_node);
    }

    

    create_node_int(track_node, track, "map_offset_world_x");
    create_node_int(track_node, track, "map_offset_world_y");
    create_node_int(track_node, track, "map_scale");
    create_node_int(track_node, track, "is_omedeto_difficulty");
    create_node_bin(track_node, track, "edit_data");
    

    event_node.addNode("track", track_node);

    var entry_set = event.entry_set;
    if (!entry_set.isDefault())
    {
        var entry_set_node = pdistd::MDomNode();

        if (!entry_set.entry_generate.isDefault())
        {
            var entry_generate_node = pdistd::MDomNode();
            var entry_generate = entry_set.entry_generate;
            create_node_int(entry_generate_node, entry_generate, "entry_num");
            create_node_int(entry_generate_node, entry_generate, "player_pos");
            create_node_enum(entry_generate_node, entry_generate, "generate_type", gtengine::GenerateType);
            create_node_enum(entry_generate_node, entry_generate, "enemy_list_type", gtengine::EnemyListType);
            create_node_hex(entry_generate_node, entry_generate, "race_code");
            create_node_int(entry_generate_node, entry_generate, "ai_skill");
            create_node_int(entry_generate_node, entry_generate, "ai_skill_breaking");
            create_node_int(entry_generate_node, entry_generate, "ai_skill_cornering");
            create_node_int(entry_generate_node, entry_generate, "ai_skill_accelerating");
            create_node_int(entry_generate_node, entry_generate, "ai_skill_starting");
            create_node_int(entry_generate_node, entry_generate, "ai_roughness");
            create_node_int(entry_generate_node, entry_generate, "enemy_lv");
            create_node_int(entry_generate_node, entry_generate, "enemy_bspec_lv");
            create_node_int(entry_generate_node, entry_generate, "bspec_lv_offset");
            create_node_int(entry_generate_node, entry_generate, "gap_for_start_rolling_distance");
            create_node_int(entry_generate_node, entry_generate, "rolling_start_v");
            create_node_int(entry_generate_node, entry_generate, "use_rolling_start_param");
            create_node_cars(entry_generate_node, entry_generate);
            create_node_int_array(entry_generate_node, entry_generate, "delays", "delay");
            create_node_enum(entry_generate_node, entry_generate, "enemy_sort_type", gtengine::EnemySortType);
            
            create_node_entry_base_array(entry_generate_node, entry_generate);

            entry_set_node.addNode("entry_generate", entry_generate_node);
        }

        var entries = entry_set.entries;
        num = entries.size;
        for (var i = 0; i < num; i++)
        {
            var entry_node = pdistd::MDomNode();

            var entry = entries[i];
            create_node_int(entry_node, entry, "player_no");

            if (entry.car.code != gtengine::MSpecDB::NO_CODE)
            {
                var node = pdistd::MDomNode();
                node.addAttribute("label", entry.car.label);
                node.addAttribute("color", entry.car.color);
                entry_node.addNode("car", node);
            }
            if (!entry.car_parameter.isVacant())
            {
                var node = pdistd::MDomNode();
                var map = entry.car_parameter.getArchiveTree();
                var version = map["version"];
                var bytedata = map["data"];
                var compressed = pdistd::Deflate(bytedata);
                node.value = pdistd::EncodeBase64(compressed);
                node.addAttribute("version", version);
                entry_node.addNode("car_parameter", node);
            }
            create_node_value(entry_node, entry, "driver_name");
            create_node_value(entry_node, entry, "driver_region");
            if (!entry.driver_parameter.isVacant())
            {
                var node = createDriverParameterXML(entry.driver_parameter);
                entry_node.addNode("driver_parameter", node);
            }
            create_node_int(entry_node, entry, "pilot_id");

            if (entry.entry_base.car.code != gtengine::MSpecDB::NO_CODE)
            {
                create_entry_base(entry.entry_base, entry_node);
            }

            if (entry.available_initial_position)
                create_node_int(entry_node, entry, "initial_position");
            create_node_int(entry_node, entry, "initial_velocity");
            create_node_enum(entry_node, entry, "start_type", gtengine::StartType);
            create_node_int(entry_node, entry, "delay");
            create_node_int(entry_node, entry, "race_class_id");
            create_node_int(entry_node, entry, "proxy_driver_model");
            create_node_int(entry_node, entry, "no_suitable_tire");
            create_node_int(entry_node, entry, "initial_fuel100");

            create_node_int_array(entry_node, entry, "boost_race_ratio", "race_ratio");
            create_node_int_array(entry_node, entry, "boost_ratio", "ratio");

            create_node_int(entry_node, entry, "ai_skill_breaking"); // ðŸ™ƒ Don't change PoDi
            create_node_int(entry_node, entry, "ai_skill_cornering");
            create_node_int(entry_node, entry, "ai_skill_accelerating");
            create_node_int(entry_node, entry, "ai_skill_starting");
            create_node_int(entry_node, entry, "ai_roughness");
            

            entry_set_node.addNode("entry", entry_node);
        }

        event_node.addNode("entry_set", entry_set_node);
    }

    var eval_condition = event.eval_condition;
    if (!eval_condition.isDefault())
    {
        var eval_condition_node = pdistd::MDomNode();
        create_node_enum(eval_condition_node, eval_condition, "type", gtengine::EvalType);
        create_node_int(eval_condition_node, eval_condition, "gold");
        create_node_int(eval_condition_node, eval_condition, "silver");
        create_node_int(eval_condition_node, eval_condition, "bronze");
        create_node_value(eval_condition_node, eval_condition, "ghost_data_path");
        event_node.addNode("eval_condition", eval_condition_node);
    }

    var achieve_condition = event.achieve_condition;
    if (!achieve_condition.isDefault())
    {
        var achieve_condition_node = pdistd::MDomNode();
        create_node_enum(achieve_condition_node, achieve_condition, "type", gtengine::AchieveType);
        create_node_int(achieve_condition_node, achieve_condition, "num");
        event_node.addNode("achieve_condition", achieve_condition_node);
    }

    var failure_condition = event.failure_condition;
    if (!failure_condition.isDefault())
    {
        var failure_condition_node = pdistd::MDomNode();
        create_node_enum_array(failure_condition_node, failure_condition, "type_list", "type", gtengine::FailureType);
        create_node_int_array(failure_condition_node, failure_condition, "data_list", "data");
        create_node_int(failure_condition_node, failure_condition, "no_failure_at_result");
        event_node.addNode("failure_condition", failure_condition_node);
    }

    var license_condition = event.license_condition;
    if (!license_condition.isDefault())
    {
        var license_condition_node = pdistd::MDomNode();
        create_node_int(license_condition_node, license_condition, "use_basic_finish");
        create_node_int(license_condition_node, license_condition, "stop_on_finish");
        create_node_enum(license_condition_node, license_condition, "display_mode", gtengine::LicenseDisplayModeType);
        create_node_array(license_condition_node, license_condition, "gadget_names", "gadget");
        createLicenseConditionDataXML(license_condition_node, license_condition, "finish_condition", true);
        createLicenseConditionDataXML(license_condition_node, license_condition, "failure_condition", true);
        createLicenseConditionDataXML(license_condition_node, license_condition, "success_condition", true);
        event_node.addNode("license_condition", license_condition_node);
    }

    var reward = event.reward;
    var reward_node = createRewardXML(reward, false);
    if (reward_node != nil)
        event_node.addNode("reward", reward_node);
    
    var ranking = event.ranking;
    var ranking_node = createRankingXML(ranking);
    if (ranking_node != nil)
        event_node.addNode("ranking", ranking_node);

    var replay = event.replay;
    var replay_node = createReplayXML(replay);
    if (replay_node != nil)
        event_node.addNode("replay", replay_node);

    var information = event.information;
    var information_node = createInformationXML(information);
    if (information_node != nil)
        event_node.addNode("information", information_node);

    var begin_date = event.begin_date;
    if (begin_date != 0)
    {
        var begin_date_node = pdistd::MDomNode();
        begin_date_node.value = event.begin_date_str;
        event_node.addNode("begin_date", begin_date_node);
    }
    var end_date = event.end_date;
    if (end_date != 0)
    {
        var end_date_node = pdistd::MDomNode();
        end_date_node.value = event.end_date_str;
        event_node.addNode("end_date", end_date_node);
    }

    var stage_data = event.stage_data;
    if (!stage_data.isDefault())
    {
        var stage_data_node = pdistd::MDomNode();
        createStageResetDataXML(stage_data_node, stage_data.before_start, "before_start", true);
        createStageResetDataXML(stage_data_node, stage_data.race_start, "race_start", true);
        createStageResetDataXML(stage_data_node, stage_data.race_end, "race_end", true);

        event_node.addNode("stage_data", stage_data_node);
    }
    create_node_aiscripter(event_node, event, "penalty_script");

    create_node_aiscripter(event_node, event, "ai_script");

    return event_node;
}

function createStageResetDataXML(stage_data_node, data, node_name, only_default)
{
    if (!only_not_default || !data.isDefault())
    {
        var data_node = pdistd::MDomNode();
        create_node_value(data_node, data, "code");
        create_node_enum(data_node, data, "coord", gtengine::StageCoordType);
        create_node_int(data_node, data, "target_id");
        create_node_int(data_node, data, "resource_id");

        create_node_float(data_node, data, "x");
        create_node_float(data_node, data, "y");
        create_node_float(data_node, data, "z");
        create_node_float(data_node, data, "rotYdeg");
        create_node_float(data_node, data, "vcoord");

        stage_data_node.addNode(node_name, data_node);
    }
}

function createLicenseConditionDataXML(parent_node, data, node_name, only_default)
{
    if (!only_not_default || !data.isDefault())
    {

        var num = data.size;
        var array_node = pdistd::MDomNode();
        for (var idx = 0; i < num; i++) // BUG: They use 'i' instead of 'idx'
        {
            var single_data = data[idx];
            createLicenseConditionDataXMLCore(array_node, single_data, "data", only_default);
        }
        parent_node.addNode(node_name, array_node);
    }
}

function createLicenseConditionDataXMLCore(parent_node, data, node_name, only_default)
{
    if (!only_not_default || !data.isDefault())
    {

        var data_node = pdistd::MDomNode();
        create_node_enum(data_node, data, "check_type", gtengine::LicenseCheckType);
        create_node_enum(data_node, data, "condition", gtengine::LicenseConditionType);
        create_node_enum(data_node, data, "connection", gtengine::LicenseConnectionType);
        create_node_int(data_node, data, "result_type");
        create_node_float(data_node, data, "float_value");
        create_node_uint(data_node, data, "uint_value");
        create_node_int(data_node, data, "int_value");

        parent_node.addNode(node_name, data_node);
    }
}


function createRewardXML(reward, only_not_default)
{
    if (!only_not_default || !reward.isDefault())
    {
        var reward_node = pdistd::MDomNode();
        create_node_int_array(reward_node, reward, "prize_table", "prize", 0);
        create_node_int_array(reward_node, reward, "point_table", "point", 0);
        create_node_enum_array(reward_node, reward, "star_table", "star", gtengine::FinishResult);
        create_node_present(reward_node, reward);
        create_node_value(reward_node, reward, "special_reward_code");
        create_node_value(reward_node, reward, "prize_type");
        create_node_value(reward_node, reward, "pp_base");
        create_node_value(reward_node, reward, "percent_at_pp100");
        create_node_int(reward_node, reward, "is_once");
        create_node_enum(reward_node, reward, "present_type", gtengine::RewardPresentType);

        create_node_present(reward_node, reward, "entry_present");
        create_node_enum(reward_node, reward, "entry_present_type", gtengine::RewardEntryPresentType);

        create_entry_base(reward.entry_base, reward_node);
        return reward_node;
    }
    else
        return nil;
}

function createRankingXML(ranking)
{
    if (ranking.isDefault())
        return nil;

    var ranking_node = pdistd::MDomNode();
    create_node_enum(ranking_node, ranking, "type", gtengine::RankingType);
    create_node_int(ranking_node, ranking, "is_local");
    create_node_int(ranking_node, ranking, "replay_rank_limit");
    create_node_int(ranking_node, ranking, "display_rank_limit");
    create_node_long(ranking_node, ranking, "board_id");
    create_node_int(ranking_node, ranking, "registration");
    create_node_enum(ranking_node, ranking, "registration_type", gtengine::RegistrationType);

    var begin_date = ranking.begin_date;
    if (begin_date != 0)
    {
        var begin_date_node = pdistd::MDomNode();
        begin_date_node.value = ranking.begin_date_str;
        ranking_node.addNode("begin_date", begin_date_node);
    }
    var end_date = ranking.end_date;
    if (end_date != 0)
    {
        var end_date_node = pdistd::MDomNode();
        end_date_node.value = ranking.end_date_str;
        ranking_node.addNode("end_date", end_date_node);
    }

    return ranking_node;
}

function createLocalizeTextXML(localize_text, put_even_though_vacant)
{
    if (put_even_though_vacant == nil)
        put_even_though_vacant = false;

    var localize_text_node = pdistd::MDomNode();

    var found = false;
    foreach (|var langname| in pdistd::Language)
    {
        var text = localize_text.getText(langname);
        if (text != nil && text != "" || put_even_though_vacant)
        {
            var lang_node = pdistd::MDomNode();
            lang_node.value = text;
            localize_text_node.addNode(langname, lang_node);
            found = true;
        }
    }

    return localize_text_node;
}

function createInformationXML(information)
{
    var information_node = pdistd::MDomNode();

    var title_node = createLocalizeTextXML(information.title);
    if (title_node != nil)
        information_node.addNode("title", title_node);
    var one_line_title_node = createLocalizeTextXML(information.one_line_title);
    if (one_line_title_node != nil)
        information_node.addNode("one_line_title", one_line_title_node);
    var description_node = createLocalizeTextXML(information.description);
    if (description_node != nil)
        information_node.addNode("description", description_node);
    var advanced_notice_node = createLocalizeTextXML(information.advanced_notice);
    if (advanced_notice_node != nil)
        information_node.addNode("advanced_notice", advanced_notice_node);
    var registration_notice_node = createLocalizeTextXML(information.registration_notice);
    if (registration_notice_node != nil)
        information_node.addNode("registration_notice", registration_notice_node);



    if (information.narration_id != 0)
        create_node_int(information_node, information, "narration_id");
    if (information.logo_image_path != "")
        create_node_value(information_node, information, "logo_image_path");
    if (information.logo_image_layout != 0)
        create_node_int(information_node, information, "logo_image_layout");
    create_node_bin(information_node, information, "logo_image_buffer");
    create_node_value(information_node, information, "logo_other_info");
    if (information.flier_image_path != "")
        create_node_value(information_node, information, "flier_image_path");
    create_node_bin(information_node, information, "flier_image_buffer");
    create_node_value(information_node, information, "flier_other_info");
    if (information.race_label != "")
        create_node_value(information_node, information, "race_label");

    if (information.race_info_minute != 0)
        create_node_uint(information_node, information, "race_info_minute");

    return information_node;
}

function createReplayXML(replay)
{
    if (replay.isDefault())
        return nil;

    var replay_node = pdistd::MDomNode();


    create_node_value(replay_node, replay, "local_path");
    create_node_value(replay_node, replay, "url");
    create_node_value(replay_node, replay, "demo_data_path");
    create_node_enum(replay_node, replay, "replay_recording_quality", gtengine::ReplayRecordingQuality);
    create_node_int(replay_node, replay, "auto_save");

    return replay_node;
}

/*************************************/
/*************************************/
/*             READING               */
/*************************************/
/*************************************/
function apply_attr_value(gnode, group, attrname, need_escape)
{
    var node = gnode[attrname];
    if (node != nil && node[0] != nil)
    {
        var s = node[0].getAttribute("value", 0);
        if (need_escape != nil && need_escape)
        {
            
            s.replaceAll("&lt;", "<");
            s.replaceAll("&gt;", ">");
            s.replaceAll("&quot;", "\"");
            s.replaceAll("&apos;", "'");
            s.replaceAll("&amp;", "&");
        }
        group.setObjectAttribute(attrname, s);
    }
}


function apply_attr_hex(gnode, group, attrname, isULong)
{
    var node = gnode[attrname];
    if (node != nil && node[0] != nil)
    {
        var value;
        if (isULong != nil)
            value = node[0].getAttribute("value", 0).toULong();
        else
            value = node[0].getAttribute("value", 0).toLong();
        
        if (value < -1)
            value = value.toInt();
        group.setObjectAttribute(attrname, value);
    }
}


function apply_attr_int(gnode, group, attrname)
{
    var node = gnode[attrname];
    if (node != nil && node[0] != nil)
    {
        var value = node[0].getAttribute("value", 0).toInt();
        if (value < -1)
            value = value.toInt();
        group.setObjectAttribute(attrname, value);
    }
}


function apply_attr_uint(gnode, group, attrname)
{
    var node = gnode[attrname];
    if (node != nil && node[0] != nil)
    {
        var value = node[0].getAttribute("value", 0).toUInt();
        group.setObjectAttribute(attrname, value);
    }
}


function apply_attr_long(gnode, group, attrname)
{
    var node = gnode[attrname];
    if (node != nil && node[0] != nil)
    {
        var value = node[0].getAttribute("value", 0).toLong();
        group.setObjectAttribute(attrname, value);
    }
}

function apply_attr_ulong(gnode, group, attrname)
{
    var node = gnode[attrname];
    if (node != nil && node[0] != nil)
    {
        var value = node[0].getAttribute("value", 0).toULong();
        group.setObjectAttribute(attrname, value);
    }
}

function apply_attr_float(gnode, group, attrname)
{
    var node = gnode[attrname];
    if (node != nil && node[0] != nil)
    {
        var value = node[0].getAttribute("value", 0).toFloat();
        group.setObjectAttribute(attrname, value);
    }
}

function apply_attr_enum(gnode, group, attrname, mdl)
{
    var node = gnode[attrname];
    if (node != nil && node[0] != nil)
    {
        var value = node[0].getAttribute("value", "");
        value = mdl[value]
        if (value != nil)
            group.setObjectAttribute(attrname, value);
    }
}

function apply_attr_minmax(gnode, group, attrname, min_default, max_default)
{
    var node = gnode[attrname];
    if (node != nil && node[0] != nil)
    {
        var pair = Array(2);
        pair[0] = node[0].getAttribute("min", min_default);
        pair[1] = node[0].getAttribute("max", max_default);
        group.setObjectAttribute(attrname, pair);
    }
}


function apply_attr_array(gnode, group, plural_attrname, attrname)
{
    var node = gnode[plural_attrname];
    var obj_attr = group.getObjectAttribute(plural_attrname);
    if (node != nil && node[0] != nil && obj_attr != nil)
    {
        var node0 = node[0][attrname];
        if (node0 != nil)
        {
            var num = node0.size;
            if (obj_attr.isInstanceOf(System::Array))
            {
                var array = Array(num);
                for (var i = 0; i < num; i++)
                {
                    array[i] = node0[i].getAttribute("value");
                }
                group.setObjectAttribute(plural_attrname, array);
            }
            else
            {
                obj_attr.resize(num);
                for (var i = 0; i < num; i++)
                {
                    obj_attr[i] = node0[i].getAttribute("value");
                }
            }
        }
    }
}


function apply_attr_int_array(gnode, group, plural_attrname, attrname)
{
    var node = gnode[plural_attrname];
    var obj_attr = group.getObjectAttribute(plural_attrname);
    if (node != nil && node[0] != nil)
    {
        var node0 = node[0][attrname];
        if (node0 != nil)
        {
            var num = node0.size;
            if (obj_attr.isInstanceOf(System::Array))
            {
                var array = Array(num);
                for (var i = 0; i < num; i++)
                {
                    array[i] = node0[i].getAttribute("value").toInt();
                }
                group.setObjectAttribute(plural_attrname, array);
            }
            else
            {
                obj_attr.resize(num);
                for (var i = 0; i < num; i++)
                {
                    obj_attr[i] = node0[i].getAttribute("value").toInt();
                }
            }
        }
    }
}

function apply_attr_enum_array(gnode, group, plural_attrname, attrname, mdl)
{
    var node = gnode[plural_attrname];
    if (node != nil && node[0] != nil)
    {
        var node0 = node[0][attrname];
        if (node0 != nil)
        {
            var num = node0.size;
            var list_attr = group.getObjectAttribute(plural_attrname);
            list_attr.resize(num);
            for (var i = 0; i < num; i++)
            {
                var value = node0[i].getAttribute("value", "");
                value = mdl[value];
                if (value != nil)
                    list_attr[i] = value;
            }
        }
    }
}

function apply_attr_func_array(gnode, group, plural_attrname, attrname, func)
{
    var node = gnode[plural_attrname];
    if (node != nil && node[0] != nil)
    {
        var node0 = node[0][attrname];
        if (node0 != nil)
        {
            var num = node0.size;
            var list_attr = group.getObjectAttribute(plural_attrname);
            list_attr.resize(num);
            for (var i = 0; i < num; i++)
            {
                var value = node0[i].getAttribute("value", "");
                list_attr[i] = func(value);
            }
        }
    }
}

function apply_attr_cars(gnode, group, is_ban_cars)
{
    var node_name = "cars";
    if (is_ban_cars != nil)
        node_name = "ban_cars";
    
    var node = gnode[node_name];
    if (node != nil && node[0] != nil)
    {
        var node0 = node[0]["car"];
        if (node0 != nil)
        {
            var num = node0.size;
            if (is_ban_cars != nil)
                group.ban_cars.resize(num);
            else
                group.cars.resize(num);

            for (var i = 0; i < num; i++)
            {
                var code_attr = node0[i].getAttribute("label");
                if (code_attr != nil)
                {
                    var col = node0[i].hasAttribute("color") ? node0[i].getAttribute("color") : 0;
                    var ct = gtengine::MCarThin(code_attr.toString(), col);
                    ct.code == gtengine::MSpecDB::NO_CODE; // Nothing done


                    if (is_ban_cars != nil)
                        group.ban_cars[i] = ct;
                    else
                        group.cars[i] = ct;
                }
                else
                {
                    code_attr = node0[i].getAttribute("code", "-1");
                    if (code_attr != "-1")
                    {
                        var col = node0[i].hasAttribute("color") ? node0[i].getAttribute("color") : 0;
                        if (is_ban_cars != nil)
                            group.ban_cars[i] = gtengine::MCarThin(code_attr.toULong(), col);
                        else
                            group.cars[i] = gtengine::MCarThin(code_attr.toULong(), col);
                    }
                }
            }
        }
    }
}

function apply_attr_present(gnode, group, attr_present = "present")
{
    var node = gnode[attr_present];

    if (node != nil && node[0] != nil)
    {
        var node0 = node[0]["item"];
        if (node0 != nil)
        {
            var num = node0.size;

            if (attr_present == "entry_present")
                group.entry_present.resize(num);
            else
                group.present.resize(num);

            for (var i = 0; i < num; i++)
            {
                var type_attr = node0[i].getAttribute("type_id");
                var category_attr = node0[i].getAttribute("category_id");
                if (type_attr != nil && category_attr != nil)
                {
                    var gi = main::gtengine::MGameItem();
                    gi.itemtype = node0[i].getAttribute("type_id");
                    gi.itemcategory = node0[i].getAttribute("category_id");
                    gi.argument1 = node0[i].getAttribute("argument1");
                    gi.argument2 = node0[i].getAttribute("argument2");
                    gi.argument3 = node0[i].getAttribute("argument3");
                    gi.argument4 = node0[i].getAttribute("argument4");
                    gi.f_name = node0[i].getAttribute("f_name");

                    if (attr_present == "entry_present")
                        group.entry_present[i] = gi;
                    else
                        group.present[i] = gi;
                }
            }
        }
    }
}

function apply_attr_bin(gnode, group, attrname)
{
    var node = gnode[attrname];
    if (node != nil && node[0] != nil)
    {
        var value = node[0].getAttribute("value");
        if (value == nil)
            return;

        var compressed = pdistd::DecodeBase64(value);
        var bytedata = pdistd::Inflate(compressed);
        group.setObjectAttribute(attrname, bytedata);
    }
}

function apply_attr_course(gnode, group, attrname)
{
    var node = gnode[attrname];
    if (node != nil && node[0] != nil)
    {
        var label = node[0].getAttribute("label");
        if (label != nil)
        {
            var code = gtengine::MSpecDB::getCourseCode(label);
            if (code == gtengine::MSpecDB::NO_CODE)
            {
                // Default to tsukuba if not found
                code = gtengine::MSpecDB::getCourseCode("tsukuba");
            }
            group.setObjectAttribute(attrname, code);
        }
        else
            apply_attr_hex(gnode, group, attrname, true);
    }
}

function apply_attr_mtime(gnode, group, attrname)
{
    var node = gnode[attrname];
    if (node != nil && node[0] != nil)
    {
        var str = node[0].getAttribute("datetime");
        if (str != nil)
        {
            var mtime = pdistd::MTime(str);
            group.setObjectAttribute(attrname, mtime);
        }
    }
}

function parseDriverParameterXml(dp, dp_node)
{
    apply_attr_int(dp_node, dp, "port");
    apply_attr_enum(dp_node, dp, "type", gtengine::DriverType);
    apply_attr_value(dp_node, dp, "display_name");
    apply_attr_value(dp_node, dp, "region");

    apply_attr_int(dp_node, dp, "physics_pro");
    apply_attr_int(dp_node, dp, "head_code");
    apply_attr_int(dp_node, dp, "body_code");
    apply_attr_int(dp_node, dp, "head_color_code");
    apply_attr_int(dp_node, dp, "body_color_code");
    apply_attr_int(dp_node, dp, "braking_skill");
    apply_attr_int(dp_node, dp, "starting_skill");
    apply_attr_int(dp_node, dp, "cornering_skill");
    apply_attr_int(dp_node, dp, "accelerating_skill");
    apply_attr_int(dp_node, dp, "ai_roughness");
    apply_attr_enum(dp_node, dp, "special_ai_type", gtengine::SpecialAIType);
    apply_attr_value(dp_node, dp, "display_driving_line");
}

function applyStageResetDataXML(reset_data, node)
{
    if (node == nil)
        return;

    apply_attr_value(node, reset_data, "code");
    apply_attr_enum(node, reset_data, "coord", gtengine::StageCoordType);
    apply_attr_int(node, reset_data, "target_id");
    apply_attr_int(node, reset_data, "resource_id");

    apply_attr_float(node, reset_data, "x");
    apply_attr_float(node, reset_data, "y");
    apply_attr_float(node, reset_data, "z");
    apply_attr_float(node, reset_data, "rotYdeg");
    apply_attr_float(node, reset_data, "vcoord");
}


function apply_attr_stage_reset_data_array(gnode, array_base)
{
    var node = gnode;
    if (node != nil && node[0] != nil)
    {
        var node0 = node[0]["stage_reset_data"];
        if (node0 != nil)
        {
            var num = node0.size;
            array_base.resize(num);

            for (var i = 0; i < num; i++)
            {
                applyStageResetDataXML(array_base[i], node0[i]);
            }
        }
    }
}

function applyLicenseConditionDataXML(data, data_node)
{
    if (data_node == nil)
        return;

    apply_attr_enum(data_node, data, "check_type", gtengine::LicenseCheckType);
    apply_attr_enum(data_node, data, "condition", gtengine::LicenseConditionType);
    apply_attr_enum(data_node, data, "connection", gtengine::LicenseConnectionType);
    apply_attr_int(data_node, data, "result_type");
    apply_attr_float(data_node, data, "float_value");
    apply_attr_uint(data_node, data, "uint_value");
    apply_attr_int(data_node, data, "int_value");
}

function apply_attr_license_condition_data_array(gnode, array_base)
{
    var node = gnode;
    if (node != nil && node[0] != nil)
    {
        var node0 = node[0]["data"];
        if (node0 != nil)
        {
            var num = node0.size;
            array_base.resize(num);

            for (var i = 0; i < num; i++)
            {
                applyLicenseConditionDataXML(array_base[i], node0[i]);
            }
        }
    }
}


function apply_attr_aiscripter(gnode, group, attrname)
{
    var node = gnode[attrname];
    if (node != nil && node[0] != nil)
    {
        var s = node[0].getAttribute("value", 0);
        
        s.replaceAll("&lt;", "<");
        s.replaceAll("&gt;", ">");
        s.replaceAll("&quot;", "\"");
        s.replaceAll("&apos;", "'");
        s.replaceAll("&amp;", "&");
        group.setObjectAttribute(attrname, s);
    }
}

function apply_attr_entry_base(node, entry_base)
{

    if (node["car"] != nil)
    {
        var car_thin = node["car"][0];

        var label = car_thin.getAttribute("label");
        var col = car_thin.hasAttribute("color") ? car_thin.getAttribute("color") : 0;
        var ct = gtengine::MCarThin(label.toString(), col);
        entry_base.car = ct;
    }

    apply_attr_value(node, entry_base, "driver_name");
    apply_attr_value(node, entry_base, "driver_region");

    apply_attr_int(node, entry_base, "race_class_id");
    apply_attr_int(node, entry_base, "proxy_driver_model");

    apply_attr_int_array(node, entry_base, "boost_race_ratio", "race_ratio");
    apply_attr_int_array(node, entry_base, "boost_ratio", "ratio");

    apply_attr_int(node, entry_base, "ai_skill_breaking");
    apply_attr_int(node, entry_base, "ai_skill_cornering");
    apply_attr_int(node, entry_base, "ai_skill_accelerating");
    apply_attr_int(node, entry_base, "ai_skill_starting");
    apply_attr_int(node, entry_base, "ai_roughness");
    apply_attr_int(node, entry_base, "ai_reaction");

    apply_attr_enum(node, entry_base, "engine_na_tune_stage", gtengine::PARTS_NATUNE);
    apply_attr_enum(node, entry_base, "engine_turbo_kit", gtengine::PARTS_TURBINEKIT);
    apply_attr_enum(node, entry_base, "engine_computer", gtengine::PARTS_COMPUTER);
    apply_attr_enum(node, entry_base, "muffler", gtengine::PARTS_MUFFLER);
    apply_attr_enum(node, entry_base, "suspension", gtengine::PARTS_SUSPENSION);
    apply_attr_enum(node, entry_base, "transmission", gtengine::PARTS_GEAR);
    apply_attr_int(node, entry_base, "wheel");
    apply_attr_int(node, entry_base, "wheel_color");
    apply_attr_int(node, entry_base, "wheel_inch_up");
    apply_attr_enum(node, entry_base, "tire_f", gtengine::PARTS_TIRE);
    apply_attr_enum(node, entry_base, "tire_r", gtengine::PARTS_TIRE);
    apply_attr_int(node, entry_base, "aero_wing");
    apply_attr_int(node, entry_base, "aero_1");
    apply_attr_int(node, entry_base, "aero_2");
    apply_attr_int(node, entry_base, "aero_3");
    apply_attr_int(node, entry_base, "power_limiter");
    apply_attr_int(node, entry_base, "downforce_f");
    apply_attr_int(node, entry_base, "downforce_r");
    apply_attr_int(node, entry_base, "gear_max_speed");

    apply_attr_int(node, entry_base, "ballast_weight");
    apply_attr_int(node, entry_base, "ballast_position");

    apply_attr_int(node, entry_base, "paint_id");
    apply_attr_int(node, entry_base, "decken_number");
    apply_attr_int(node, entry_base, "decken_type");
    apply_attr_int(node, entry_base, "decken_custom_id");
    apply_attr_int(node, entry_base, "decken_custom_type");

    apply_attr_int(node, entry_base, "head_code");
    apply_attr_int(node, entry_base, "body_code");
    apply_attr_int(node, entry_base, "head_color_code");
    apply_attr_int(node, entry_base, "body_color_code");
}

function apply_attr_entry_base_array(gnode, entry_generate)
{
    var node_name = "entry_base_array";

    var node = gnode[node_name];
    if (node != nil && node[0] != nil)
    {
        var node0 = node[0]["entry_base"];
        if (node0 != nil)
        {
            var num = node0.size;
            entry_generate.entry_base_array.resize(num);

            for (var i = 0; i < num; i++)
            {
                apply_attr_entry_base(node0[i], entry_generate.entry_base_array[i]);
            }
        }
    }
}

function apply_boost_table(race_node, rp)
{
    var node_name = "boost_table_array";

    var node = race_node[node_name];
    if (node != nil && node[0] != nil)
    {
        var node0 = node[0]["boost_table"];
        if (node0 != nil)
        {
            var num = node0.size;
            for (var i = 0; i < num; i++)
            {
                var nodeList = node0[i];
                var param_size = nodeList["param"].size;
                var array = Array(param_size);

                // Og code pushes a new variable still named i, but different stack index
                // It's weird, just declare it as j
                for (var j = 0; j < param_size; j++)
                {
                    array[j] = nodeList["param"][j].getAttribute("value");
                }
                rp.boost_table = array;
            }
        }
    }
}

function apply_attr_new_weather_points(race_node, rp)
{
    var node_name = "new_weather_data";

    var node = race_node[node_name];
    if (node != nil && node[0] != nil)
    {
        var node0 = node[0]["point"];
        if (node0 != nil)
        {
            var num = node0.size;
            for (var i = 0; i < num; i++)
            {
                var node = node0[i];
                var idx = i;
                var time_rate = node["time_rate"][0].getAttribute("value", 0).toFloat();
                time_rate /= 100.0;
                var l_value = node["low"][0].getAttribute("value", 0).toFloat();
                var h_value = node["high"][0].getAttribute("value", 0).toFloat();
                rp.setWeatherValue(idx, time_rate, l_value, h_value);
            }

            num != rp.weather_point_num; // Nothing done
        }
    }
}

function parseEventXML(event, event_node)
{
    apply_attr_long(event_node, event, "event_id");

    apply_attr_enum(event_node, event, "game_mode", gtengine::GameMode);

    var play_style_node = event_node["play_style"];
    if (play_style_node != nil)
    {
        var play_style = event.play_style;

        play_style_node = play_style_node[0];
        apply_attr_enum(play_style_node, play_style, "bspec_type", gtengine::BSpecType);
        apply_attr_enum(play_style_node, play_style, "play_type", gtengine::PlayType);
        apply_attr_int(play_style_node, play_style, "no_quickmenu");
        apply_attr_int(play_style_node, play_style, "no_instant_replay");
        apply_attr_int(play_style_node, play_style, "replay_record_enable");
        apply_attr_int(play_style_node, play_style, "rentcar_setting_enable");
        apply_attr_int(play_style_node, play_style, "window_num");
        apply_attr_int(play_style_node, play_style, "time_limit");
        apply_attr_int(play_style_node, play_style, "leave_limit");
    }

    apply_attr_enum(event_node, event, "event_type", gtengine::EventType);

    apply_attr_int(event_node, event, "inheritance");

    apply_attr_int(event_node, event, "is_seasonal_event");


    var regulation_node = event_node["regulation"];
    if (regulation_node != nil)
    {
        var regulation = event.regulation;

        regulation_node = regulation_node[0];
        apply_attr_int(regulation_node, regulation, "limit_pp");
        apply_attr_int(regulation_node, regulation, "need_pp");
        apply_attr_int(regulation_node, regulation, "limit_tire_f");
        apply_attr_int(regulation_node, regulation, "need_tire_f");
        apply_attr_int(regulation_node, regulation, "limit_tire_r");
        apply_attr_int(regulation_node, regulation, "need_tire_r");
        apply_attr_enum_array(regulation_node, regulation, "car_categories", "category", gtengine::CarCategory);
        apply_attr_cars(regulation_node, regulation);
        apply_attr_cars(regulation_node, regulation, true);
        apply_attr_int(regulation_node, regulation, "need_license");
        apply_attr_int(regulation_node, regulation, "limit_power");
        apply_attr_int(regulation_node, regulation, "need_power");
        apply_attr_int(regulation_node, regulation, "limit_weight");
        apply_attr_int(regulation_node, regulation, "need_weight");
        apply_attr_int(regulation_node, regulation, "limit_length");
        apply_attr_int(regulation_node, regulation, "need_length");
        apply_attr_int(regulation_node, regulation, "need_drivetrain");
        apply_attr_int(regulation_node, regulation, "need_aspiration");
        apply_attr_int(regulation_node, regulation, "tuning");
        apply_attr_int(regulation_node, regulation, "NOS");
        apply_attr_int(regulation_node, regulation, "kart_permitted");
        apply_attr_int(regulation_node, regulation, "car_tag_id");
        apply_attr_int(regulation_node, regulation, "restrictor_limit");
        apply_attr_int(regulation_node, regulation, "limit_year");
        apply_attr_int(regulation_node, regulation, "need_year");
        apply_attr_enum_array(regulation_node, regulation, "tuners", "tuner", gtengine::Tuner);
        apply_attr_enum_array(regulation_node, regulation, "countries", "country", gtengine::Country);
        apply_attr_int(regulation_node, regulation, "limit_aspec_level");
        apply_attr_int(regulation_node, regulation, "need_aspec_level");
        apply_attr_int(regulation_node, regulation, "limit_bspec_level");
        apply_attr_int(regulation_node, regulation, "need_bspec_level");
        apply_attr_int(regulation_node, regulation, "limit_bspec_driver_count");
        apply_attr_int(regulation_node, regulation, "need_bspec_driver_count");
        apply_attr_value(regulation_node, regulation, "need_entitlement");
    }

    var constraint_node = event_node["constraint"];
    if (constraint_node != nil)
    {
        var constraint = event.constraint;

        constraint_node = constraint_node[0];
        apply_attr_int(constraint_node, constraint, "transmission");
        apply_attr_int(constraint_node, constraint, "driving_line");
        apply_attr_int(constraint_node, constraint, "asm");
        apply_attr_int(constraint_node, constraint, "tcs");
        apply_attr_int(constraint_node, constraint, "suggest_tcs");
        apply_attr_int(constraint_node, constraint, "abs");
        apply_attr_int(constraint_node, constraint, "simulation");
        apply_attr_int(constraint_node, constraint, "limit_tire_f");
        apply_attr_int(constraint_node, constraint, "need_tire_f");
        apply_attr_int(constraint_node, constraint, "suggest_tire_f");
        apply_attr_int(constraint_node, constraint, "limit_tire_r");
        apply_attr_int(constraint_node, constraint, "need_tire_r");
        apply_attr_int(constraint_node, constraint, "suggest_tire_r");
        apply_attr_int(constraint_node, constraint, "active_steering");
        apply_attr_int(constraint_node, constraint, "drift_type");
        apply_attr_int(constraint_node, constraint, "suggested_gear");
        apply_attr_int(constraint_node, constraint, "in_car_view");
        apply_attr_int(constraint_node, constraint, "enemy_tire");
        apply_attr_cars(constraint_node, constraint);
    }


    var arcade_setting_node = event_node["arcade_style_setting"];
    if (arcade_setting_node != nil)
    {
        var arcade_setting = event.arcade_setting;
        arcade_setting_node = arcade_setting_node[0];
        apply_attr_int(arcade_setting_node, arcade_setting, "start_seconds");
        apply_attr_int(arcade_setting_node, arcade_setting, "default_extend_seconds");
        apply_attr_int(arcade_setting_node, arcade_setting, "limit_seconds");
        apply_attr_int(arcade_setting_node, arcade_setting, "level_up_step");
        apply_attr_int(arcade_setting_node, arcade_setting, "overtake_seconds");
        apply_attr_int(arcade_setting_node, arcade_setting, "enable_speed_trap");
        apply_attr_int(arcade_setting_node, arcade_setting, "enable_jump_bonus");
        apply_attr_int(arcade_setting_node, arcade_setting, "appear_step_v");
        apply_attr_int(arcade_setting_node, arcade_setting, "disappear_step_v");

        apply_attr_int(arcade_setting_node, arcade_setting, "afford_time");
        apply_attr_int(arcade_setting_node, arcade_setting, "overtake_score");
        apply_attr_int(arcade_setting_node, arcade_setting, "speed_trap_score");
        apply_attr_int(arcade_setting_node, arcade_setting, "jump_bonus_score");
        apply_attr_int(arcade_setting_node, arcade_setting, "startup_step_v");
        apply_attr_int(arcade_setting_node, arcade_setting, "startup_offset_v");
        apply_attr_int(arcade_setting_node, arcade_setting, "initial_velocity_l");
        apply_attr_int(arcade_setting_node, arcade_setting, "initial_velocity_h");

        apply_attr_int_array(arcade_setting_node, arcade_setting, "section_extend_seconds", "seconds");
        apply_attr_int_array(arcade_setting_node, arcade_setting, "speed_trap", "coursev");
    }
	
    var race_node = event_node["race"];
    if (race_node != nil)
    {

        var rp = gtengine::MRaceParameter();

        race_node = race_node[0];
        apply_attr_enum(race_node, rp, "race_type", gtengine::RaceType);
        apply_attr_enum(race_node, rp, "start_type", gtengine::StartType);
        apply_attr_enum(race_node, rp, "complete_type", gtengine::CompleteType);
        apply_attr_enum(race_node, rp, "finish_type", gtengine::FinishType);
        apply_attr_int(race_node, rp, "race_limit_laps");
        apply_attr_int(race_node, rp, "race_limit_minute");
        apply_attr_int(race_node, rp, "time_to_start");
        apply_attr_int(race_node, rp, "time_to_finish");
        apply_attr_int(race_node, rp, "entry_max");
        apply_attr_int(race_node, rp, "racers_max");
        apply_attr_int(race_node, rp, "keep_load_ghost");
        apply_attr_int(race_node, rp, "immediate_finish");
        apply_attr_enum(race_node, rp, "grid_sort_type", gtengine::GridSortType);
        apply_attr_int(race_node, rp, "autostart_pitout");
        apply_attr_int(race_node, rp, "endless");
        apply_attr_enum(race_node, rp, "ghost_type", gtengine::GhostType);
        apply_attr_int(race_node, rp, "disable_collision");
        apply_attr_int(race_node, rp, "penalty_level");
        apply_attr_int(race_node, rp, "accumulation");
        apply_attr_int(race_node, rp, "bspec_vitality10");
        apply_attr_int(race_node, rp, "consume_fuel");
        apply_attr_int(race_node, rp, "consume_tire");
        apply_attr_int(race_node, rp, "temperature_tire");
        apply_attr_int(race_node, rp, "temperature_brake");
        apply_attr_int(race_node, rp, "temperature_engine");
        apply_attr_int(race_node, rp, "goal_time_use_lap_total");
        apply_attr_int(race_node, rp, "start_time_offset");
        apply_attr_int(race_node, rp, "start_signal_type");
        apply_attr_int(race_node, rp, "consideration_type");

        apply_attr_int(race_node, rp, "academy_event");
        apply_attr_enum(race_node, rp, "lighting_mode", gtengine::LightingMode);
        apply_attr_array(race_node, rp, "boost_params", "param");

        apply_boost_table(race_node, rp);

        apply_attr_int(race_node, rp, "boost_level");
        apply_attr_int(race_node, rp, "boost_type");
        apply_attr_int(race_node, rp, "boost_flag");

        apply_attr_mtime(race_node, rp, "datetime");
        apply_attr_float(race_node, rp, "time_progress_speed");
        apply_attr_int(race_node, rp, "lucky_player");
        apply_attr_int(race_node, rp, "enable_pit");
        apply_attr_int(race_node, rp, "pit_constraint");
        apply_attr_int(race_node, rp, "course_out_penalty_margine");
        apply_attr_int(race_node, rp, "behavior_fallback");
        apply_attr_int(race_node, rp, "need_tire_change");
        apply_attr_int(race_node, rp, "disable_recording_replay");
        apply_attr_enum(race_node, rp, "flagset", gtengine::RaceFlagSet);
        apply_attr_int(race_node, rp, "online_on");
        apply_attr_array(race_node, rp, "grid_list", "grid");
        apply_attr_array(race_node, rp, "event_v_list", "v");
        apply_attr_int(race_node, rp, "auto_standing_delay");
        apply_attr_int(race_node, rp, "allow_codriver");
        apply_attr_int(race_node, rp, "pace_note");
        apply_attr_int(race_node, rp, "replace_at_courseout");
        apply_attr_int(race_node, rp, "mu_ratio100");
        apply_attr_int(race_node, rp, "enable_damage");
        apply_attr_int(race_node, rp, "penalty_no_reset");
        apply_attr_enum(race_node, rp, "low_mu_type", gtengine::LowMuType);
        apply_attr_enum(race_node, rp, "behavior_damage_type", gtengine::BehaviorDamageType);
        apply_attr_enum(race_node, rp, "behavior_slip_stream_type", gtengine::BehaviorSlipStreamType);
        apply_attr_enum(race_node, rp, "ghost_presence_type", gtengine::GhostPresenceType);
        apply_attr_int(race_node, rp, "line_ghost_play_max");
        apply_attr_enum(race_node, rp, "line_ghost_record_type", gtengine::LineGhostRecordType);
        apply_attr_enum(race_node, rp, "attack_separate_type", gtengine::AttackSeparateType);
        apply_attr_int(race_node, rp, "event_start_v");
        apply_attr_int(race_node, rp, "event_goal_v");
        apply_attr_int(race_node, rp, "event_goal_width");


        apply_attr_int(race_node, rp, "fixed_retention");
        apply_attr_enum(race_node, rp, "decisive_weather", gtengine::DecisiveWeather);
        apply_attr_int(race_node, rp, "weather_random_seed");
        apply_attr_int(race_node, rp, "weather_random");


        apply_attr_int(race_node, rp, "weather_base_celsius");
        apply_attr_int(race_node, rp, "weather_max_celsius");
        apply_attr_int(race_node, rp, "weather_min_celsius");


        apply_attr_int(race_node, rp, "weather_accel100");
        apply_attr_float(race_node, rp, "weather_rate_sec1");
        apply_attr_float(race_node, rp, "weather_rate_sec2");
        apply_attr_float(race_node, rp, "weather_value0");
        apply_attr_float(race_node, rp, "weather_value1");
        apply_attr_float(race_node, rp, "weather_value2");
        apply_attr_float(race_node, rp, "weather_value3");

        
        apply_attr_int(race_node, rp, "weather_no_schedule");
        apply_attr_int(race_node, rp, "weather_no_precipitation");
        apply_attr_int(race_node, rp, "weather_no_wind");
        apply_attr_int(race_node, rp, "weather_prec_rain_only");
        apply_attr_int(race_node, rp, "weather_prec_snow_only");
        apply_attr_int(race_node, rp, "weather_point_num");
        apply_attr_float(race_node, rp, "weather_total_sec");
        apply_attr_int(race_node, rp, "initial_retention10");
        apply_attr_int(race_node, rp, "weather_accel10");
        apply_attr_int(race_node, rp, "weather_accel_water_retention10");

        apply_attr_new_weather_points(race_node, rp);

        event.race_parameter = rp;
    }


    var track_node = event_node["track"];
    if (track_node != nil)
    {
        var track = event.track;

        track_node = track_node[0];

        apply_attr_course(track_node, track, "course_code");
        apply_attr_ulong(track_node, track, "generated_course_id");
        apply_attr_hex(track_node, track, "course_layout_no");

        var gadgets_node = track_node["gadget"];
        if (gadgets_node != nil)
        {
            var num = gadgets_node.size;
            track.gadgets.resize(num);

            for (var i = 0; i < num; i++)
            {
                var gadget = track.gadgets[i];
                var gadget_node = gadgets_node[i];
                apply_attr_value(gadget_node, gadget, "kind_db_id");

                apply_attr_float(gadget_node, gadget, "x");
                apply_attr_float(gadget_node, gadget, "y");
                apply_attr_float(gadget_node, gadget, "z");
                apply_attr_array(gadget_node, gadget, "posture", "param");
            }
        }
        apply_attr_bin(track_node, track, "edit_data");
        apply_attr_int(track_node, track, "map_offset_world_x");
        apply_attr_int(track_node, track, "map_offset_world_y");
        apply_attr_int(track_node, track, "map_scale");
        apply_attr_int(track_node, track, "is_omedeto_difficulty");
    }


    var entry_set_node = event_node["entry_set"];
    if (entry_set_node != nil)
    {
        var entry_set = event.entry_set;


        entry_set_node = entry_set_node[0];

        var entry_generate_node = entry_set_node["entry_generate"];
        if (entry_generate_node != nil)
        {
            var entry_generate = entry_set.entry_generate;

            entry_generate_node = entry_generate_node[0];
            apply_attr_int(entry_generate_node, entry_generate, "entry_num");
            apply_attr_int(entry_generate_node, entry_generate, "player_pos");
            apply_attr_enum(entry_generate_node, entry_generate, "generate_type", gtengine::GenerateType);
            apply_attr_enum(entry_generate_node, entry_generate, "enemy_list_type", gtengine::EnemyListType);
            apply_attr_hex(entry_generate_node, entry_generate, "race_code", true);
            apply_attr_int(entry_generate_node, entry_generate, "ai_skill");
            apply_attr_int(entry_generate_node, entry_generate, "ai_skill_breaking");
            apply_attr_int(entry_generate_node, entry_generate, "ai_skill_cornering");
            apply_attr_int(entry_generate_node, entry_generate, "ai_skill_accelerating");
            apply_attr_int(entry_generate_node, entry_generate, "ai_skill_starting");
            apply_attr_int(entry_generate_node, entry_generate, "ai_roughness");
            apply_attr_int(entry_generate_node, entry_generate, "enemy_lv");
            apply_attr_int(entry_generate_node, entry_generate, "enemy_bspec_lv");
            apply_attr_int(entry_generate_node, entry_generate, "bspec_lv_offset");
            apply_attr_int(entry_generate_node, entry_generate, "gap_for_start_rolling_distance");
            apply_attr_int(entry_generate_node, entry_generate, "rolling_start_v");
            apply_attr_int(entry_generate_node, entry_generate, "use_rolling_start_param");
            apply_attr_cars(entry_generate_node, entry_generate);
            apply_attr_entry_base_array(entry_generate_node, entry_generate);
            apply_attr_int_array(entry_generate_node, entry_generate, "delays", "delay");
            apply_attr_enum(entry_generate_node, entry_generate, "enemy_sort_type", gtengine::EnemySortType);
        }

        var entries_node = entry_set_node["entry"];
        if (entries_node != nil)
        {
            var num = entries_node.size;
            entry_set.entries.resize(num);
            for (var i = 0; i < num; i++)
            {
                var entry = entry_set.entries[i];
                var entry_node = entries_node[i];

                apply_attr_int(entry_node, entry, "player_no");

                var car_node = entry_node["car"];
                if (car_node != nil)
                {

                    car_node = car_node[0];
                    var label_attr = car_node.getAttribute("label");
                    if (label_attr != nil)
                    {
                        var col = car_node.hasAttribute("color") ? car_node.getAttribute("color") : 0;
                        var ct = gtengine::MCarThin(label_attr.toString(), col);
                        ct.code == gtengine::MSpecDB::NO_CODE; // Nothing
                        
                        entry.car = ct;
                    }
                    else
                    {
                        var code_attr = car_node.getAttribute("code");
                        if (code_attr != nil)
                        {
                            var col = car_node.hasAttribute("color") ? car_node.getAttribute("color") : 0;
                            entry.car = gtengine::MCarThin(code_attr.toULong(), col);
                        }
                    }
                }


                apply_attr_value(entry_node, entry, "driver_name");
                apply_attr_value(entry_node, entry, "driver_region");

                var car_parameter_node = entry_node["car_parameter"];
                if (car_parameter_node != nil)
                {

                    car_parameter_node = car_parameter_node[0];
                    var version = car_parameter_node.getAttribute("version");
                    if (version == gtengine::MCarParameter::getVersion())
                    {
                        var value = car_parameter_node.value;
                        var compressed = pdistd::DecodeBase64(value);
                        var bytedata = pdistd::Inflate(compressed);
                        var map = ["version" : version, "data" : bytedata];
                        var car_parameter = gtengine::MCarParameter();
                        car_parameter.setArchiveTree(map);
                        entry.car_parameter = car_parameter;
                    }
                }

                var driver_parameter_node = entry_node["driver_parameter"];
                if (driver_parameter_node != nil)
                {
                    driver_parameter_node = driver_parameter_node[0];
                    parseDriverParameterXml(entry.driver_parameter, driver_parameter_node);
                }

                apply_attr_int(entry_node, entry, "pilot_id");


                var entry_base_node = entry_node["entry_base"];
                if (entry_base_node != nil)
                {

                    entry_base_node = entry_base_node[0];
                    apply_attr_entry_base(entry_base_node, entry.entry_base);
                }

                if (entry_node["initial_position"] != nil)
                {
                    apply_attr_int(entry_node, entry, "initial_position");
                    entry.available_initial_position = true;
                }
                apply_attr_int(entry_node, entry, "initial_velocity");
                apply_attr_enum(entry_node, entry, "start_type", gtengine::StartType);
                apply_attr_int(entry_node, entry, "delay");
                apply_attr_int(entry_node, entry, "race_class_id");
                apply_attr_int(entry_node, entry, "proxy_driver_model");
                apply_attr_int(entry_node, entry, "no_suitable_tire");
                apply_attr_int(entry_node, entry, "initial_fuel100");

                apply_attr_int_array(entry_node, entry, "boost_race_ratio", "race_ratio");
                apply_attr_int_array(entry_node, entry, "boost_ratio", "ratio");

                apply_attr_int(entry_node, entry, "ai_skill_breaking");
                apply_attr_int(entry_node, entry, "ai_skill_cornering");
                apply_attr_int(entry_node, entry, "ai_skill_accelerating");
                apply_attr_int(entry_node, entry, "ai_skill_starting");
                apply_attr_int(entry_node, entry, "ai_roughness");
            }
        }
    }



    var eval_condition_node = event_node["eval_condition"];
    if (eval_condition_node != nil)
    {
        var eval_condition = event.eval_condition;

        eval_condition_node = eval_condition_node[0];

        apply_attr_enum(eval_condition_node, eval_condition, "type", gtengine::EvalType);
        apply_attr_int(eval_condition_node, eval_condition, "gold");
        apply_attr_int(eval_condition_node, eval_condition, "silver");
        apply_attr_int(eval_condition_node, eval_condition, "bronze");
        apply_attr_value(eval_condition_node, eval_condition, "ghost_data_path");


        var node = eval_condition_node["data"];
        if (node != nil && node[0] != nil)
        {  
            var node0 = node[0]["item"];
            if (node0 != nil)
            {
                var num = node0.size;
                var array = Array(num);
                for (var i = 0; i < num; i++)
                {
                    array[i] = node0[i].getAttribute("value").toInt();
                }

                eval_condition.setObjectAttribute("gold", array[0]);
                eval_condition.setObjectAttribute("silver", array[1]);
                eval_condition.setObjectAttribute("bronze", array[2]);
            }
        }
    }

    var achieve_condition_node = event_node["achieve_condition"];
    if (achieve_condition_node != nil)
    {
        var achieve_condition = event.achieve_condition;


        achieve_condition_node = achieve_condition_node[0];

        apply_attr_enum(achieve_condition_node, achieve_condition, "type", gtengine::AchieveType);
        apply_attr_int(achieve_condition_node, achieve_condition, "num");
    }

    var failure_condition_node = event_node["failure_condition"];
    if (failure_condition_node != nil)
    {
        var failure_condition = event.failure_condition;


        failure_condition_node = failure_condition_node[0];

        apply_attr_enum_array(failure_condition_node, failure_condition, "type_list", "type", gtengine::FailureType);
        apply_attr_int_array(failure_condition_node, failure_condition, "data_list", "data");
        apply_attr_int(failure_condition_node, failure_condition, "no_failure_at_result");
    }


    var license_condition_node = event_node["license_condition"];
    if (license_condition_node != nil)
    {
        var license_condition = event.license_condition;



        license_condition_node = license_condition_node[0];

        apply_attr_int(license_condition_node, license_condition, "use_basic_finish");
        apply_attr_int(license_condition_node, license_condition, "stop_on_finish");
        apply_attr_enum(license_condition_node, license_condition, "display_mode", gtengine::LicenseDisplayModeType);
        apply_attr_array(license_condition_node, license_condition, "gadget_names", "gadget");

        apply_attr_license_condition_data_array(license_condition_node["finish_condition"], license_condition.finish_condition);
        apply_attr_license_condition_data_array(license_condition_node["failure_condition"], license_condition.failure_condition);
        apply_attr_license_condition_data_array(license_condition_node["success_condition"], license_condition.success_condition);
    }


    var drift_node = event_node["drift_condition"];
    if (drift_node != nil)
    {
        var drift_condition = event.drift_condition;
        drift_node = drift_node[0];

        apply_attr_uint(drift_node, drift_condition, "launch_speed");
        apply_attr_uint(drift_node, drift_condition, "launch_v");

        var node0 = drift_node["section"];
        if (node0 != nil)
        {
            var num = node0.size;
            var section = drift_condition.section;
            section.resize(num);
            for (var i = 0; i < num; i++)
            {
                section[i].start_v = node0[i].getAttribute("start");
                section[i].finish_v = node0[i].getAttribute("finish");
            }
        }
    }

    var reward_node = event_node["reward"];
    if (reward_node != nil)
    {
        parseRewardXML(event.reward, reward_node[0]);
    }

    var ranking_node = event_node["ranking"];
    if (ranking_node != nil)
    {
        parseRankingXML(event.ranking, ranking_node[0]);
    }



    var replay_node = event_node["replay"];
    if (replay_node != nil)
    {
        parseReplayXML(event.replay, replay_node[0]);
    }

    var information_node = event_node["information"];
    if (information_node != nil)
    {
        parseInformationXML(event.information, information_node[0]);
    }


    var node = event_node["begin_date"];
    if (node != nil && node[0] != nil && node[0].value != "")
        event.begin_date_str = node[0].value;
    else
        event.begin_date_str = "2010/04/02 12:00:00";

    
    var node = event_node["end_date"];
    if (node != nil && node[0] != nil && node[0].value != "")
        event.end_date_str = node[0].value;
    else
        event.end_date_str = "2010/04/02 12:00:00";
    


    var stage_data_node = event_node["stage_data"];
    if (stage_data_node != nil)
    {
        
        stage_data_node = stage_data_node[0];
        var stage_data = event.stage_data;

        apply_attr_stage_reset_data_array(stage_data_node["at_quick_back"], stage_data.at_quick);
        apply_attr_stage_reset_data_array(stage_data_node["at_quick"], stage_data.at_quick);
        apply_attr_stage_reset_data_array(stage_data_node["before_start"], stage_data.before_start);
        apply_attr_stage_reset_data_array(stage_data_node["race_start"], stage_data.countdown);
        apply_attr_stage_reset_data_array(stage_data_node["countdown"], stage_data.countdown);
        apply_attr_stage_reset_data_array(stage_data_node["race_end"], stage_data.race_end);

        apply_attr_enum(stage_data_node, stage_data, "layout_type_at_quick", gtengine::StageLayoutType);
        apply_attr_enum(stage_data_node, stage_data, "layout_type_before_start", gtengine::StageLayoutType);
        apply_attr_enum(stage_data_node, stage_data, "layout_type_countdown", gtengine::StageLayoutType);
        apply_attr_enum(stage_data_node, stage_data, "layout_type_race_end", gtengine::StageLayoutType);
        
        
    }
    apply_attr_aiscripter(event_node, event, "penalty_script");

    apply_attr_aiscripter(event_node, event, "ai_script");
}

function parseOnlineSeriesXML(series, node)
{
    apply_attr_course(node, series, "course_code");
    apply_attr_uint(node, series, "laps");
    apply_attr_uint(node, series, "time_progress_speed");
    apply_attr_mtime(node, series, "datetime");
}

function parseQualityControlParameterXML(qcp, node)
{
    apply_attr_int(node, qcp, "template_type");
}

function parseOnlineRoomXML(online_room, online_room_node)
{
    apply_attr_value(online_room_node, online_room, "comment", true);
    apply_attr_value(online_room_node, online_room, "password");
    apply_attr_enum(online_room_node, online_room, "room_type", gtengine::RoomType);
    apply_attr_enum(online_room_node, online_room, "room_policy", gtengine::RoomPolicy);
    apply_attr_enum(online_room_node, online_room, "scope", gtengine::Scope);
    apply_attr_enum(online_room_node, online_room, "chat_type", gtengine::ChatType);
    apply_attr_enum(online_room_node, online_room, "voice_quality", gtengine::VoiceQuality);
    apply_attr_enum(online_room_node, online_room, "voice_chat_mode", gtengine::VoiceChatMode);
    apply_attr_enum(online_room_node, online_room, "car_shuffle_method", gtengine::CarShuffleMethod);
    apply_attr_enum(online_room_node, online_room, "car_select_method", gtengine::CarSelectMethod);
    apply_attr_enum(online_room_node, online_room, "car_filter_type", gtengine::CarFilterType);
    apply_attr_enum(online_room_node, online_room, "course_select_method", gtengine::CourseSelectMethod);
    apply_attr_enum(online_room_node, online_room, "topology", pdistd::TopologyType);
    apply_attr_enum(online_room_node, online_room, "matching_space", gtengine::MatchingSpace);
    apply_attr_int(online_room_node, online_room, "room_max");
    apply_attr_int(online_room_node, online_room, "racer_max");
    apply_attr_int(online_room_node, online_room, "race_countdown");
    apply_attr_int(online_room_node, online_room, "auto_grant_ownership");
    apply_attr_int(online_room_node, online_room, "nat_restriction");
    apply_attr_int(online_room_node, online_room, "exclude_blocklist");
    apply_attr_int(online_room_node, online_room, "voice_chat");
    apply_attr_int(online_room_node, online_room, "is_lan");
    apply_attr_int(online_room_node, online_room, "fill_vacancy");
    apply_attr_int(online_room_node, online_room, "overwrite_user_name");
    apply_attr_int(online_room_node, online_room, "overwrite_user_region");
    apply_attr_int(online_room_node, online_room, "show_hidden_config");
    apply_attr_int(online_room_node, online_room, "use_custom_grid");
    apply_attr_int(online_room_node, online_room, "use_custom_countdown");
    apply_attr_int(online_room_node, online_room, "is_autocratic");
    apply_attr_int(online_room_node, online_room, "is_automated");
    apply_attr_int(online_room_node, online_room, "is_only_garage_car");
    apply_attr_int(online_room_node, online_room, "is_only_rental_car");
    apply_attr_int(online_room_node, online_room, "is_saved_course");
    apply_attr_int(online_room_node, online_room, "theme_color_index");
    apply_attr_enum(online_room_node, online_room, "room_game_mode", gtengine::RoomGameMode);
    apply_attr_enum(online_room_node, online_room, "trackday_mode", gtengine::TrackDayMode);
    apply_attr_enum(online_room_node, online_room, "battle_mode", gtengine::BattleMode);
    apply_attr_enum(online_room_node, online_room, "trial_start_type", gtengine::StartType);
    apply_attr_enum(online_room_node, online_room, "qualifier_race_type", gtengine::RaceType);
    apply_attr_int(online_room_node, online_room, "qualifier_begin");
    apply_attr_int(online_room_node, online_room, "qualifier_period");

    var seriesListNode = online_room_node["online_series"];
    if (seriesListNode != nil)
    {
        seriesListNode = seriesListNode[0];
        var seriesNode = seriesListNode["series"];
        if (seriesNode != nil)
        {
            var num = seriesNode.size;
            online_room.online_series.resize(num);
            for (var i = 0; i < num; ++i)
                parseOnlineSeriesXML(online_room.online_series[i], seriesNode[i]);
        }
    }
    apply_attr_enum(online_room_node, online_room, "series_point_type", gtengine::OnlineSeriesPointType);
    apply_attr_array(online_room_node, online_room, "series_point_table", "point");
    apply_attr_int(online_room_node, online_room, "booby_point");
    apply_attr_int(online_room_node, online_room, "matching_world_offset");
    apply_attr_int(online_room_node, online_room, "freerun_penalty");
    apply_attr_int(online_room_node, online_room, "freerun_collision");

    apply_attr_int(online_room_node, online_room, "shuffle_base");
    apply_attr_int(online_room_node, online_room, "shuffle_ratio");
    apply_attr_enum(online_room_node, online_room, "weather", gtengine::TrackDayWeather);
    apply_attr_int(online_room_node, online_room, "game_region_code");
    apply_attr_int(online_room_node, online_room, "alarm_time");
    apply_attr_int(online_room_node, online_room, "alarm_time_value");
    apply_attr_int(online_room_node, online_room, "club_id");
    apply_attr_int(online_room_node, online_room, "club_event_id");
    apply_attr_uint(online_room_node, online_room, "event_setting_version");
    apply_attr_uint(online_room_node, online_room, "event_setting_hash");
    apply_attr_uint(online_room_node, online_room, "scenery_course_code");
    

    var qcpNode = online_room_node["quality_control_parameter"];
    if (qcpNode != nil)
    {
        qcpNode = qcpNode[0];
        parseQualityControlParameterXML(online_room.quality_control_parameter, qcpNode);
    }
}

function parseGameParameterXML(gp, gp_node)
{

    apply_attr_long(gp_node, gp, "folder_id");


    var events_node = gp_node["events"];
    if (events_node != nil)
    {
        events_node = events_node[0];

        var event_node = events_node["event"];
        
        if (event_node != nil)
        {
            var num = event_node.size;
            gp.events.resize(num);
            for (var i = 0; i < num; i++)
            {
                parseEventXML(gp.events[i], event_node[i]);
            }
        }
    }


    var online_room_node = gp_node["online_room"];
    if (online_room_node != nil)
    {
        parseOnlineRoomXML(gp.online_room, online_room_node[0]);
    }


    var reward_node = gp_node["series_reward"];
    if (reward_node != nil)
    {
        parseRewardXML(gp.series_reward, reward_node[0]);
    }


    var information_node = gp_node["series_information"];
    if (information_node != nil)
    {
        parseInformationXML(gp.series_information, information_node[0]);
    }


    var editor_info_node = gp_node["editor_info"];
    if (editor_info_node != nil)
    {
        editor_info_node = editor_info_node[0];
        var editor_info = gp.editor_info;
        apply_attr_int(editor_info_node, editor_info, "psp_mode");
    }

    apply_attr_int(gp_node, gp, "championship");
    apply_attr_int(gp_node, gp, "arcade");
    
    return true;
}

function parseRewardXML(reward, reward_node)
{
    apply_attr_int_array(reward_node, reward, "prize_table", "prize");
    apply_attr_int_array(reward_node, reward, "point_table", "point");
    apply_attr_enum_array(reward_node, reward, "star_table", "star", gtengine::FinishResult);
    apply_attr_present(reward_node, reward);
    apply_attr_value(reward_node, reward, "special_reward_code");
    apply_attr_value(reward_node, reward, "prize_type");
    apply_attr_value(reward_node, reward, "pp_base");
    apply_attr_value(reward_node, reward, "percent_at_pp100");
    apply_attr_int(reward_node, reward, "is_once");
    apply_attr_enum(reward_node, reward, "present_type", gtengine::RewardPresentType);

    apply_attr_present(reward_node, reward, "entry_present");
    apply_attr_enum(reward_node, reward, "entry_present_type", gtengine::RewardEntryPresentType);
    
    var entry_base_node = reward_node["entry_base"];
    if (entry_base_node != nil)
    {
        apply_attr_entry_base(entry_base_node[0], reward.entry_base);
    }
}

function parseRankingXML(ranking, ranking_node)
{
    apply_attr_enum(ranking_node, ranking, "type", gtengine::RankingType);
    apply_attr_int(ranking_node, ranking, "is_local");
    apply_attr_int(ranking_node, ranking, "replay_rank_limit");
    apply_attr_int(ranking_node, ranking, "display_rank_limit");
    apply_attr_long(ranking_node, ranking, "board_id");
    apply_attr_int(ranking_node, ranking, "registration");
    apply_attr_enum(ranking_node, ranking, "registration_type", gtengine::RegistrationType);
    


    
    var node = ranking_node["begin_date"];
    if (node != nil && node[0] != nil && node[0].value != "")
        ranking.begin_date_str = node[0].value;
    else
        ranking.begin_date_str = "2010/04/02 12:00:00";

    
    var node = ranking_node["end_date"];
    if (node != nil && node[0] != nil && node[0].value != "")
        ranking.end_date_str = node[0].value;
    else
        ranking.end_date_str = "2010/04/02 12:00:00";
}

function parseLocalizeTextXML(localize_text, localize_text_node)
{
    if (localize_text_node == nil)
        return;
    
    localize_text_node = localize_text_node[0];

    foreach (|var langname| in pdistd::Language)
    {
        var lang_node = localize_text_node[langname];
        if (lang_node != nil)
        {
            var lang0 = pdistd::Language[langname];
            localize_text.setText(lang0, lang_node[0].value);
        }
    }
}

function parseInformationXML(information, information_node)
{
    parseLocalizeTextXML(information.title, information_node["title"]);
    parseLocalizeTextXML(information.one_line_title, information_node["one_line_title"]);
    parseLocalizeTextXML(information.description, information_node["description"]);
    parseLocalizeTextXML(information.advanced_notice, information_node["advanced_notice"]);
    parseLocalizeTextXML(information.registration_notice, information_node["registration_notice"]);
    apply_attr_int(information_node, information, "narration_id");
    apply_attr_value(information_node, information, "logo_image_path");
    apply_attr_int(information_node, information, "logo_image_layout");
    apply_attr_bin(information_node, information, "logo_image_buffer");
    apply_attr_value(information_node, information, "logo_other_info");
    apply_attr_value(information_node, information, "flier_image_path");
    apply_attr_bin(information_node, information, "flier_image_buffer");
    apply_attr_value(information_node, information, "flier_other_info");
    apply_attr_value(information_node, information, "race_label");
    apply_attr_uint(information_node, information, "race_info_minute");
}

function parseReplayXML(replay, replay_node)
{
    
    apply_attr_value(replay_node, replay, "local_path");
    apply_attr_value(replay_node, replay, "url");
    apply_attr_value(replay_node, replay, "demo_data_path");
    apply_attr_enum(replay_node, replay, "replay_recording_quality", gtengine::ReplayRecordingQuality);
    apply_attr_int(replay_node, replay, "auto_save");
}

function parseXML(xml_data)
{
    var xml = pdistd::MXml();
    xml.parse(xml_data);
    var dom = xml.result;
    var xml_nodes = dom["xml"];
    var gp_nodes = nil;
    if (xml_nodes != nil)
    {
        if (xml_nodes.size <= 0)
            return [];

        var xml_node = xml_nodes[0];
        gp_nodes = xml_node["GameParameter"];
        if (gp_nodes == nil)
            gp_nodes = xml_node["GamePlan"];
    }
    else
    {
        gp_nodes = dom["GamePlan"];
    }

    if (gp_nodes == nil)
        return [];
    
    var gp_list = Array(gp_nodes.size);
    for (var i = 0; i < gp_nodes.size; i++)
    {
        var gp = gtengine::MGameParameter();
        var gp_node = gp_nodes[i];
        parseGameParameterXML(gp, gp_node);
        gp_list[i] = gp;
    }

    return gp_list;
}

function setup_start_position(gp)
{
    var event = gp.event;
    var rp = event.race_parameter;
    var entry_set = event.entry_set;
    var use_initial_position = 0;
    for (var i = 0; i < entry_set.entries.size; ++i)
    {
        var entry = entry_set.entries[i];
        if (entry.available_initial_position)
        {
            use_initial_position = 2;
            rp.setLaunchPosition(i, entry.initial_position);
        }
        else
        {
            rp.setLaunchPosition(i, 0);
        }

        if (entry.initial_velocity > 0)
        {
            rp.setLaunchSpeed(i, entry.initial_velocity);
        }
        else
        {
            rp.setLaunchSpeed(i, 0);
        }
        rp.setDelayStartSecond(i, entry.delay);
        rp.setStartTypeSlot(i, entry.start_type);
    }

    if (!use_initial_position && entry_set.entry_generate.use_rolling_start_param)
    {
        use_initial_position = 1;
        rp.setLaunchPosition(0, entry_set.entry_generate.rolling_start_v);
        rp.setLaunchPosition(1, entry_set.entry_generate.gap_for_start_rolling_distance);
    }

    if (rp.start_type == gtengine::StartType::ROLLING2)
        rp.rolling_player_grid = entry_set.entry_generate.player_pos;

    rp.useLaunchData(use_initial_position);
}

function createBspecDriver(dp)
{
    var dpB = gtengine::MCarDriverParameter();
    dpB.deepCopy(dp);
    dpB.setGroveAIParameter("max_ai");

    ABspecUtil::getBSpecPlayerSkill(dpB, 40);


    dpB.disable_bspec_skill = false;
    return dpB;
}

function execute_common(context, gp, game_status, driving_option_cb, player_num)
{
    var user_profile = game_status.user_profile;
    var residence = user_profile.residence;
    var player_cp_list = [];
    var player_dp_list = [];
    if (player_num == nil)
        player_num = 1;
    var entry_set = gp.event.entry_set;
    var entry_generate = entry_set.entry_generate;



    residence.refreshPlayerName();


    if (gp.event.game_mode == gtengine::GameMode::SPLIT_BATTLE ||
        gp.event.game_mode == gtengine::GameMode::SPLIT_ONLINE_BATTLE ||
        gp.event.game_mode == gtengine::GameMode::DRAG_RACE)
    {
        player_num = 2;
    }
    for (var i = 0; i < player_num; i++)
    {
        var player_no = i;
        var has_entry = false;


        if (entry_set.entries.size > 0)
        {
            for (var ii = 0; ii < entry_set.entries.size; ii++)
            {
                var entry = entry_set.entries[ii];


                var cp;
                if (!entry.car_parameter.isVacant())
                    cp = entry.car_parameter;
                else if (entry.car.code != gtengine::MSpecDB::NO_CODE)
                    cp = gtengine::MCarParameter(entry.car);
                else if (entry.entry_base.car.code != gtengine::MSpecDB::NO_CODE)
                {
                    if (entry.entry_base.car.code == "GARAGE_CAR")
                    {
                        cp = user_profile.garage.getRidingCar();
                    }
                    else
                    {
                        cp = LaunchRaceUtil::makeCarParameterFromEntryBase(entry.entry_base);
                    }
                }
                var dp = entry.driver_parameter;
                if (cp == nil || dp == nil)
                    break;
                

                if (entry.player_no == player_no)
                {
                    if (dp.isVacant())
                    {
                        if (gp.arcade)
                            dp = residence.getArcadePlayer(player_no);
                        else
                            dp = residence.getPlayer();
                    }
                }
                var tmp_cp = cp;
                var tmp_dp = dp;

                if (gp.launch_context == gtengine::LaunchContext::ACADEMY)
                {

                    tmp_dp.head_code = 85;
                    tmp_dp.body_code = 85;
                    tmp_dp.head_color_code = 0;
                    tmp_dp.body_color_code = 0;
                }


                if (entry.entry_base.head_code >= 0) tmp_dp.head_code = entry.entry_base.head_code;
                if (entry.entry_base.body_code >= 0) tmp_dp.body_code = entry.entry_base.body_code;
                if (entry.entry_base.head_color_code >= 0) tmp_dp.head_color_code = entry.entry_base.head_color_code;
                if (entry.entry_base.body_color_code >= 0) tmp_dp.body_color_code = entry.entry_base.body_color_code;

                |cp, dp| = gp.event.constraint.apply(tmp_cp, tmp_dp);

                if (entry.player_no == player_no)
                {
                    if (driving_option_cb != nil)
                    {
                        user_profile.context.saved_driving_option[i].setTo(tmp_cp, tmp_dp);
                        var result = driving_option_cb(context, gp, cp, dp, player_no);
                        if (!result)
                            return false;
                    }
                    has_entry = true;
                }

                if (!entry.no_suitable_tire)
                {
                    var rp = gp.event.race_parameter;
                    cp.setSuitableTires(gp.event.track.course_code, rp.isRainTireRecommended());
                }
                entry.car_parameter = cp;


                if (entry.player_no == player_no)
                {

                    var dpB = createBspecDriver(dp);
                    entry.driver_parameter_list = [dp, dpB];
                }
                has_entry = true;
            }   
        }

        if (!has_entry)
        {

            var tmp_cp;
            if (gp.event.constraint.cars.size == 1)
            {
                tmp_cp = gtengine::MCarParameter(gp.event.constraint.cars[0]);
            }
            else if (gp.arcade)
                tmp_cp = user_profile.context.getArcadeCar(i);
            else 
                tmp_cp = user_profile.garage.getRidingCar();
            
            if (tmp_cp == nil)
            {
                // No suitable car found to use for the event
                return false;
            }
            var tmp_dp = gp.arcade ? residence.getArcadePlayer(player_no) : residence.getPlayer();

            if (gp.launch_context == gtengine::LaunchContext::ACADEMY)
            {

                tmp_dp.head_code = 74;
                tmp_dp.body_code = 74;
                tmp_dp.head_color_code = 0;
                tmp_dp.body_color_code = 0;
            }

            |cp, dp| = gp.event.constraint.apply(tmp_cp, tmp_dp);



            var rp = gp.event.race_parameter;
            cp.setSuitableTiresWithTrunk(gp.event.track.course_code, rp.isRainTireRecommended());
            if (!cp.rentacar)
                game_status.user_profile.garage.updateCar(cp);


            if (driving_option_cb != nil)
            {
                user_profile.context.saved_driving_option[i].setTo(tmp_cp, tmp_dp);
                var result = driving_option_cb(context, gp, cp, dp, player_no);
                if (!result)
                    return false;
            }

            player_cp_list.push(cp);
            player_dp_list.push(dp);
        }
    }

    var bspec_dp_list;
    if (player_dp_list.size > 0)
    {
        var dp = createBspecDriver(player_dp_list[0]);
        bspec_dp_list = [dp];
    }
    else
    {
        bspec_dp_list = [];
    }
    setup_start_position(gp);

    execute(context, gp, player_cp_list, player_dp_list, bspec_dp_list);
    return true;
}

function executeEvent(context, gp, game_status, driving_option_cb)
{
    gp.arcade = false;
    execute_common(context, gp, game_status, driving_option_cb);
}

function executeArcade(context, gp, game_status, driving_option_cb)
{
    gp.arcade = true;
    gp.event.play_style.time_limit = game_status.user_profile.option.arcade_time_limit;
    return execute_common(context, gp, game_status, driving_option_cb);
}

function executeAutoDemo(context, gp, game_status)
{
    gp.arcade = false;
    execute_common(context, gp, game_status, nil, 0);
}


function executeEventFile(context, path, overwriting_event_id)
{
    if (pdistd::Exist(path))
    {
        var fst = pdistd::ReadFile(path);
        var buf = fst["buffer"];
        if (buf != nil)
        {
            var gp_list = GameParameterUtil::parseXML(buf);
            var gp = gp_list[0];
            if (overwriting_event_id != nil)
                gp.event_id = overwriting_event_id;
            executeEvent(context, gp, GAME_STATUS);
            return true;
        }
    }
    return false;
}


function createFromFile(path)
{
    // Try cached game parameter first
    var GP_CACHE_DIR = "/game_parameter/gp_cache/";
    var fgp = path + ".fgp";
    var st = pdistd::ReadFile(fgp);
    var gp_cache_path = nil;
    if (st["result"] == 0)
    {
        var buf = st["buffer"];
        gp_cache_path = GP_CACHE_DIR + buf.toString().chop();
        st = pdistd::ReadFile(gp_cache_path);
        if (st["result"] == 0)
        {
            var gp = gtengine::MGameParameter();
            gp.deserialize(st["buffer"]);
            return gp;
        }
    }
    // Read directly
    var file = pdistd::ReadFile(path);
    if (file["buffer"] == nil)
        return nil;

    var gp_list = GameParameterUtil::parseXML(file["buffer"]);
    if (gp_list.size == 0)
        return nil;

    var gp = gp_list[0];
    return gp;
}

function create_cache(path)
{
    var GP_CACHE_DIR = "/app_home/game_parameter/gp_cache/";
    var dirname = IO::Path::GetDirName(path);
    var fname = IO::Path::GetBaseName(path);
    var fgp = dirname + "/%{fname}.fgp";
    var st = pdistd::ReadFile(fgp);
    var gp_cache_path = nil;
    if (st["result"] == 0)
    {
        var buf = st["buffer"];
        gp_cache_path = GP_CACHE_DIR + buf.toString().chop();
    }
    else return;

    var file = pdistd::ReadFile(path);
    if (file["buffer"] == nil)
        return;
    
    var gp_list = GameParameterUtil::parseXML(file["buffer"]);
    if (gp_list.size == 0)
        return;
    
    var gp = gp_list[0];
    if (gp_cache_path != nil)
    {


        // Limit buffer size to 1MB
        var size = 1 * 1024 * 1024;
        var buf = ByteData(0, size);
        if (buf != nil)
        {
            var res = gp.serialize(buf);
            if (res < size)
            {
                buf.resize(res);
                pdistd::WriteFile(gp_cache_path, buf);
            }
            else
                ;
        }
    }
}

function createCacheForRelease(dir)
{
    var entries = pdistd::GetFileEntries(dir);
    if (entries == nil)
        return;
    foreach (var entry in entries)
    {
        var file = entry["name"];
        if (file == ".")
            continue;
        if (file == "..")
            continue;
        if (file == ".work")
            continue;
        
        var path = dir + "/" + file;
        if (entry["type"] == "DIRECTORY")
            createCacheForRelease(path);
        else if (!file.endsWith(".xml"))
            continue;

        create_cache(path);
    }
}

/***************************************/
/***************************************/
/*             TEMPLATES               */
/***************************************/
/***************************************/

function createSingleRace(course_code, entry_num, arcade_laps, ai_skill, enemy_lv, boost_lv, penalty_level, prize_table, one_make)
{
    var gp = gtengine::MGameParameter();
    var course_max_entry = gtengine::MSpecDB::getCourseMaxEntry(course_code);
    if (entry_num > course_max_entry)
        entry_num = course_max_entry;


    var event = gp.event;

    event.game_mode = gtengine::GameMode::SINGLE_RACE;
    
    var play_style = event.play_style;
    play_style.play_type = gtengine::PlayType::RACE;
    play_style.replay_record_enable = true;


    var entry_set = event.entry_set;
    var entry_generate = entry_set.entry_generate;
    entry_generate.entry_num = entry_num;
    entry_generate.player_pos = (entry_num - 1) / 2;
    if (ai_skill != nil)
        entry_generate.ai_skill = ai_skill;
    if (enemy_lv != nil)
        entry_generate.enemy_lv = enemy_lv;
    if (one_make != nil && one_make)
        entry_generate.generate_type = gtengine::GenerateType::ONE_MAKE;
    else
        entry_generate.generate_type = gtengine::GenerateType::ENEMY_LIST;

    
    var limit_minimum_entries = GetVersionBranch() != "runviewer" || RaceOperator.expand_memory;


    var entry_max = 16;
    if (limit_minimum_entries)
        entry_max = entry_num;
    if (entry_max > course_max_entry)
        entry_max = course_max_entry;
    
    var track = event.track;
    track.course_code = course_code;


    var rp = event.race_parameter;
    rp.race_type = gtengine::RaceType::COMPETITION;
    rp.start_type = gtengine::StartType::GRID;
    
    rp.complete_type = gtengine::CompleteType::BYLAPS;
    rp.finish_type = gtengine::FinishType::TARGET;
    rp.time_to_finish = 30000;
    rp.race_limit_laps = arcade_laps;
    rp.enable_pit = false;
    rp.entry_max = entry_max;
    rp.racers_max = entry_max;
    rp.penalty_level = penalty_level;

    if (boost_lv != nil)
        rp.boost_level = boost_lv;
    rp.line_ghost_play_max = 0;
    rp.line_ghost_record_type = gtengine::LineGhostRecordType::OFF;
    rp.enable_damage = GAME_STATUS.user_profile.option.arcade_enable_damage;

    if (GetVersionBranch() == "runviewer" && arcade_laps < 0)
    {
        rp.race_limit_minute = -arcade_laps;
        rp.complete_type = gtengine::CompleteType::BYTIME;
        rp.immediate_finish = false;
    }

    var reward = event.reward;
    reward.prize_table = prize_table;
    var information = event.information;

    return gp;
}


function createSingleRaceRacingKart(course_code, entry_num, arcade_laps, ai_skill, enemy_lv, boost_lv, penalty_level, prize_table, one_make)
{
    var gp = createSingleRace(course_code, entry_num, arcade_laps, ai_skill, enemy_lv, boost_lv, penalty_level, prize_table, one_make);
    return gp;
}


function createOnlineSingleRace(course_code, entry_num, arcade_laps, ai_skill, enemy_lv, boost_lv, penalty_level, prize_table, one_make)
{
    var gp = createSingleRace(course_code, entry_num, arcade_laps, ai_skill, enemy_lv, boost_lv, penalty_level, prize_table, one_make);
    var event = gp.events[0];
    event.game_mode = gtengine::GameMode::ONLINE_SINGLE_RACE;
    return gp;
}


function createAutoDemo(course_code, entry_num, laps, one_make)
{
    var gp = gtengine::MGameParameter();
    var course_max_entry = gtengine::MSpecDB::getCourseMaxEntry(course_code);
    if (entry_num > course_max_entry)
        entry_num = course_max_entry;


    var event = gp.event;

    event.game_mode = gtengine::GameMode::SINGLE_RACE;
    
    var play_style = event.play_style;
    play_style.play_type = gtengine::PlayType::DEMO;
    play_style.no_quickmenu = true;
    play_style.replay_record_enable = false;
    if (GetVersionBranch() == "runviewer")
    {
        if (laps == nil)
            play_style.time_limit = 30;
    }

    var entry_set = event.entry_set;
    var entry_generate = entry_set.entry_generate;

    entry_generate.entry_num = entry_num;
    entry_generate.player_pos = 0;
    entry_generate.ai_skill = 100;
    entry_generate.enemy_lv = 0;

    if (one_make != nil && one_make)
        entry_generate.generate_type = gtengine::GenerateType::ONE_MAKE;
    else
        entry_generate.generate_type = gtengine::GenerateType::SPEC_DB;

    
    var limit_minimum_entries = GetVersionBranch() != "runviewer" || RaceOperator.expand_memory;


    var entry_max = 16;
    if (limit_minimum_entries)
        entry_max = entry_num;
    if (entry_max > course_max_entry)
        entry_max = course_max_entry;
    
    var track = event.track;
    track.course_code = course_code;

    var rp = event.race_parameter;
    rp.race_type = gtengine::RaceType::COMPETITION;
    rp.start_type = gtengine::StartType::ROLLING;
    rp.complete_type = gtengine::CompleteType::BYLAPS;
    rp.finish_type = gtengine::FinishType::TARGET;
    if (laps != nil)
        rp.race_limit_laps = laps;
    else
        rp.race_limit_laps = 0;

    rp.entry_max = entry_max;
    rp.racers_max = entry_max;
    rp.line_ghost_play_max = 0;
    rp.line_ghost_record_type = gtengine::LineGhostRecordType::OFF;
    rp.enable_damage = false;

    rp.enable_pit = false;

    return gp;
}


function createTimeAttack(course_code)
{
    var gp = gtengine::MGameParameter();

    var event = gp.events[0];

    event.game_mode = gtengine::GameMode::TIME_ATTACK;
    
    var play_style = event.play_style;
    play_style.play_type = gtengine::PlayType::RACE;
    play_style.no_quickmenu = false;
    play_style.replay_record_enable = true;

    var entry_set = event.entry_set;

    entry_set.entries.resize(1);
    var entry = entry_set.entries[0];
    entry.player_no = 0;

    var rp = event.race_parameter;
    rp.race_type = gtengine::RaceType::TIMEATTACK;
    rp.start_type = gtengine::StartType::ATTACK;
    rp.complete_type = gtengine::CompleteType::NONE;
    rp.ghost_type = gtengine::GhostType::ONELAP;
    
    rp.penalty_level = -1;
    rp.entry_max = 1;
    rp.racers_max = 1;
    rp.line_ghost_play_max = 10;
    rp.line_ghost_record_type = gtengine::LineGhostRecordType::ONE;
    rp.enable_damage = GAME_STATUS.user_profile.option.arcade_enable_damage;

    var track = event.track;
    track.course_code = course_code;

    return gp;
}

function createArcadeStyleRace(course_code)
{
    var gp = gtengine::MGameParameter();

    var nb_entries = 10;

    var event = gp.events[0];

    event.game_mode = gtengine::GameMode::ARCADE_STYLE_RACE;
    
    var play_style = event.play_style;
    play_style.play_type = gtengine::PlayType::RACE;
    play_style.no_quickmenu = false;
    play_style.replay_record_enable = true;

    var entry_set = event.entry_set;

    entry_set.entries.resize(nb_entries);

    var entry_generate = entry_set.entry_generate;
    entry_generate.entry_num = nb_entries;
    entry_generate.player_pos = 0;
    entry_generate.ai_skill = 10;
    entry_generate.enemy_lv = 0;

    entry_generate.generate_type = gtengine::GenerateType::SPEC_DB;

    var rp = event.race_parameter;
    rp.race_type = gtengine::RaceType::TIMEATTACK;

    rp.start_type = gtengine::StartType::PIT;

    rp.complete_type = gtengine::CompleteType::BYLAPS;
    rp.finish_type = gtengine::FinishType::TARGET;
    rp.race_limit_laps = 1;
    rp.race_initial_laps = 0;
    rp.ghost_type = gtengine::GhostType::NONE;

    rp.penalty_level = gtengine::PenaltyLevelTypes::OFF;
    rp.entry_max = nb_entries;
    rp.racers_max = nb_entries;
    rp.line_ghost_play_max = 10;
    rp.line_ghost_record_type = gtengine::LineGhostRecordType::ONE;
    rp.enable_damage = false;
    rp.behavior_damage_type = gtengine::BehaviorDamageType::WEAK;

    var track = event.track;
    track.course_code = course_code;

    return gp;
}

function createFreeRun(course_code)
{
    var gp = gtengine::MGameParameter();

    var event = gp.events[0];

    event.game_mode = gtengine::GameMode::FREE_RUN;
    
    var play_style = event.play_style;
    play_style.play_type = gtengine::PlayType::RACE;
    play_style.no_quickmenu = false;

    var entry_set = event.entry_set;

    entry_set.entries.resize(1);
    var entry = entry_set.entries[0];
    entry.player_no = 0;
 
    var rp = event.race_parameter;
    rp.race_type = gtengine::RaceType::TIMEATTACK;
    rp.start_type = gtengine::StartType::ATTACK;
    rp.complete_type = gtengine::CompleteType::NONE;
    rp.ghost_type = gtengine::GhostType::ONELAP;

    rp.penalty_level = 0;
    rp.entry_max = 1;
    rp.racers_max = 1;
    rp.enable_damage = true;

    var track = event.track;
    track.course_code = course_code;

    return gp;
}

function createGpsReplay(course_code)
{
    var gp = gtengine::MGameParameter();

    var event = gp.events[0];

    event.game_mode = gtengine::GameMode::GPS_REPLAY;
    
    var play_style = event.play_style;
    play_style.play_type = gtengine::PlayType::RACE;
    play_style.no_quickmenu = false;
    play_style.replay_record_enable = true;

    var entry_set = event.entry_set;

    entry_set.entries.resize(1);
    var entry = entry_set.entries[0];
    entry.player_no = 0;
 
    var rp = event.race_parameter;
    rp.race_type = gtengine::RaceType::TIMEATTACK;
    rp.start_type = gtengine::StartType::ATTACK;
    rp.complete_type = gtengine::CompleteType::NONE;
    rp.ghost_type = gtengine::GhostType::ONELAP;

    rp.penalty_level = -1;
    rp.entry_max = 1;
    rp.racers_max = 1;
    rp.line_ghost_play_max = 10;
    rp.line_ghost_record_type = gtengine::LineGhostRecordType::ONE;
    rp.enable_damage = GAME_STATUS.user_profile.option.arcade_enable_damage;
    
    var track = event.track;
    track.course_code = course_code;

    return gp;
}

function createOnlineTimeAttack(course_code)
{
    var gp = createTimeAttack(course_code);
    var event = gp.event;
    event.game_mode = gtengine::GameMode::ONLINE_TIME_ATTACK;
    event.begin_date_str = "1999/04/01 00:00:00";
    event.end_date_str = "2999/04/01 00:00:00";
    var ranking = event.ranking;
    ranking.begin_date_str = "1999/04/01 00:00:00";
    ranking.end_date_str = "2999/04/01 00:00:00";
    ranking.is_local = false;
    ranking.board_id = 2000199;
    ranking.replay_rank_limit = 100;
    var rp = event.race_parameter;
    rp.line_ghost_play_max = 10;
    rp.line_ghost_record_type = gtengine::LineGhostRecordType::ONE;
    rp.enable_damage = true;
    return gp;
}

function createDriftAttack(course_code, layout, endless)
{
    var gp = gtengine::MGameParameter();
    var event = gp.events[0];
	
    event.game_mode = gtengine::GameMode::DRIFT_ATTACK;
    var play_style = event.play_style;
    play_style.play_type = gtengine::PlayType::RACE;
    play_style.no_quickmenu = false;
    play_style.replay_record_enable = true;

    var entry_set = event.entry_set;

    var rp = event.race_parameter;
    var num = 1;

    entry_set.entries.resize(1);
    var entry = entry_set.entries[0];
    entry.player_no = 0;

    rp.race_type = gtengine::RaceType::DRIFTATTACK;
    if (endless)
        rp.start_type = gtengine::StartType::ATTACK;
    else
        rp.start_type = num > 1 ? gtengine::StartType::COURSEINFO : gtengine::StartType::COURSEINFO_ROLLING;

    rp.entry_max = num;
    rp.racers_max = num;
    rp.complete_type = gtengine::CompleteType::NONE;
    rp.ghost_type = gtengine::GhostType::NONE;
    rp.endless = endless;
    rp.time_to_start = 1900;
    rp.time_to_finish = 2000;
    rp.line_ghost_play_max = 0;
    rp.line_ghost_record_type = gtengine::LineGhostRecordType::OFF;
    rp.enable_damage = GAME_STATUS.user_profile.option.arcade_enable_damage;

    event.constraint.simulation = 1;

    var track = event.track;
    track.course_code = course_code;
    if (layout != nil)
        track.course_layout_no = layout;

    return gp;
}

function createOnlineDriftAttack(course_code, layout, endless)
{

    var gp = createDriftAttack(course_code, layout, endless);
    var event = gp.events[0];
    event.game_mode = gtengine::GameMode::ONLINE_DRIFT_ATTACK;
    return gp;
}

function createDragRace(course_code)
{
    var gp = gtengine::MGameParameter();

    var event = gp.events[0];

    event.game_mode = gtengine::GameMode::DRAG_RACE;
    
    var play_style = event.play_style;
    play_style.play_type = gtengine::PlayType::RACE;
    play_style.no_quickmenu = false;
    play_style.replay_record_enable = true;

    var entry_set = event.entry_set;

    var num = 2;
    entry_set.entries.resize(num);
    var entry0 = entry_set.entries[0];
    entry0.player_no = 0;
    for (var i = 1; i < num; i++)
    {
        var entry = entry_set.entries[i];
        entry.car_parameter.deepCopy(entry0.car_parameter);
        var dp = gtengine::MCarDriverParameter();
        dp.display_name = "SubDriver%{i}";
        dp.setPlayer(i);
        entry.driver_parameter = dp;
        entry.player_no = i;
    }

    var rp = event.race_parameter;
    rp.race_type = gtengine::RaceType::TIMEATTACK;
    rp.start_type = gtengine::StartType::GRID;
    rp.complete_type = gtengine::CompleteType::NONE;
    rp.ghost_type = gtengine::GhostType::NONE;
    rp.entry_max = 8;
    rp.racers_max = 8;
    rp.time_to_finish = 3000;
    rp.line_ghost_play_max = 0;
    rp.line_ghost_record_type = gtengine::LineGhostRecordType::OFF;
    rp.enable_damage = GAME_STATUS.user_profile.option.arcade_enable_damage;

    event.constraint.simulation = 1;
    event.constraint.tcs = 0;
    event.constraint.asm = 0;


    var track = event.track;
    track.course_code = course_code;

    return gp;
}

function createReplayWithPath(path, data_logger)
{
    var buf = ORG.getReplayHeaderFromPath(path);
    if (buf == nil)
    {

        return nil;
    }

    var info = gtengine::MReplayInfo();

    var success = info.initialize(buf);
    if (!success)
    {
        return nil;
    }


    var result = info.checkVersion();
    if (result != gtengine::VersionCheckResult::OK)
    {
        return nil;
    }

    var gp = gtengine::MGameParameter();
    if (gp != nil)
    {

        gp.event.replay.local_path = path;
        if (data_logger != nil)
            gp.event.replay.data_logger = data_logger;
    }

    return gp;
}

function createLicense(course_code)
{
    var gp = gtengine::MGameParameter();

    var event = gp.event;
    event.game_mode = gtengine::GameMode::LICENSE;
    
    var play_style = event.play_style;
    play_style.play_type = gtengine::PlayType::RACE;
    play_style.replay_record_enable = true;

    var entry_set = event.entry_set;

    entry_set.entries.resize(1);
    var entry = entry_set.entries[0];
    entry.player_no = 0;
 

    var rp = event.race_parameter;
    rp.race_type = gtengine::RaceType::COMPETITION;
    rp.start_type = gtengine::StartType::STANDING;
    rp.complete_type = gtengine::CompleteType::NONE;
    rp.finish_type = gtengine::FinishType::TARGET;
    rp.race_limit_laps = 0;
    rp.racers_max = 1;
    rp.line_ghost_play_max = 10;
    rp.line_ghost_record_type = gtengine::LineGhostRecordType::ONE;
    rp.enable_damage = true;
    
    var track = event.track;
    track.course_code = course_code;

    var eval_condition = event.eval_condition;
    eval_condition.type = gtengine::EvalType::TIME;
    eval_condition.gold = 59000;
    eval_condition.silver = 59000;
    eval_condition.bronze = 59000;

    return gp;
}

function createSplitBattle(course, cp_list, dp_list)
{

    var num = cp_list.size;

    var gp = gtengine::MGameParameter();
    var event = gp.event;
    event.game_mode = gtengine::GameMode::SPLIT_BATTLE;
    
    var play_style = event.play_style;
    play_style.play_type = gtengine::PlayType::RACE;
    play_style.no_quickmenu = true;
    play_style.replay_record_enable = true;

    var rp = event.race_parameter;
    rp.setDefault();
    rp.entry_max = num;
    rp.racers_max = num;
    rp.race_type = gtengine::RaceType::COMPETITION;
    rp.start_type = gtengine::StartType::GRID;
    rp.complete_type = gtengine::CompleteType::BYLAPS;
    rp.finish_type = gtengine::FinishType::TARGET;
    rp.race_limit_laps = GAME_STATUS.user_profile.option.arcade_laps;
    rp.line_ghost_play_max = 0;
    rp.line_ghost_record_type = gtengine::LineGhostRecordType::OFF;
    rp.enable_damage = GAME_STATUS.user_profile.option.arcade_enable_damage;
    
    var track = event.track;
    track.course_code = course;

    var entry_set = event.entry_set;
    entry_set.entries.resize(num);

    for (var i = 0; i < num; i++)
    {
        var entry = entry_set.entries[i];
        entry.player_no = i;
        entry.car_parameter = cp_list[i];
        entry.driver_parameter = dp_list[i];
    }
    return gp;
}

function createSplitOnlineBattle(course, cp_list, dp_list)
{

    var num = cp_list.size;

    var gp = gtengine::MGameParameter();
    var event = gp.event;
    event.game_mode = gtengine::GameMode::SPLIT_ONLINE_BATTLE;
    
    var play_style = event.play_style;
    play_style.play_type = gtengine::PlayType::RACE;
    play_style.replay_record_enable = true;

    var rp = event.race_parameter;
    rp.setDefault();
    rp.entry_max = 12;
    rp.racers_max = 12;
    rp.race_type = gtengine::RaceType::COMPETITION;

    rp.complete_type = gtengine::CompleteType::BYLAPS;
    rp.finish_type = gtengine::FinishType::TARGET;

    rp.time_to_finish = 20000;
    rp.immediate_finish = false;
    rp.online_on = true;
    rp.line_ghost_play_max = 0;
    rp.line_ghost_record_type = gtengine::LineGhostRecordType::OFF;
    rp.enable_damage = GAME_STATUS.user_profile.option.arcade_enable_damage;
    
    var track = event.track;
    track.course_code = course;

    var entry_set = event.entry_set;
    entry_set.entries.resize(num);

    for (var i = 0; i < num; i++)
    {
        var entry = entry_set.entries[i];
        entry.player_no = i;
        entry.car_parameter = cp_list[i];
        entry.driver_parameter = dp_list[i];
    }
    return gp;
}

function createOnlineBattle(course_code, room_type)
{
    var gp = gtengine::MGameParameter();
    var online_room = gp.online_room;
    online_room.room_type = room_type;
    online_room.room_game_mode = gtengine::RoomGameMode::RACE;
    online_room.trackday_mode = gtengine::TrackDayMode::RACE;
    online_room.room_max = 16;

    online_room.is_autocratic = room_type == gtengine::RoomType::OPEN_MATCH ||
        room_type == gtengine::RoomType::CLUB_LOBBY ||
        room_type == gtengine::RoomType::CLUB_EVENT;
    
    online_room.auto_grant_ownership = !OnlineUtility.isInsideOfControversialNetwork();
    online_room.is_only_garage_car = false;
    online_room.is_only_rental_car = false;
    online_room.game_region_code = gtengine::MGameParameter::GetOwnGameRegionCode();
    online_room.voice_chat = false;
    online_room.event_setting_version = EventSettingUtil::GetCurrentEventSettingVersion();

    var isClubRoom = room_type == gtengine::RoomType::CLUB_LOBBY 
        || room_type == gtengine::RoomType::CLUB_EVENT;
    online_room.room_policy = isClubRoom ? gtengine::RoomPolicy::NONE : gtengine::RoomPolicy::ENJOY_RACE;
    online_room.scope = isClubRoom ? gtengine::Scope::CLUB : gtengine::Scope::PUBLIC;



    var event = gp.event;
    event.play_style.play_type = gtengine::PlayType::RACE;
    event.play_style.bspec_type = gtengine::BSpecType::ONLY_A;
    event.play_style.replay_record_enable = true;
    event.game_mode = gtengine::GameMode::ONLINE_ROOM;
    var track = event.track;

    var invalid = gtengine::MGameParameter::INVALID_VALUE_INT;
    var regulation = event.regulation;
    regulation.limit_pp = invalid;
    regulation.limit_tire_f = invalid;
    regulation.need_tire_f = invalid;
    var constraint = event.constraint;
    constraint.simulation = invalid;
    constraint.driving_line = invalid;
    constraint.active_steering = invalid;
    constraint.drift_type = invalid;
    constraint.enemy_tire = invalid;
    constraint.tcs = invalid;
    constraint.asm = invalid;
    constraint.limit_tire_f = invalid;
    constraint.need_tire_f = invalid;
    var rp = event.race_parameter;
    rp.start_type = gtengine::StartType::GRID_FLYING;
    rp.finish_type = gtengine::FinishType::FASTEST;
    rp.grid_sort_type = gtengine::GridSortType::FASTEST_UP;
    rp.time_to_start = 7000;
    rp.time_to_finish = 30000;
    rp.immediate_finish = false;

    rp.race_limit_laps = 2;

    rp.online_on = true;
    rp.racers_max = 16;
    rp.enable_pit = true;
    rp.penalty_level = gtengine::PenaltyLevelTypes::OFF;
    rp.boost_level = 2;
    rp.weather_random = false;
    rp.weather_random_seed = pdistd::MRandom().getMTInt();
    rp.initial_retention10 = 0;
    var consumption = gtengine::RaceChangeConditionType::CONDITION_NOCHANGE;
    rp.consume_tire = consumption;
    rp.consume_fuel = consumption;

    rp.temperature_tire = consumption;
    rp.accumulation = consumption;
    rp.behavior_damage_type = gtengine::BehaviorDamageType::WEAK;
    rp.line_ghost_play_max = 10;

    rp.line_ghost_record_type = gtengine::LineGhostRecordType::OFF;
    rp.enable_damage = GAME_STATUS.user_profile.option.arcade_enable_damage;

    var time = pdistd::MTime();

    var info = nil;
    if (course_code != nil)
    {
        track.course_code = course_code;
        rp.course_code = course_code;
        if (course_code != gtengine::MSpecDB::NO_CODE)
        {
            info = SPECDB.query1("SELECT ChangeTime, ChangeWeather, StartDateTime, WeatherValue"
                          " FROM COURSE WHERE ID=?", [course_code]);
        }
    }

    if (info != nil)
    {
        var minutes = (info.StartDateTime % (24 * 3600)) / 60;
        time.setTimeFromMinutes(minutes);
        if (info.ChangeTime)
            rp.time_progress_speed = 3.0;
        else
            rp.time_progress_speed = 0.0;


        rp.weather_value0 = info.WeatherValue;
        rp.initial_retention10 = 0;
    }
    else
    {
        time.hour = 12;
        rp.time_progress_speed = 0.0;
        online_room.weather = gtengine::TrackDayWeather::NONE;
    }

    rp.datetime = time;
    return gp;
}

function createSchool()
{
    var gp = gtengine::MGameParameter();
    gp.events.resize(2);

    var event = gp.event;

    event.game_mode = gtengine::GameMode::SCHOOL;
    
    var play_style = event.play_style;
    play_style.play_type = gtengine::PlayType::RACE;
    play_style.replay_record_enable = true;


    var entry_set = event.entry_set;
    var entry_generate = entry_set.entry_generate;
    entry_generate.generate_type = gtengine::GenerateType::NONE;
    entry_set.entries.resize(2);

    var entry = entry_set.entries[0];
    entry.car_parameter = gtengine::MCarParameter("gtr_07");
    entry.car_parameter.color = 1;
    var dp = gtengine::MCarDriverParameter();
    dp.setGroveAIParameter("max_ai");
    dp.display_name = "[Sebastian Vettel]";
    dp.special_ai_type = gtengine::SpecialAIType::LEADING;
    entry.driver_parameter = dp;


    entry = entry_set.entries[1];
    entry.player_no = 0;
    entry.car_parameter = gtengine::MCarParameter("gtr_07");

    var entry_num = 2;


    var rp = event.race_parameter;
    rp.race_type = gtengine::RaceType::COMPETITION;
    rp.start_type = gtengine::StartType::PIT;
    rp.complete_type = gtengine::CompleteType::BYLAPS;
    rp.finish_type = gtengine::FinishType::TARGET;
    rp.race_limit_laps = 1;
    rp.entry_max = entry_num;
    rp.racers_max = entry_num;
    rp.penalty_level = gtengine::PenaltyLevelTypes::OFF;
    rp.ghost_type = gtengine::GhostType::FULL;
    rp.autostart_pitout = false;
    rp.line_ghost_play_max = 0;
    rp.line_ghost_record_type = gtengine::LineGhostRecordType::OFF;
    rp.enable_damage = true;
    
    var track = event.track;
    track.course_code = gtengine::MSpecDB::getCourseCode("indianapolis_f1");

    event = gp.events[1];

    rp = event.race_parameter;
    rp.race_type = gtengine::RaceType::COMPETITION;
    rp.start_type = gtengine::StartType::GRID;
    rp.complete_type = gtengine::CompleteType::BYLAPS;
    rp.finish_type = gtengine::FinishType::TARGET;
    rp.race_limit_laps = 1;
    rp.penalty_level = gtengine::PenaltyLevelTypes::OFF;

    return gp;
}

function createArena(course_code, cp_list, dp_list, arcade_laps)
{
    var gp = gtengine::MGameParameter();

    var event = gp.event;

    event.game_mode = gtengine::GameMode::ARENA;
    
    var play_style = event.play_style;
    play_style.play_type = gtengine::PlayType::RACE;
    play_style.replay_record_enable = true;


    var entry_max = cp_list.size < dp_list.size ? cp_list.size : dp_list.size;
    var course_max_entry = gtengine::MSpecDB::getCourseMaxEntry(course_code);
    if (entry_max > course_max_entry)
        entry_max = course_max_entry;

    
    var entry_set = event.entry_set;
    entry_set.entries.resize(entry_max);
    for (var i = 0; i < entry_max; i++)
    {
        var entry = entry_set.entries[i];
        entry.car_parameter = cp_list[i];
        entry.driver_parameter = dp_list[i];
    }

    var track = event.track;
    track.course_code = course_code;

    var rp = event.race_parameter;
    rp.race_type = gtengine::RaceType::COMPETITION;
    rp.start_type = gtengine::StartType::GRID;
    rp.complete_type = gtengine::CompleteType::BYLAPS;
    rp.finish_type = gtengine::FinishType::FASTEST;
    rp.race_limit_laps = arcade_laps;
    rp.entry_max = entry_max;
    rp.racers_max = entry_max;
    rp.penalty_level = gtengine::PenaltyLevelTypes::OFF;
    rp.grid_sort_type = gtengine::GridSortType::RANDOM;
    rp.line_ghost_play_max = 0;
    rp.line_ghost_record_type = gtengine::LineGhostRecordType::OFF;
    rp.enable_damage = true;

    return gp;
}

function setListForArena(gp, cp_list, dp_list)
{

    var event = gp.event;


    var track = event.track;


    var entry_max = cp_list.size < dp_list.size ? cp_list.size : dp_list.size;
    var course_max_entry = gtengine::MSpecDB::getCourseMaxEntry(track.course_code);
    if (entry_max > course_max_entry)
        entry_max = course_max_entry;

    var entry_set = event.entry_set;
    entry_set.entries.resize(entry_max);
    for (var i = 0; i < entry_max; i++)
    {
        var entry = entry_set.entries[i];
        entry.car_parameter = cp_list[i];
        entry.driver_parameter = dp_list[i];
        entry.driver_parameter.disable_bspec_skill = false;

        if (gp.event.entry_set.entry_generate.bspec_lv_offset > 0)
        {
            var new_dp = gtengine::MCarDriverParameter();

            new_dp.deepCopy(entry.driver_parameter);
            var offset_lv = new_dp.growth_parameter.lv + event.entry_set.entry_generate.bspec_lv_offset;

            if (offset_lv > 40)
                offset_lv = 40;
            
            ABspecUtil::getBSpecPlayerSkill(new_dp, offset_lv, new_dp.growth_parameter.spec_id);
            
            
            entry.driver_parameter = new_dp;
        }

        var skill = entry.driver_parameter.growth_parameter.skill_base_cornering - 85;
        if (skill < 0) skill = 0;
        skill *= 2.5;
        skill += 75;

        entry.driver_parameter.growth_parameter.skill_base_cornering = skill;
    }

    var rp = event.race_parameter;
    rp.entry_max = entry_max;
    rp.racers_max = entry_max;
    rp.enable_damage = true;

    return gp;
}

function createRally()
{
    var entry_num = 4;
    var course_list = ["template01", "template02", "template03"];
    var seed_list = [192, 212, 924];

    var gp = gtengine::MGameParameter();
    
    gp.events.resize(course_list.size);

    for (var i = 0; i < gp.events.size; ++i)
    {
        var event = gp.events[i];

        event.game_mode = gtengine::GameMode::EVENT_RALLY;

        event.event_type = gtengine::EventType::RACE;

        var play_style = event.play_style;
        play_style.play_type = gtengine::PlayType::RACE;
        play_style.replay_record_enable = true;
        

        var reward = event.reward;
        reward.point_table.resize(8);
        for (var j = 0; j < 8; ++j)
            reward.point_table[j] = (8 - j) * 10 + (i * 5);
        

        var entry_set = event.entry_set;
        var entry_generate = entry_set.entry_generate;
        entry_generate.entry_num = entry_num;
        entry_generate.player_pos = entry_num - 1;
        entry_generate.generate_type = gtengine::GenerateType::SPEC_DB;

        var course_code = gtengine::MSpecDB::getCourseCode(course_list[i]);
       
        var track = event.track;
        track.course_code = course_code;

        var rp = event.race_parameter;
        rp.race_type = gtengine::RaceType::TIMEATTACK;
        rp.start_type = gtengine::StartType::GRID;
        rp.complete_type = gtengine::CompleteType::BYLAPS;
        rp.finish_type = gtengine::FinishType::TARGET;
        rp.flagset = gtengine::RaceFlagSet::FLAGSET_RALLY;
        rp.grid_sort_type = gtengine::GridSortType::NONE;
        rp.time_to_finish = 15000;
        rp.auto_standing_delay = 5;
        rp.race_limit_laps = 1;
        rp.entry_max = entry_num;
        rp.racers_max = entry_num;
        rp.allow_codriver = true;
        rp.pace_note = true;
        rp.line_ghost_play_max = 0;
        rp.line_ghost_record_type = gtengine::LineGhostRecordType::OFF;
    }

    return gp;
}

function createTour(course_code)
{
    var gp = gtengine::MGameParameter();
    var entry_num = 8;

    var event = gp.event;

    event.game_mode = gtengine::GameMode::TOUR;
    
    var play_style = event.play_style;
    play_style.play_type = gtengine::PlayType::RACE;
    play_style.replay_record_enable = true;

    var entry_set = event.entry_set;
    var entry_generate = entry_set.entry_generate;
    entry_generate.entry_num = entry_num;
    entry_generate.player_pos = (entry_num - 1) / 2;
    entry_generate.generate_type = gtengine::GenerateType::SPEC_DB;


    var course_max_entry = gtengine::MSpecDB::getCourseMaxEntry(course_code);
    var entry_max = entry_num;
    if (entry_max > course_max_entry)
        entry_max = course_max_entry;

    
    var track = event.track;
    track.course_code = course_code;


    var rp = event.race_parameter;
    rp.race_type = gtengine::RaceType::COMPETITION;
    rp.start_type = gtengine::StartType::GRID;
    rp.complete_type = gtengine::CompleteType::BYLAPS;
    rp.finish_type = gtengine::FinishType::NONE;
    rp.race_limit_laps = 1;
    rp.entry_max = entry_max;
    rp.racers_max = entry_max;
    rp.line_ghost_play_max = 0;
    rp.line_ghost_record_type = gtengine::LineGhostRecordType::OFF;
    rp.enable_damage = true

    return gp;
}

function createEvent()
{
    var entry_num = 8;
    var course_list = ["campo", "tsukuba", "suzuka_east"];


    var gp = gtengine::MGameParameter();
    gp.events.resize(course_list.size);
    if (course_list.size >= 2)
        gp.championship = true;
    
    for (var i = 0; i < gp.events.size; ++i)
    {
        var event = gp.events[i];

        event.game_mode = gtengine::GameMode::EVENT_RACE;

        event.event_type = gtengine::EventType::RACE;

        var play_style = event.play_style;
        play_style.play_type = gtengine::PlayType::RACE;
        play_style.replay_record_enable = true;
    
    
        var reward = event.reward;
        reward.point_table.resize(8);
        for (var j = 0; j < 8; ++j)
            reward.point_table[j] = (8 - j) * 10 + (i * 5);
        
        var entry_set = event.entry_set;
        var entry_generate = entry_set.entry_generate;
        entry_generate.entry_num = entry_num;
        entry_generate.player_pos = (entry_num - 1) / 2;
        entry_generate.generate_type = gtengine::GenerateType::SPEC_DB;

        var course_code = gtengine::MSpecDB::getCourseCode(course_list[i]);
       
        var course_max_entry = gtengine::MSpecDB::getCourseMaxEntry(course_code);
        var entry_max = entry_num;
        if (entry_max > course_max_entry)
            entry_max = course_max_entry;
       

        var track = event.track;
        track.course_code = course_code;


        var rp = event.race_parameter;
        rp.race_type = gtengine::RaceType::COMPETITION;
        rp.start_type = gtengine::StartType::GRID;
        rp.complete_type = gtengine::CompleteType::BYLAPS;
        rp.finish_type = gtengine::FinishType::TARGET;
        rp.race_limit_laps = 1;

        rp.entry_max = entry_max;
        rp.racers_max = entry_max;
        rp.line_ghost_play_max = 0;
        rp.line_ghost_record_type = gtengine::LineGhostRecordType::OFF;
        rp.enable_damage = true;
    }

    return gp;
}

function createLeaveDemo(course_code, race_code, entry_num)
{
    var gp = gtengine::MGameParameter();
    var course_max_entry = gtengine::MSpecDB::getCourseMaxEntry(course_code);
    if (entry_num > course_max_entry)
        entry_num = course_max_entry;

    var event = gp.event;
    event.game_mode = gtengine::GameMode::SINGLE_RACE;
    
    var play_style = event.play_style;
    play_style.play_type = gtengine::PlayType::DEMO;
    play_style.no_quickmenu = true;
    play_style.replay_record_enable = false;

    var entry_set = event.entry_set;
    var entry_generate = entry_set.entry_generate;
    entry_generate.entry_num = entry_num;
    entry_generate.player_pos = gtengine::MGameParameter::INVALID_VALUE_INT;
    entry_generate.ai_skill = 100;
    entry_generate.enemy_lv = 0;
    entry_generate.race_code = race_code;
    entry_generate.generate_type = gtengine::GenerateType::SPEC_DB;


    var limit_minimum_entries = true;


    var entry_max = 16;
    if (limit_minimum_entries)
        entry_max = entry_num;
    if (entry_max > course_max_entry)
        entry_max = course_max_entry;


    var track = event.track;
    track.course_code = course_code;


    var rp = event.race_parameter;
    rp.course_code = course_code;
    rp.race_type = gtengine::RaceType::COMPETITION;
    rp.start_type = gtengine::StartType::ROLLING;
    rp.complete_type = gtengine::CompleteType::BYLAPS;
    rp.finish_type = gtengine::FinishType::TARGET;
    rp.race_limit_laps = 0;
    rp.entry_max = entry_max;
    rp.racers_max = entry_max;
    rp.line_ghost_play_max = 0;
    rp.line_ghost_record_type = gtengine::LineGhostRecordType::OFF;
    rp.enable_damage = false;


    rp.enable_pit = false;

    return gp;
}

function createCourseEdit(scenery_code)
{
    var course_code = gtengine::MSpecDB::getCourseCode("coursemaker");
    var gp = gtengine::MGameParameter();

    var event = gp.events[0];
    event.game_mode = gtengine::GameMode::COURSE_EDIT;
    var play_style = event.play_style;
    play_style.play_type = gtengine::PlayType::RACE;
    play_style.no_quickmenu = false;

    var entry_set = event.entry_set;

    entry_set.entries.resize(1);
    var entry = entry_set.entries[0];
    entry.player_no = 0;
 

    var rp = event.race_parameter;
    rp.race_type = gtengine::RaceType::TIMEATTACK;
    rp.start_type = gtengine::StartType::FREE;
    rp.complete_type = gtengine::CompleteType::NONE;
    rp.ghost_type = gtengine::GhostType::NONE;
    rp.penalty_level = gtengine::PenaltyLevelTypes::OFF;
    rp.entry_max = 1;
    rp.racers_max = 1;
    rp.enable_damage = false;
    
    var track = event.track;
    track.course_code = course_code;
    return gp;
}