// NOTE: We put errors into a header, non-original, but where else to put it?
#include "dnas_error.h"

module PROJECT::ROOT
{
	static sDnas  = nil;
	static sPhase = 0;
	
	function StrError(context, errno)
	{
		var showFooter = false;
		var str;
	
		switch (errno)
		{
			case sceDNAS2_SS_SERVER_BUSY:
				str = context.translate(ROOT, "SS_SERVER_BUSY");
				break;
	
			case sceDNAS2_SS_BEFORE_SERVICE:
				str = context.translate(ROOT, "SS_BEFORE_SERVICE");
				showFooter = true;
				break;
	
			case sceDNAS2_SS_OUT_OF_SERVICE:
				str = context.translate(ROOT, "SS_OUT_OF_SERVICE");
				showFooter = true;
				break;
	
			case sceDNAS2_SS_END_OF_SERVICE:
				str = context.translate(ROOT, "SS_END_OF_SERVICE");
				showFooter = true;
				break;
	
			case sceDNAS2_SS_SESSION_TIME_OUT:
				str = context.translate(ROOT, "SS_SESSION_TIME_OUT");
				break;
	
			case sceDNAS2_SS_INVALID_SERVER:
				str = context.translate(ROOT, "SS_INVALID_SERVER");
				showFooter = true;
				break;
	
			case sceDNAS2_SS_INTERNAL_ERROR:
				str = context.translate(ROOT, "SS_INTERNAL_ERROR");
				showFooter = true;
				break;
	
			case sceDNAS2_SS_EXTERNAL_ERROR:
				str = context.translate(ROOT, "SS_EXTERNAL_ERROR");
				showFooter = true;
				break;
	
			case sceDNAS2_SS_INVALID_PS2:
			case sceDNAS2_SS_INVALID_HDD_BINDING:
				str = context.translate(ROOT, "SS_INVALID_HW");
				showFooter = true;
				break;
	
			case sceDNAS2_SS_INVALID_MEDIA:
			case sceDNAS2_SS_INVALID_AUTHDATA:
				str = context.translate(ROOT, "SS_INVALID_MEDIA");
				showFooter = true;
				break;
	
			case sceDNAS2_ERR_GLUE_ABORT:
				str = context.translate(ROOT, "GLUE_ABORT");
				break;
	
			case sceDNAS2_ERR_NET_PROXY:
				str = context.translate(ROOT, "NET_PROXY");
				break;
				
			case sceDNAS2_ERR_NET_ETIMEOUT:
			case sceDNAS2_ERR_NET_TIMEOUT:
				str = context.translate(ROOT, "NET_TIMEOUT");
				break;
	
			case sceDNAS2_ERR_NET_DNS_TRY_AGAIN:
				str = context.translate(ROOT, "DNS_TRY_AGAIN");
				break;
	
			case sceDNAS2_ERR_NET_DNS_HOST_NOT_FOUND:
			case sceDNAS2_ERR_NET_DNS_NO_RECOVERY:
			case sceDNAS2_ERR_NET_DNS_NO_DATA:
				str = context.translate(ROOT, "DNS_COMMON");
				break;
	
			case sceDNAS2_ERR_NET_DNS_OTHERS:
				str = context.translate(ROOT, "DNS_OTHERS");
				break;
	
			case sceDNAS2_ERR_NET_SSL:
			case sceDNAS2_ERR_NET_EISCONN:
			case sceDNAS2_ERR_NET_ECONNREFUSED:
			case sceDNAS2_ERR_NET_ENETUNREACH:
			case sceDNAS2_ERR_NET_ENOTCONN:
			case sceDNAS2_ERR_NET_ECONNRESET:
				str = context.translate(ROOT, "NET_SERVER");
				break;
	
			case sceDNAS2_ERR_NET_ENOBUFS:
			case sceDNAS2_ERR_NET_EMFILE:
			case sceDNAS2_ERR_NET_EBADF:
			case sceDNAS2_ERR_NET_EINVAL:
			case sceDNAS2_ERR_NET_OTHERS:
				str = context.translate(ROOT, "NET_COMM");
				break;
	
			default:
				str = context.translate(ROOT, "OTHER");
				if (errno <= -800)
					showFooter = true;
				break;
		}
	
		if (showFooter)
		{
			footer.visible = true;
			footer["text"].text = context.translate(ROOT, "footer");
		}
	
		return str;
	}


	function OnFrame(context)
	{
		if (sPhase != 0)
		{
			var done  = sDnas.IsDone();
			if (done)
			{
				var error = sDnas.GetLastError();
				if (!error)
				{
					switch (sPhase)
					{
						case 1:
							if (sDnas.RequestId())
							{
								sPhase = 2;
							}
							else
							{
								error = sDnas.GetLastError();
							}
							break;
						
						case 2:
							main::network.setDnasSignature(sDnas.GetId());
							sPhase = 0;
							DeleteWatcher();
							start_page(context, ServerRoot);
							break;
					}
				}
			
				if (error)
				{
					message["text"].text = "%d: %s".format(error, StrError(context, error));
					sPhase = 0;
					DeleteWatcher();
				}
			}
		}
	}



	function GetPassPhrase(code)
	{
		var a = []
	
		if (code == "dna_beta")
		{
			a.push(0x40); a.push(0xBC); a.push(0x09); a.push(0xD5);
			a.push(0x53); a.push(0x35); a.push(0x9C); a.push(0xE0);
		}
		else
		{
			a.push(0x33); a.push(0xB3); a.push(0xEF); a.push(0x42);
			a.push(0x4B); a.push(0x4C); a.push(0x7B); a.push(0x60);
		}
		return a;
	}


	function OnInitialize(context)
	{
		footer.visible = false;
	
		mark::TextFace.text = context.translate(ROOT, "notice");
	
		var code = main::menu::MSystem::GetDnasCode();
		var ver  = main::menu::MSystem::GetVersionBranch();
	
		if (code == "dna" && (ver == "beta" || ver == "main"))
			code = "dna_beta";
	
		var filename = "/dnas/auth_" + code + ".dat";
		var netconf  = main::game.option.netconf;
	
		var success = false;
	
		if (netconf.use_proxy)
		{
			success = sDnas.Initialize(
				filename,
				GetPassPhrase(code),
				netconf.proxy,
				netconf.proxy_port
			);
		}
		else
		{
			success = sDnas.Initialize(
				filename,
				GetPassPhrase(code)
			);
		}
	
		if (success)
		{
			success = sDnas.RequestAuthorization();
			if (success)
			{
				sPhase = 1;
				CreateWatcher(context, OnFrame, 2);
			}
		}
	
		if (!success)
		{
			var error = sDnas.GetLastError();
			message["text"].text = "%d: %s".format(error, StrError(context, error));
		}
	}



	function onInitialize(context)
	{
		message["text"].text = context.translate(ROOT, "AUTH");
	
		sDnas = main::menu::MDnas();
	
		var event = main::menu::MScriptEvent(context, ROOT, "OnInitialize");
		context.pushEvent(event);
	}
	
	function onFinalize(context)
	{
		DeleteWatcher();
		sDnas = nil;
	}
	
	function onCancel(context)
	{
		main::sound.play("cancel");
	
		var result = openConfirmDialog(context, DIALOG_QUERY, context.translate(ConnectRoot, "QUIT"));
		if (result)
		{
			DeleteWatcher();
			sDnas.Abort();
			main::network.disconnect();
			restart(context);
		}
	
		return EVENTRESULT_FILTER;
	}
}