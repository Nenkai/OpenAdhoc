module PhotoShootProject::ShootRoot
{
	static last_stand = 0;

	function normalize(value, min, max)
	{
		return (value - min) / (max - min);
	}
	
	function unnormalize(value, min, max)
	{
		return value * (max - min) + min;
	}

	import main::menu::MUtility::GetFormatString

	function format_int(value)
	{
		var f = value;
	
		if (f < 0.0)
			f -= 0.5;
		else if (f > 0.0)
			f += 0.5;
	
		f.toInt().toString();
	}
	
	function format_int10(value)
	{
		var f = value * 10.0;
	
		if (f < 0.0)
			f -= 0.5;
		else if (f > 0.0)
			f += 0.5;
	
		GetFormatString("%.1t", f.toInt());
	}


	function fov_step(slider, fac)
	{
		var x = slider.value - slider.repeat_start;
	
		if (x < 0.0)
			x = -x;
	
		var len = slider.max - slider.min;
		x /= len;
	
		(0.002 + x) * fac;
	}
	
	function aperture_step(slider)
	{
		var x = slider.value - slider.repeat_start;
	
		if (x < 0.0)
			x = -x;
	
		var len = slider.max - slider.min;
		x /= len;
	
		0.1 + (x * 5.0);
	}

	function zoom_step(slider)
	{
		var x = slider.value - slider.repeat_start;
	
		if (x < 0.0)
			x = -x;
	
		x /= (slider.max - slider.min);
	
		1.0 + (x * 10.0);
	}
	
	function onLoad(context)
	{
		Map::PM::setCarArrow(context, 0);
		Map::PM::setCameraArrow(context, 0);
	}

	function onInitialize(context)
	{
		Panel::Orbit.can_focus = 0;
		Panel::Orbit.visible = 0;
	
		if (ShootRoot.focus_widget == nil)
			ShootRoot.focus_widget = Panel::Pan;
	
		setStand(last_stand);
		Panel::FocalLen::Reset();
		Panel::Aperture::Reset(context);
	
		Map::PM::zoom.repeat_start = Map::PM::zoom.value;
		Map::PM::zoom::onValueChanged(context, Map::PM::zoom);
		Map::PM::zoom.popup = 1;
	
		ShootRoot::Panel::ManualFocus::Reset();
		ShootRoot::Panel::Mode::Reset();
	
		context.pushEvent(main::menu::MFunctionEvent(set_navi, context));
	}
	
	function set_navi(context)
	{
		context.sync();
		Map::PM::set_navigate_box(0);
	}

	function setStand(flg)
	{
		var option = main::game.option;
		var asp = option.photo_aspect;
		var widget = nil;
	
		if (flg)
		{
			switch (asp)
			{
				case "16x9":
				{
					widget = View::Stand16_9;
					break;
				}
				case "3x2":
				{
					widget = View::Stand3_2;
					break;
				}
				case "1x1":
				{
					widget = View::A1_1;
					break;
				}
				default:
				{
					widget = View::StandViewArea;
					break;
				}
			}
		}
		else
		{
			switch (asp)
			{
				case "16x9":
				{
					widget = View::Lay16_9;
					break;
				}
				case "3x2":
				{
					widget = View::Lay3_2;
					break;
				}
				case "1x1":
				{
					widget = View::A1_1;
					break;
				}
				default:
				{
					widget = View::LayViewArea;
					break;
				}
			}
		}
	
		View::PV.x = widget.x;
		View::PV.y = widget.y;
		View::PV.w = widget.w;
		View::PV.h = widget.h;
	
		Panel::Lay.active = !flg;
		Panel::Stand.active = flg;
		Map::PM.stand = flg;
	}

	function onCancel(context, event, item)
	{
		return EVENTRESULT_FILTER;
	}
	
	import main::menu::MKeyPressEvent
	import main::menu::MKeyReleaseEvent
	static before_widget = nil;
	static current_widget = nil;
	static grab = 0;
	static map_view = 0;
	static fov_popup = 0;
	
	function onKeyPress(context, event)
	{
		if (map_view)
		{
			if (event.keysym == 65480 || event.keysym == 65490)
				return true;

			switch (event.keysym)
			{
				case 65252:
					;
				case 65254:
				{
					event.keysym = 65361;
					break;
				}
				case 65253:
					;
				case 65255:
				{
					event.keysym = 65363;
					break;
				}
				default:
					return false;
			}
		}
	
		if (!grab)
		{
			var state = context.getUpdateContext().getPadButtonState(0) & (256 | 512 | 2048 | 4096);
	
			switch (event.keysym)
			{
				case 65480:
					;
				case 65481:
					;
				case 65490:
					;
				case 65491:
					;
				case 65293:
					;
			}
	
			var focus_widget = nil;
	
			if (event.keysym == 65293)
			{
				switch (ShootRoot.focus_widget)
				{
					case Panel::Pan:
					{
						state = 256;
						grab = true;
						break;
					}
					case Panel::Roll:
					{
						state = 512;
						grab = true;
						break;
					}
					case Panel::Move:
					{
						state = 2048;
						grab = true;
						break;
					}
					case Panel::Climb:
					{
						state = 4096;
						grab = true;
						break;
					}
					default:
						break;
				}
	
				if(state == 256)
				{
					focus_widget = ShootRoot::Panel::Pan;
					Map::PM.operate_mode = "pan";
				}
				if(state == 512)
				{
					focus_widget = ShootRoot::Panel::Roll;
					Map::PM.operate_mode = "roll";
				}
				if(state == 2048)
				{
					focus_widget = ShootRoot::Panel::Move;
					Map::PM.operate_mode = "move";
				}
				if(state == 4096)
				{
					focus_widget = ShootRoot::Panel::Climb;
					Map::PM.operate_mode = "climb";
				}
				if(state == 256 | 512)
				{
					focus_widget = ShootRoot::Map::PM::zoom;
					Map::PM.operate_mode = "none";
				}
				if(state == 2048 | 4096)
				{
					focus_widget = ShootRoot::Panel::FocalLen;
					Map::PM.operate_mode = "none";
	
					if (!fov_popup)
					{
						fov_popup.value = 1;
						if (!focus_widget.popup)
						{
							context.pushEvent(MKeyPressEvent(context, focus_widget, 65293, 1, 0, 0, 0));
						}
					}
				}
	
				if (focus_widget != nil)
				{
					if (focus_widget != current_widget)
					{
						if (current_widget != nil)
							current_widget.active = false;
	
						current_widget = focus_widget;
	
						if (current_widget != nil)
						{
							current_widget.active = true;
	
							if (before_widget == nil)
							{
								before_widget = ShootRoot.focus_widget;
							}
							ShootRoot.focus_widget = current_widget;
							main::sound.play("cursor");
						}
					}
				}
			}
		}
	
		if (current_widget != nil)
		{
			//4360	INT_CONST: 1 (0x01)	
			//4361	JUMP: Jump:UNK			
			//4362	INT_CONST: 0 (0x00)			
			//4363	POP_OLD			
			//4364	SET_STATE_OLD: State=RETURN (1)			
			//4365	NIL_CONST			
			//4366	NIL_CONST
		}
	}

	function onKeyRelease(context, event)
	{
		if (map_view)
		{
			if (event.keysym == 65480 || event.keysym == 65490)
			{
				return 1;
			}
			return 0;
		}
	
		var state = context.getUpdateContext().getPadButtonState(0) &
			(256 | 512 | 2048 | 4096 | 128 | 32);
	
		if (event.keysym == 65293)
		{
			grab = 0;
		}
	
		if (!grab)
		{
			switch (event.keysym)
			{
				case 65480:
				case 65481:
					var focus_widget = nil;
	
				case 65490:
				case 65491:
					if (state == 256)
					{
						var focus_widget = ShootRoot::Panel::Pan;
						Map::PM.operate_mode = "pan";
					}
					if(state == 512)
					{
						focus_widget = ShootRoot::Panel::Roll;
						Map::PM.operate_mode = "roll";
					}
					if(state == 2048)
					{
						focus_widget = ShootRoot::Panel::Move;
						Map::PM.operate_mode = "move";
					}
					if(state == 4096)
					{
						focus_widget = ShootRoot::Panel::Climb;
						Map::PM.operate_mode = "climb";
					}
					if(state == 256 | 512)
					{
						focus_widget = ShootRoot::Map::PM::zoom;
						Map::PM.operate_mode = "none";
					}
					if(state == 2048 | 4096)
					{
						focus_widget = ShootRoot::Panel::FocalLen;
						Map::PM.operate_mode = "none";
					}
					if(state != 2048 | 4096)
					{
						var fov = Panel::FocalLen
						if (fov_popup)
						{
							if(fov.popup)
							{
								context.pushEvent(MKeyPressEvent(context, fov, 65293, 1, 0, 0, 0));
							}
							fov_popup.value = 0;
						}
					}
					if (before_widget != nil)
					{
						if (focus_widget != current_widget)
						{
							if (current_widget != nil)
							{
								current_widget.active = false;
							}
							current_widget = focus_widget;
							
							if (current_widget != nil)
							{
								current_widget.active = true;
								ShootRoot.focus_widget = focus_widget;
								main::sound.play("cursor");
							}
							Map::PM.operate_mode = "none";	
							ShootRoot.focus_widget = before_widget;
							before_widget = nil;
						}
					}
				case 65293:
					Map::PM.operate_mode = "none";
					break;
			}
		}
		if (current_widget != nil)
		{
			true;
		}
		false;
	}
}

module PhotoShootProject::ShootRoot::Map::PM
{
	static last_event_mask = 0;

	function onFocusOff(context)
	{
		main::sound.play("cursor");
	
		context.cursor = "normal";
	
		car::body.active = false;
		camera::body.active = false;
	
		PM.operate_mode = "map_zoom";
	
		context.event_mask = last_event_mask;
		context.cursor_visible = true;
	
		ToolTip::tooltip.key = "MapView_description";
		return EVENTRESULT_FILTER;
	}

	function setCarArrow(context, flg)
	{
		car::body::bga0.visible = !flg;
		car::body::bg.visible   = !flg;
		car::body::bga.visible  = !flg;
		car::shadow::bg.visible = !flg;
	
		car::body::arrow.visible   = flg;
		car::shadow::arrow.visible = flg;
	
		car::bgi.visible = !flg;
	}

	function setCameraArrow(context, flg)
	{
		camera::body::bga0.visible   = !flg;
		camera::body::bg.visible     = !flg;
		camera::body::bga.visible    = !flg;
		camera::shadow::bg.visible   = !flg;
	
		camera::body::arrow.visible   = flg;
		camera::shadow::arrow.visible = flg;
	
		camera::bgi.visible = !flg;
	}

	function setViewAngleRange(context, min, max)
	{
	}

	function setViewAngle(context, value)
	{
	}

	function onPhotoViewDisable(context, disable)
	{
		View.insensitive = disable;
	}

	function set_navigate_box(in)
	{
		if (in)
		{
			car::body.navigate_box    = [ -254, -36, 48 + 254, 48 + 36 ];
			camera::body.navigate_box = [ -254, -36, 48 + 254, 48 + 36 ];
		}
	
		// Centers of car and camera
		var px = (car.x + (car.w * 0.5));
		var py = (car.y + (car.h * 0.5));
		var qx = (camera.x + (camera.w * 0.5));
		var qy = (camera.y + (camera.h * 0.5));
	
		// Absolute deltas
		var dx = (px - qx);
		var dy = (py - qy);
		if (dx < 0.0) { dx = -dx; }
		if (dy < 0.0) { dy = -dy; }
	
		// Split mode: horizontal vs vertical
		var s = 0
		if (dx > dy)
			s = 1;
	
		// Midpoint between centers
		var cx = ((px + qx) * 0.5);
		var cy = ((py + qy) * 0.5);
	
		// Primary/secondary actors and their bodies
		var a = camera;
		var b = car;
		var a_body = camera::body;
		var b_body = car::body;
	
		// If the car center is above the camera center, swap roles
		if (py < qy)
		{
			a = car;
			b = camera;
			a_body = car::body;
			b_body = camera::body;
		}
	
		// Build navigate box for "a"
		var x0 = 0.0;
		var y0 = (-a.y);
		var x1 = a.w;
		var y1 = (s ? (PM.h - a.y) : (cy - a.y));
		a_body.navigate_box = [ x0, y0, x1, y1 ];
	
		// Build navigate box for "b"
		x0 = 0.0;
		y0 = (s ? (-b.y) : (cy - b.y));
		x1 = b.w;
		y1 = (PM.h - b.y);
		b_body.navigate_box = [ x0, y0, x1, y1 ];
	}
}

module PhotoShootProject::ShootRoot::Map::PM::car::body
{
	function onFocusEnter(context, event)
	{
		if (PM.operate_mode == "none")
		{
			PM.operate_mode = "map_zoom";
			ShootRoot::map_view.value = 1;
			ToolTip::tooltip.key = "MapView_description";
		}
	
		set_navigate_box(1);
		true;
	}

	function onFocusLeave(context, event)
	{
		if (PM.operate_mode == "map_zoom")
		{
			PM.operate_mode = "none";
			ShootRoot::map_view.value = 0;
			ToolTip::tooltip.key = "";
		}
	
		set_navigate_box(0);
		true;
	}

	function onActivate(context, event, item)
	{
		main::sound.play("cursor");
	
		context.cursor = "";
		PM.operate_mode = "car";
		body.active = true;
	
		PM::last_event_mask.value = context.event_mask;
		context.event_mask = 0;
		context.cursor_visible = false;
	
		ToolTip::tooltip.key = "MapView_description_car";
	
		return EVENTRESULT_FILTER;
	}
}

module PhotoShootProject::ShootRoot::Map::PM::camera::body
{
	function onFocusEnter(context, event)
	{
		if (PM.operate_mode == "none")
		{
			PM.operate_mode = "map_zoom";
			ShootRoot::map_view.value = 1;
			ToolTip::tooltip.key = "MapView_description";
		}
	
		set_navigate_box(1);
		true;
	}

	function onFocusLeave(context, event)
	{
		if (PM.operate_mode == "map_zoom")
		{
			PM.operate_mode = "none";
			ShootRoot::map_view.value = 0;
			ToolTip::tooltip.key = "";
		}
	
		set_navigate_box(0);
		true;
	}

	function onActivate(context, event, item)
	{
		main::sound.play("cursor");
	
		context.cursor = "";
		PM.operate_mode = "camera";
		body.active = true;
	
		PM::last_event_mask.value = context.event_mask;
		context.event_mask = 0;
		context.cursor_visible = false;
	
		ToolTip::tooltip.key = "MapView_description";
	
		return EVENTRESULT_FILTER;
	}
}

module PhotoShootProject::ShootRoot::Map::PM::zoom
{
	function onValueChanged(context, slider)
	{
		PM.setBaseLen(zoom.value);
	}
	
	function onStepChanged(context, slider)
	{
		zoom.step = zoom_step(zoom);
	}
}

module PhotoShootProject::ShootRoot::Panel::FocalLen
{
	static last_professional = nil;

	function Cleanup()
	{
		last_professional = nil;
		popup::min.text = nil;
		popup::max.text = nil;
		popup::pinch::value.text = nil;
		label.text = nil;
	}


	function Reset()
	{
		var option = main::game.option;
		var professional = option.photo_professional;
	
		if (last_professional == nil)
		{
			last_professional = !professional;
	
			if (professional)
			{
				FocalLen.min = 16.0;
				FocalLen.max = 300.0;
				FocalLen.value = 70.0;
			}
			else
			{
				FocalLen.min = 1.0;
				FocalLen.max = 10.0;
	
				var value = normalize(70.0, 16.0, 300.0);
				FocalLen.value = FocalLen.min + value * (FocalLen.max - FocalLen.min);
			}
		}
	
		if (professional != last_professional)
		{
			if (professional)
			{
				var value = normalize(FocalLen.value, FocalLen.min, FocalLen.max);
	
				FocalLen.min = 16.0;
				FocalLen.max = 300.0;
				FocalLen.value = FocalLen.min + value * (FocalLen.max - FocalLen.min);
	
				FocalLen.current_value = FocalLen.value;
				FocalLen.repeat_start = FocalLen.value;
	
				FocalLen.step = fov_step(FocalLen, (FocalLen.max - FocalLen.min) / 4.0);
				popup::min.text = format_int(FocalLen.min);
				popup::max.text = format_int(FocalLen.max);
				popup::pinch::value.text = format_int(FocalLen.value);
				label.text = format_int(FocalLen.value) + "mm";
				Map::PM.view_angle = FocalLen.value;
			}
			else
			{
				var value = normalize(FocalLen.value, FocalLen.min, FocalLen.max);
	
				FocalLen.min = 1.0;
				FocalLen.max = 10.0;
				FocalLen.value = (FocalLen.min + value * (FocalLen.max - FocalLen.min));
	
				FocalLen.current_value = FocalLen.value;
				FocalLen.repeat_start = FocalLen.value;
				FocalLen.step = fov_step(FocalLen, (FocalLen.max - FocalLen.min) / 4.0);
	
				popup::min.text = format_int(FocalLen.min);
				popup::max.text = format_int(FocalLen.max);
				popup::pinch::value.text = format_int(FocalLen.value);
				label.text = format_int(FocalLen.value);
	
				// Map normalized slider back to mm for the map view angle
				var value = normalize(FocalLen.value, FocalLen.min, FocalLen.max);
				Map::PM.view_angle = (16.0 + value * (300.0 - 16.0));
			}
		}
		last_professional = professional;
	}

	function onValueChanged(context)
	{
		var option = main::game.option;
		var professional = option.photo_professional;
	
		if (professional)
		{
			popup::pinch::value.text = format_int(FocalLen.value);
			label.text = format_int(FocalLen.value) + "mm";
			Map::PM.view_angle = FocalLen.value;
		}
		else
		{
			popup::pinch::value.text = format_int(FocalLen.value);
			label.text = format_int(FocalLen.value);
	
			var value = normalize(FocalLen.value, FocalLen.min, FocalLen.max);
			Map::PM.view_angle = (16.0 + value * (300.0 - 16.0));
		}
	}

	function onStepChanged(context)
	{
		var option = main::game.option;
		var professional = option.photo_professional;
	
		if (professional)
		{
			FocalLen.step = fov_step(FocalLen, (FocalLen.max - FocalLen.min) / 4.0);
		}
		else
		{
			FocalLen.step = fov_step(FocalLen, (FocalLen.max - FocalLen.min) / 4.0);
		}
	}
}

module PhotoShootProject::ShootRoot::Panel::Aperture
{
	static last_professional = nil;

	function Cleanup()
	{
		last_professional = nil;
		popup::min.text = nil;
		popup::max.text = nil;
		popup::pinch::value.text = nil;
		label.text = nil;
	}

	function Reset(context)
	{
		var option = main::game.option;
		var professional = option.photo_professional;
	
		// First-time init: seed last_professional opposite to force a refresh
		if (last_professional == nil)
		{
			last_professional = !professional;
	
			if (professional)
			{
				// Professional: F-number domain [1..16], default 7.5
				Aperture.min = 1.0;
				Aperture.max = 16.0;
				Aperture.value = 7.5;
			}
			else
			{
				// Non-professional: integer steps [1..10]
				Aperture.min = 1.0;
				Aperture.max = 10.0;
	
				// Start from pro default (7.5 on [1..16]) and remap into [1..10]
				var value = normalize(7.5, 1.0, 16.0); // 0..1
				Aperture.value = Aperture.min + value * (Aperture.max - Aperture.min);
			}
		}
	
		// If mode changed, remap values and refresh UI/mapping
		if (professional != last_professional)
		{
			if (professional)
			{
				// Remap current [min..max] → [1..16] continuously
				var value = 1.0 + normalize(Aperture.value, Aperture.min, Aperture.max) * (16.0 - 1.0);
	
				Aperture.min = 1.0;
				Aperture.max = 16.0;
				Aperture.value = value;
				Aperture.current_value = Aperture.value;
				Aperture.repeat_start = Aperture.value;
				Aperture.step = 1.0;
	
				// UI popups use mapped F-number labels in professional mode
				popup::min.text = format_int10(Map::PM.getAperture(context, 1.0));
				popup::max.text = format_int10(Map::PM.getAperture(context, 16.0));
	
				var ap = Map::PM.getAperture(context, value.toInt());
				popup::pinch::value.text = format_int10(ap);
				label.text = "F" + format_int10(ap);
	
				Map::PM.aperture = ap;
			}
			else
			{
				// Remap current [min..max] → normalized, then into [1..10]
				var value = normalize(Aperture.value, Aperture.min, Aperture.max);
	
				Aperture.min = 1.0;
				Aperture.max = 10.0;
				Aperture.value = Aperture.min + value * (Aperture.max - Aperture.min);
				Aperture.current_value = Aperture.value;
				Aperture.repeat_start = Aperture.value;
				Aperture.step = 1.0;
	
				// UI popups show plain integers in non-professional mode
				popup::min.text = format_int(Aperture.min);
				popup::max.text = format_int(Aperture.max);
				popup::pinch::value.text = format_int(Aperture.value);
				label.text = format_int(Aperture.value);
	
				// Still drive the underlying PM aperture via mapped [1..16]
				var value = 1.0 + normalize(Aperture.value, Aperture.min, Aperture.max) * (16.0 - 1.0);
				var ap = Map::PM.getAperture(context, value.toInt());
				Map::PM.aperture = ap;
			}
		}
	
		last_professional = professional;
	}

	function onValueChanged(context, slider)
	{
		var option = main::game.option;
		var professional = option.photo_professional;
	
		if (professional)
		{
			var i = Aperture.value.toInt();
			var ap = Map::PM.getAperture(context, i);
	
			Aperture.current_value = Aperture.value;
			Aperture.step = 1.0;
	
			popup::pinch::value.text = format_int10(ap);
			label.text = "F" + format_int10(ap);
			Map::PM.aperture = ap;
		}
		else
		{
			Aperture.current_value = Aperture.value;
			Aperture.step = 1.0;
	
			popup::pinch::value.text = format_int(Aperture.value);
			label.text = format_int(Aperture.value);
	
			var value = 1.0 + normalize(Aperture.value, Aperture.min, Aperture.max) * (16.0 - 1.0);
			Map::PM.aperture = value;
		}
	}
}
 
module PhotoShootProject::ShootRoot::Panel::Pan
{
}

module PhotoShootProject::ShootRoot::Panel::Roll
{
}

module PhotoShootProject::ShootRoot::Panel::Move
{
}

module PhotoShootProject::ShootRoot::Panel::Climb
{
}
 
 
module PhotoShootProject::ShootRoot::Panel::Steering
{
	function onActivate(context, event, item)
	{
		main::sound.play("ok");
	
		var result = SteeringDialog::open(context, 0);
	
		if (result)
		{
			SteeringDialog::Apply();
		}
		else
		{
			SteeringDialog::Cancel();
		}
	
		SteeringDialog::Cleanup();
		return EVENTRESULT_FILTER;
	}
}

module PhotoShootProject::ShootRoot::Panel::Filter
{
	function onActivate(context, event, item)
	{
		main::sound.play("ok");
	
		var result = FilterDialog::open(context, 0);
	
		if (result)
		{
			FilterDialog::Apply();
		}
		else
		{
			FilterDialog::Cancel();
		}
	
		FilterDialog::Cleanup();
		return EVENTRESULT_FILTER;
	}
}

module PhotoShootProject::ShootRoot::Panel::Mode
{
	function Reset()
	{
		var option = main::game.option;
	
		Panel::ManualFocus.visible = option.photo_manual_focus;
		var professional = option.photo_professional;
	
		Panel::FocalLen::popup::bg.visible = 1;
		Panel::FocalLen::popup::bg0.visible = 0;
	
		var type = option.photo_shutter;
		main::game.loadShutterSound(type.downcase());
	}

	function onActivate(context, event, item)
	{
		main::sound.play("ok");
	
		var result = ModeDialog::open(context, 0);
	
		if (result)
		{
			ModeDialog::Apply();
			Reset();
			Panel::FocalLen::Reset();
			Panel::Aperture::Reset(context);
			ShootRoot::setStand(last_stand);
		}
		else
		{
			ModeDialog::Cancel();
		}
	
		ModeDialog::Cleanup(context);
		return EVENTRESULT_FILTER;
	}
}

module PhotoShootProject::ShootRoot::Panel::Exit
{
	function onActivate(context, event, item)
	{
		main::sound.play("ok");
	
		var result = openConfirmDialog(context, 1, context.translate(ShootRoot, "Quit?"));
	
		if (result)
		{
			main::game.next_menu_project = main::game.major_menu_project;
			main::game.next_menu_arg = main::game.major_menu_page;
			main::game.menu_result = "exit";
			start_sequence(context, "menu");
		}
	
		return EVENTRESULT_FILTER;
	}
}

module PhotoShootProject::ShootRoot::Panel::ManualFocus
{
	function setActor(widget)
	{
		widget.actor = main::menu::MBlinkActor(widget);
		widget.actor.period = 0.25;
	}


	function Reset()
	{
		setActor(ShootRoot::View::Focus::blink);
	
		View::Focus::fix.visible = true;
		View::Focus::blink.visible = false;
		View::Focus::active.visible = false;
	}

	function onEnter(context, event)
	{
		View::Focus::fix.visible = false;
		View::Focus::blink.visible = true;
		View::Focus::active.visible = false;
	}

	function onLeave(context, event)
	{
		View::Focus::fix.visible = true;
		View::Focus::blink.visible = false;
		View::Focus::active.visible = false;
	}

	function onActivate(context, event)
	{
		View::Focus::blink.visible = 0;
		View::Focus::active.visible = 1;
	
		main::sound.play("zoom1");
	
		var i = 0;
		while (i <= 35)
		{
			var ii = i % 6;
			View::Focus::active.opacity = 0.2 * ii;
			context.sync();
			i++;
		}
	
		main::sound.play("zoom");
	
		View::Focus::blink.visible = 1;
		View::Focus::active.visible = 0;
	
		ShootRoot::Map::PM.doFocus(context);
		return EVENTRESULT_FILTER;
	}

}

module PhotoShootProject::ShootRoot::Panel::Shoot
{
	import main::menu::MActivateEvent
	function onKeyPress(context, event)
	{
		if (event.keysym == 65293)
		{
			Shoot.active = true;
			main::sound.play("shutter");
			true;
		}
		else if (event.keysym == 65421)
		{
			true;
		}
		else if (Shoot.active)
		{
			true;
		}
	
		false;
	}

	function onKeyRelease(context, event)
	{
		if ((event.keysym == 65293) && Shoot.active)
		{
			Shoot.active = false;
			context.pushEvent(MActivateEvent(context, Shoot));
			EVENTRESULT_FILTER;
		}
		else if (event.keysym == 65421)
		{
			true;
		}
	
		false;
	}

	function onActivate(context, event, item)
	{
		if (Map::PM.can_shoot)
		{
			var result = 1;
	
			if (result)
			{
				context.sync(0.1);
				context.startPage(PreviewRoot);
			}
		}
		else
		{
			main::sound.play("disable");
			WarningDialog::open(context, context.translate(ShootRoot, "The car is not visible.Unable to take picture."));
		}
	
		return EVENTRESULT_FILTER;
	}
}

module PhotoShootProject::ShootRoot::Panel::Aspect
{
	function onActivate(context, event, item)
	{
		main::sound.play("cursor");
	
		if (Panel::Lay.active)
		{
			last_stand.value = 1;
		}
		else
		{
			last_stand.value = 0;
		}
	
		ShootRoot::setStand(last_stand);
		return EVENTRESULT_FILTER;
	}
}