module ROOT
{
    hidden.visible = false;

    static sModalPage;
    static sResult = false;

    static sRegulation;
    static sReport;
    static sDispTire;
    static sDispGarage;

    SCALE_WIDGET_SDTV(hidden::Item::report, 2.6)

    SCALE_WIDGET_SDTV(hidden::Item::reporta, 2.6)

    method open(context, regulation, report, disp_tire = true, disp_garage = true)
    {
        sRegulation = regulation;
        sReport = report;
        sDispTire = disp_tire;
        sDispGarage = disp_garage;

        sModalPage = SequenceUtil::ModalPage(context, ROOT);
        sModalPage.open();

        sModalPage = nil;
        sReport = nil;
        sRegulation = nil;
        sDispTire = true;
        sDispGarage = true;

        return sResult;
    }

    method close(context)
    {
        if (sModalPage != nil)
            sModalPage.close();
    }

    method onInitialize(context)
    {
        Pane::ScrolledWindow::ScrollClip::space.initialize(context);
        Pane::ScrolledWindow::ScrollClip.updateGeometry();

        Pane::Button::OK::Garage.visible = sReport != nil && sDispGarage;
    }

    method onFinalize(context)
    {
        Pane::ScrolledWindow::ScrollClip::space.finalize(context);
    }

    method onCancel(context)
    {
        main::sound.play("cancel");
        sResult = false;
        close(context);

        return EVENTRESULT_FILTER;
    }

    method onKeyPress(context, event)
    {
        var status = 0;

        if (event.keysym == CELL_PAD_CTRL_L3_UP)
        {
            Pane::ScrolledWindow::ScrollClip.manualTargetIncY(96.0);
            status = 2;
        }
        else if (event.keysym == CELL_PAD_CTRL_L3_DOWN)
        {
            Pane::ScrolledWindow::ScrollClip.manualTargetIncY(-96.0);
            status = 2;
        }

        return status;
    }

    module Pane::ScrolledWindow::ScrollClip::space
    {
        function conv_pp(context, value)
        {
            return value;
        }

        function conv_tire(context, value)
        {
            return context.translate(ROOT, "TireName", "name_%03d".format(value));
        }

        function conv_tire_f(context, value)
        {
            return conv_tire(context, value);
        }

        function conv_tire_r(context, value)
        {
            return conv_tire(context, value);
        }

        function conv_power(context, value)
        {
            return pdiext::MUnit::GetPowerForDisplay(value) + " " + pdiext::MUnit::GetUnitOfPower();
        }

        function conv_torque(context, value)
        {
            return pdiext::MUnit::GetTorqueForDisplay(value) + " " + pdiext::MUnit::GetUnitOfTorque();
        }

        function conv_weight(context, value)
        {
            return "%{value} " + pdiext::MUnit::GetUnitOfMass();
        }

        function conv_length(context, value)
        {
            return "%{value} mm";
        }

        function conv_year(context, value)
        {
            var language = pdistd::MLocale::getLanguage();

            if (language == "JP" || language == "TW" || language == "KR")
                return "%{value} " + context.translate(ROOT, "Unit", "YEAR");
            else
                return "%{value}";
        }

        function conv_drivetrain(context, value)
        {
            var res = gtengine::DriveTrainType.find_static(function (pair) 
            {
                return value == pair[1];
            });

            if (res.size > 0)
            {
                var name = res[0][0];
                return context.translate(ROOT, "DriveTrainName", name);
            }
            else
                return "";
        }

        function conv_aspiration(context, value)
        {
            var res = gtengine::AspirationType.find_static(function (pair) 
            {
                return value == pair[1];
            });

            if (res.size > 0)
            {
                var name = res[0][0];
                return context.translate(ROOT, "AspirationName", name);
            }
            else
                return "";
        }

        function conv_license(context, value)
        {
            var table = [
                "NAME_LICENSE_B_CLEAR",
                "NAME_LICENSE_A_CLEAR",
                "NAME_LICENSE_IC_CLEAR",
                "NAME_LICENSE_IB_CLEAR",
                "NAME_LICENSE_IA_CLEAR",
                "NAME_LICENSE_S_CLEAR"
            ];

            var idx = value.toInt();
            if (idx >= table.size)
                return "-";
            else
                return context.translate(ROOT, "Trophy", table[idx]);
        }

        method initialize(context)
        {
            var regulation = sRegulation;
            var info = regulation.createInfo();

            var qualified = nil;
            var should_be = nil;
            var current = nil;

            if (sReport != nil)
            {
                var qualified = sReport[0];
                var should_be = sReport[1];
                var current = sReport[2];
            }

            var tire_fr_same = false;

            var koumoku_tire_f = nil;
            var koumoku_tire_r = nil;

            foreach (var koumoku in info)
            {
                if (koumoku[0] == "tire_f")
                {
                    var koumoku_tire_f = koumoku;
                    continue;
                }

                if (koumoku[0] == "tire_r")
                {
                    var koumoku_tire_r = koumoku;
                    continue;
                }
            }

            if (koumoku_tire_f != nil && koumoku_tire_r != nil && 
                koumoku_tire_f[1] == koumoku_tire_r[1] && 
                koumoku_tire_f[2] == koumoku_tire_r[2])
            {
                tire_fr_same = true;
            }

            var no_limit = true;

            foreach (var koumoku in info)
            {
                var value = koumoku.shift();
                var item = hidden::Item.doCopy();

                switch (value)
                {
                    case "car_categories":
                        if (should_be != nil)
                        {
                            var need = should_be.getObjectAttribute(value);
                            item.Check.active = need.size == 0;
                        }

                        var detail = "";
                        var needs = koumoku;

                        foreach (var category in needs)
                        {
                            var res = gtengine::CarCategory.find_static(function (pair)
                            {
                                return pair[1] == category;
                            });

                            if (res.size > 0)
                            {
                                var name = res[0][0];

                                if (detail != "")
                                    detail += "\n";

                                detail += context.translate(ROOT, "CarSpec", "CATEGORY_" + name);
                            }
                        }

                        item.report.text = detail;
                        break;

                    case "cars":
                        if (should_be != nil)
                        {
                            var need = should_be.getObjectAttribute(value);
                            item.Check.active = need.size == 0;
                        }

                        var detail = "";
                        var needs = koumoku;
                        var max = 100;

                        var num = (needs.size < max) ? needs.size : max;

                        var cars = [];
                        var stds = [];

                        for (var i = 0; i < num; ++i)
                        {
                            var car = needs[i];

                            if (car.label.endWith("_std"))
                                stds.push(car.label);
                            else
                                cars.push(car.label);
                        }

                        foreach (var std in stds)
                        {
                            var label = std.removeLastOf("_std");

                            if (cars.indexOf(label) < 0)
                                cars.push(std);
                        }

                        for (var i = 0; i < cars.size; ++i)
                        {
                            var car = cars[i];
                            var name = gtengine::MSpecDB::getCarName(car);

                            if (detail != "")
                                detail += "\n";

                            detail += name;
                        }

                        if (needs.size > max)
                            detail += "\n" + context.translate(ROOT, "Regulation", "ETC");

                        item.report.text = detail;
                        break;

                    case "ban_cars":
                        if (should_be != nil)
                        {
                            var need = should_be.getObjectAttribute(value);
                            item.Check.active = need.size == 0;
                        }

                        var detail = "";
                        var needs = koumoku;
                        var max = 100;

                        var num = (needs.size < max) ? needs.size : max;

                        var cars = [];
                        var stds = [];

                        for (var i = 0; i < num; ++i)
                        {
                            var car = needs[i];

                            if (car.label.endWith("_std"))
                                stds.push(car.label);
                            else
                                cars.push(car.label);
                        }

                        foreach (var std in stds)
                        {
                            var label = std.removeLastOf("_std");

                            if (cars.indexOf(label) < 0)
                                cars.push(std);
                        }

                        for (var i = 0; i < cars.size; ++i)
                        {
                            var car = cars[i];
                            var name = gtengine::MSpecDB::getCarName(car);

                            if (detail != "")
                                detail += "\n";

                            detail += name;
                        }

                        if (needs.size > max)
                            detail += "\n" + context.translate(ROOT, "Regulation", "ETC");

                        item.report.text = detail;
                        break;

                    case "tuners":
                        if (should_be != nil)
                        {
                            var need = should_be.getObjectAttribute(value);
                            item.Check.active = need.size == 0;
                        }

                        var detail = "";
                        var needs = koumoku;

                        foreach (var tuner in needs)
                        {
                            var name = gtengine::MSpecDB::getTunerLabelFromID(tuner);

                            if (detail != "")
                                detail += "\n";

                            detail += context.translate(ROOT, "TunerName", name);
                        }

                        item.report.text = detail;
                        break;

                    case "countries":
                        if (should_be != nil)
                        {
                            var need = should_be.getObjectAttribute(value);
                            item.Check.active = need.size == 0;
                        }

                        var detail = "";
                        var needs = koumoku;

                        foreach (var country in needs)
                        {
                            var name = gtengine::MSpecDB::getCountryLabel(country);

                            if (detail != "")
                                detail += "\n";

                            detail += context.translate(ROOT, "Country", name);
                        }

                        item.report.text = detail;
                        break;

                    case "entitlement":
                        if (should_be != nil)
                        {
                            var need = should_be.getObjectAttribute("need_" + value);
                            item.Check.active = need == nil;
                        } 

                        var need = koumoku[0];

                        var detail = context.translate(ROOT, "Regulation", "entitlement_" + need);
                        item.report.text = detail;
                        break;

                    case "drivetrain":
                    case "aspiration":
                            if (should_be != nil)
                            {
                                var need = should_be.getObjectAttribute("need_" + value);
                                item.Check.active = need == gtengine::MGameParameter::INVALID_VALUE_INT;
                            }

                            var func = space["conv_" + value];
                            var detail = "";
                            var needs = koumoku;

                            foreach (var elem in needs)
                            {
                                var name = func(context, elem);

                                if (detail != "")
                                    detail += "\n";

                                detail += name;
                            }

                            item.report.text = detail;
                            break;

                    case "license":
                        if (should_be != nil)
                        {
                            var need = should_be.getObjectAttribute("need_" + value);
                            item.Check.active = need == gtengine::MGameParameter::INVALID_VALUE_INT;
                        }

                        var func = space["conv_" + value];
                        item.report.text = func(context, koumoku[0]);
                        break;

                    default:
                        if (should_be != nil)
                        {
                            var need = should_be.getObjectAttribute("need_" + value);
                            var limit = should_be.getObjectAttribute("limit_" + value);

                            item.Check.active = need == gtengine::MGameParameter::INVALID_VALUE_INT && limit == gtengine::MGameParameter::INVALID_VALUE_INT;
                        } 

                        if (value == "tire_f")
                        {
                            if (!sDispTire)
                            {
                                item.visible = false;
                                break;
                            }
                            else
                            {
                                if (tire_fr_same)
                                    value = "tire";
                            }
                        }
                        else if (value == "tire_r")
                        {
                            if (!sDispTire)
                            {
                                item.visible = false;
                                break;
                            }
                            else
                            {
                                if (tire_fr_same)
                                {
                                    item.visible = false;
                                    break;
                                }
                            }
                        }

                        var func = space["conv_" + value];
                        var need = koumoku[0];
                        var limit = koumoku[1];

                        if (value == "drivetrain" || value == "aspiration")
                            limit = need;

                        var detail = "";
                        if (need == limit)
                            detail += func != nil ? func(context, need) : need;
                        else
                        {
                            var need_key = "need";
                            var limit_key = "limit";

                            if (value == "year")
                            {
                                need_key = "need_year";
                                limit_key = "limit_year";
                            }

                            if (need != gtengine::MGameParameter::INVALID_VALUE_INT)
                                detail += context.translate(ROOT, "Regulation", need_key).build(((func) != nil) ? func(context, need) : need);

                            if (limit != gtengine::MGameParameter::INVALID_VALUE_INT)
                            {
                                if (detail != "")
                                    detail += "  \n";

                                detail += context.translate(ROOT, "Regulation", limit_key).build(((func) != nil) ? func(context, limit) : limit);
                            }
                        }

                        item.report.text = detail;
                        break;
                }

                item.label.text = context.translate(ROOT, "Regulation", value);
                item.Check.visible = should_be != nil;

                if (item.Check.visible && !item.Check.active)
                {
                    item.label.text_color = item.labela.text_color;
                    item.report.text_color = item.reporta.text_color;
                }

                if (item.visible)
                {
                    self.appendChild(context, item);
                    var no_limit = false;
                }
            }

            ScrolledWindow::no_limit.visible = no_limit;
        }

        method finalize(context)
        {
            self.clearWindow(context);
        }
    }

    module Pane::Button::OK::Garage
    {
        method onActivate(context)
        {
            main::sound.play("ok");
            sResult = true;
            ROOT.close(context);

            return EVENTRESULT_FILTER;
        }    
    }

    module Pane::Button::OK::OK
    {
        method onActivate(context)
        {
            main::sound.play("ok");
            sResult = false;
            ROOT.close(context);
        
            return EVENTRESULT_FILTER;
        }        
    }
}