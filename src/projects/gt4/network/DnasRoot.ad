// NOTE: We put errors into a header, non-original, but where else to put it?
#include "dnas_error.h"

module PROJECT::ROOT
{
	static sDnas = nil;
	static sSkip = nil;
	static sInitializing = nil;

	function setBarActor(widget)
	{
		widget.x = -widget.w;
	
		var actor = main::menu::MMoveActor(widget, PS2_SCREEN_W_F, widget.y);
		widget.actor = actor;
	
		widget.actor.ratio = 0.01;
		widget.actor.repeat = true;
		widget.actor.flip = false;
		widget.actor.linear = true;
		widget.actor.out = false;
	
		widget.actor.warp();
		widget.actor.out = true;
	}
	
	setBarActor(bar);

	function StrError(context, errno)
	{
		var showFooter = false;
		var str;
	
		switch (errno)
		{
			case sceDNAS2_SS_SERVER_BUSY:
				str = context.translate(ROOT, "SS_SERVER_BUSY");
				break;
	
			case sceDNAS2_SS_BEFORE_SERVICE:
				str = context.translate(ROOT, "SS_BEFORE_SERVICE");
				showFooter = true;
				break;
	
			case sceDNAS2_SS_OUT_OF_SERVICE:
				str = context.translate(ROOT, "SS_OUT_OF_SERVICE");
				showFooter = true;
				break;
	
			case sceDNAS2_SS_END_OF_SERVICE:
				str = context.translate(ROOT, "SS_END_OF_SERVICE");
				showFooter = true;
				break;
	
			case sceDNAS2_SS_SESSION_TIME_OUT:
				str = context.translate(ROOT, "SS_SESSION_TIME_OUT");
				break;
	
			case sceDNAS2_SS_INVALID_SERVER:
				str = context.translate(ROOT, "SS_INVALID_SERVER");
				showFooter = true;
				break;
	
			case sceDNAS2_SS_INTERNAL_ERROR:
				str = context.translate(ROOT, "SS_INTERNAL_ERROR");
				showFooter = true;
				break;
	
			case sceDNAS2_SS_EXTERNAL_ERROR:
				str = context.translate(ROOT, "SS_EXTERNAL_ERROR");
				showFooter = true;
				break;
	
			case sceDNAS2_SS_INVALID_PS2:
			case sceDNAS2_SS_INVALID_HDD_BINDING:
				str = context.translate(ROOT, "SS_INVALID_HW");
				showFooter = true;
				break;
	
			case sceDNAS2_SS_INVALID_MEDIA:
			case sceDNAS2_SS_INVALID_AUTHDATA:
				str = context.translate(ROOT, "SS_INVALID_MEDIA");
				showFooter = true;
				break;
	
			case sceDNAS2_ERR_GLUE_ABORT:
				str = context.translate(ROOT, "GLUE_ABORT");
				break;
	
			case sceDNAS2_ERR_NET_PROXY:
				str = context.translate(ROOT, "NET_PROXY");
				break;
				
			case sceDNAS2_ERR_NET_ETIMEOUT:
			case sceDNAS2_ERR_NET_TIMEOUT:
				str = context.translate(ROOT, "NET_TIMEOUT");
				break;
	
			case sceDNAS2_ERR_NET_DNS_TRY_AGAIN:
				str = context.translate(ROOT, "DNS_TRY_AGAIN");
				break;
	
			case sceDNAS2_ERR_NET_DNS_HOST_NOT_FOUND:
			case sceDNAS2_ERR_NET_DNS_NO_RECOVERY:
			case sceDNAS2_ERR_NET_DNS_NO_DATA:
				str = context.translate(ROOT, "DNS_COMMON");
				break;
	
			case sceDNAS2_ERR_NET_DNS_OTHERS:
				str = context.translate(ROOT, "DNS_OTHERS");
				break;
	
			case sceDNAS2_ERR_NET_SSL:
			case sceDNAS2_ERR_NET_EISCONN:
			case sceDNAS2_ERR_NET_ECONNREFUSED:
			case sceDNAS2_ERR_NET_ENETUNREACH:
			case sceDNAS2_ERR_NET_ENOTCONN:
			case sceDNAS2_ERR_NET_ECONNRESET:
				str = context.translate(ROOT, "NET_SERVER");
				break;
	
			case sceDNAS2_ERR_NET_ENOBUFS:
			case sceDNAS2_ERR_NET_EMFILE:
			case sceDNAS2_ERR_NET_EBADF:
			case sceDNAS2_ERR_NET_EINVAL:
			case sceDNAS2_ERR_NET_OTHERS:
				str = context.translate(ROOT, "NET_COMM");
				break;
	
			default:
				str = context.translate(ROOT, "OTHER");
				if (errno <= -800)
					showFooter = true;
				break;
		}
	
		if (showFooter)
		{
			footer.visible = true;
			footer["text"].text = context.translate(DnasRoot, "footer");
		}
	
		return str;
	}

	function OnFrame(context)
	{
		if (sSkip)
			return;
	
		if (sDnas.IsDone())
		{
			var error = sDnas.GetLastError();
		
			if (!error)
			{
				main::network.setDnasSignature(sDnas.GetId());
				DeleteWatcher();
				start_page(context, EntryRoot);
			}
			else
			{
				message["text"].text = "%d: %s".format(error, StrError(context, error));
				DeleteWatcher();
				bar.actor = nil;
				logo.visible = false;
			}
		}
	}

	function GetPassPhrase(code, ver)
	{
		var a = [];
	
		if (code == "dna")
		{
			if (ver == "beta")
			{
				a.push(0x40); a.push(0xBC); a.push(0x09); a.push(0xD5);
				a.push(0x53); a.push(0x35); a.push(0x9C); a.push(0xE0);
			}
		}
		else if (code == "dne")
		{
			if (ver == "beta")
			{
				a.push(0xE7); a.push(0x9A); a.push(0xAF); a.push(0x2F);
				a.push(0x09); a.push(0xD1); a.push(0xE7); a.push(0x99);
			}
		}
		else if (code == "dni")
		{
			if (ver == "beta")
			{
				a.push(0xAD); a.push(0x72); a.push(0xB8); a.push(0x7F);
				a.push(0x5F); a.push(0x9B); a.push(0xB1); a.push(0xB2);
			}
		}
	
		return a;
	}

	function OnInitialize(context)
	{
		var code = main::menu::MSystem::GetDnasCode();
		var ver  = main::menu::MSystem::GetVersionBranch();
	
		var filename = "/dnas/auth_" + code + "_" + ver + ".dat";
		var netconf = main::game.option.netconf;
		var success = false;
	
		if (netconf.use_proxy)
			success = sDnas.Initialize(filename, GetPassPhrase(code, ver), netconf.proxy, netconf.proxy_port);
		else
			success = sDnas.Initialize(filename, GetPassPhrase(code, ver));
	
		if (success)
		{
			success = sDnas.RequestId();
	
			if (success)
			{
				sSkip = false;
				CreateWatcher(context, OnFrame, 2);
			}
		}
	
		if (!success)
		{
			var error = sDnas.GetLastError();
			message["text"].text = "%d: %s".format(error, StrError(context, error));
		}
	
		sInitializing = nil;
	}

	function onInitialize(context)
	{
		sInitializing = true;
		logo.visible = true;
		footer.visible = false;

		mark::TextFace.text = context.translate(DnasRoot, "notice");
		message["text"].text = context.translate(DnasRoot, "AUTH");
		tip::TextFace.text = context.translate(ConnectingRoot, "TOOLTIP|Cancel");

		sDnas = main::menu::MDnas();

		var event = main::menu::MScriptEvent(context, DnasRoot, "OnInitialize");
		context.pushEvent(event);
	}
	
	function onFinalize(context)
	{
		DeleteWatcher();
		sDnas = nil;
		sSkip = nil;
		sInitializing = nil;
	}
	
	function onCancel(context)
	{
		if (sInitializing != nil)
			return EVENTRESULT_FILTER;
	
		main::sound.play("cancel");

		sSkip = true;
		DeleteWatcher();
		sDnas.Abort();
		quit(context);
		sSkip = false;
		
		return EVENTRESULT_FILTER;
	}
}