module PROJECT::ROOT
{
	static last_stand = false;

	function normalize(value, min, max)
	{
		return (value - min) / (max - min);
	}
	
	function unnormalize(value, min, max)
	{
		return value * (max - min) + min;
	}

	import main::menu::MUtility::GetFormatString;

	function format_int(value)
	{
		var f = value;
	
		if (f < 0.0)
			f -= 0.5;

		if (f > 0.0)
			f += 0.5;
		
		// COMPILER NOTE: Not actual return?
		return f.toInt().toString();
	}
	
	function format_int10(value)
	{
		var f = value * 10.0;
	
		if (f < 0.0)
			f -= 0.5;

		if (f > 0.0)
			f += 0.5;
	
		// COMPILER NOTE: Not actual return?
		return GetFormatString("%.1t", f.toInt());
	}


	function fov_step(slider, fac)
	{
		var x = slider.value - slider.repeat_start;
	
		if (x < 0.0)
			x = -x;
	
		var len = slider.max - slider.min;
		x /= len;
	
		// COMPILER NOTE: Not actual return?
		return (0.002 + x) * fac;
	}
	
	function aperture_step(slider)
	{
		var x = slider.value - slider.repeat_start;
	
		if (x < 0.0)
			x = -x;
	
		var len = slider.max - slider.min;
		x /= len;
	
		// COMPILER NOTE: Not actual return?
		return 0.1 + (x * 5.0);
	}

	function zoom_step(slider)
	{
		var x = slider.value - slider.repeat_start;
	
		if (x < 0.0)
			x = -x;
	
		x /= (slider.max - slider.min);
	
		// COMPILER NOTE: Not actual return?
		return 1.0 + (x * 10.0);
	}
	
	function onLoad(context)
	{
		Map::PM::setCarArrow(context, 0);
		Map::PM::setCameraArrow(context, 0);
	}

	function onInitialize(context)
	{
		Panel::Orbit.can_focus = false;
		Panel::Orbit.visible = false;
	
		if (ROOT.focus_widget == nil)
			ROOT.focus_widget = Panel::Pan;
	
		setStand(last_stand);
		Panel::FocalLen::Reset();
		Panel::Aperture::Reset(context);
	
		Map::PM::zoom.repeat_start = Map::PM::zoom.value;
		Map::PM::zoom::onValueChanged(context, Map::PM::zoom);
		Map::PM::zoom.popup = true;
	
		ROOT::Panel::ManualFocus::Reset();
		ROOT::Panel::Mode::Reset();
	
		context.pushEvent(main::menu::MFunctionEvent(set_navi, context));
	}
	
	function set_navi(context)
	{
		context.sync();
		Map::PM::set_navigate_box(0);
	}

	function setStand(flg)
	{
		var option = main::game.option;
		var asp = option.photo_aspect;
		var widget = nil;
	
		if (flg)
		{
			switch (asp)
			{
				case "16x9":
					widget = View::Stand16_9;
					break;

				case "3x2":
					widget = View::Stand3_2;
					break;

				case "1x1":
#ifdef GT4O_US_BETA
					widget = View::A1_1;
#else
					widget = View["1_1"];
#endif
					break;

				default:
					widget = View::StandViewArea;
					break;
			}
		}
		else
		{
			switch (asp)
			{
				case "16x9":
					widget = View::Lay16_9;
					break;

				case "3x2":
					widget = View::Lay3_2;
					break;

				case "1x1":
#ifdef GT4O_US_BETA
					widget = View::A1_1;
#else
					widget = View["1_1"];
#endif
					break;

				default:
					widget = View::LayViewArea;
					break;
			}
		}
	
		View::PV.x = widget.x;
		View::PV.y = widget.y;
		View::PV.w = widget.w;
		View::PV.h = widget.h;
	
		Panel::Lay.active = !flg;
		Panel::Stand.active = flg;
		Map::PM.stand = flg;
	}

	function onCancel(context, event, item)
	{
		return EVENTRESULT_FILTER;
	}
	
	import main::menu::MKeyPressEvent;
	import main::menu::MKeyReleaseEvent;
	static before_widget = nil;
	static current_widget = nil;
	static grab = false;
	static map_view = false;
	static fov_popup = false;
	
	function onKeyPress(context, event)
	{
		if (map_view)
		{
			if (event.keysym == PS2_PAD_CTRL_L1 || event.keysym == PS2_PAD_CTRL_R1)
				return EVENTRESULT_STOP;

			switch (event.keysym)
			{
				case 0xFEE4: // XK_Pointer_UpLeft
				case 0xFEE6: // XK_Pointer_DownLeft
					event.keysym = PS2_PAD_CTRL_L3_LEFT;
					break;

				case 0xFEE5: // XK_Pointer_UpRight
				case 0xFEE7: // XK_Pointer_DownRight
					event.keysym = PS2_PAD_CTRL_L3_RIGHT;
					break;
			}

			return EVENTRESULT_CONTINUE;
		}
	
		if (!grab)
		{
			var state = context.getUpdateContext().getPadButtonState(0) & (0x100 | 0x200 | 0x800 | 0x1000);
	
			switch (event.keysym)
			{
				case PS2_PAD_CTRL_L1:
				case PS2_PAD_CTRL_L2:
				case PS2_PAD_CTRL_R1:
				case PS2_PAD_CTRL_R2:
				case PS2_PAD_CTRL_CROSS:
					var focus_widget = nil;
					if (event.keysym == PS2_PAD_CTRL_CROSS)
					{
						switch (ROOT.focus_widget)
						{
							case Panel::Pan:
								state = 0x100;
								grab = true;
								break;

							case Panel::Roll:
								state = 0x200;
								grab = true;
								break;

							case Panel::Move:
								state = 0x800;
								grab = true;
								break;

							case Panel::Climb:
								state = 0x1000;
								grab = true;
								break;
						}
					}
					
					if (state == 0x100)
					{
						focus_widget = ROOT::Panel::Pan;
						Map::PM.operate_mode = "pan";
					}
					else if (state == 0x200)
					{
						focus_widget = ROOT::Panel::Roll;
						Map::PM.operate_mode = "roll";
					}
					else if (state == 0x800)
					{
						focus_widget = ROOT::Panel::Move;
						Map::PM.operate_mode = "move";
					}
					else if (state == 0x1000)
					{
						focus_widget = ROOT::Panel::Climb;
						Map::PM.operate_mode = "climb";
					}
					else if (state == (0x100 | 0x200))
					{
						focus_widget = ROOT::Map::PM::zoom;
						Map::PM.operate_mode = "none";
					}
					else if (state == (0x800 | 0x1000))
					{
						focus_widget = ROOT::Panel::FocalLen;
						Map::PM.operate_mode = "none";
					
						if (!fov_popup)
						{
							fov_popup.value = true;
							if (!focus_widget.popup)
								context.pushEvent(MKeyPressEvent(context, focus_widget, PS2_PAD_CTRL_CROSS, 1, 0, 0, 0));
						}
					}
				
					if (focus_widget != nil)
					{
						if (focus_widget != current_widget)
						{
							if (current_widget != nil)
								current_widget.active = false;
						
							current_widget = focus_widget;
						
							if (current_widget != nil)
							{
								current_widget.active = true;
							
								if (before_widget == nil)
									before_widget = ROOT.focus_widget;
								
								ROOT.focus_widget = current_widget;
								main::sound.play("cursor");
							}
						}
					}
					break;
			}
		}
	
		// COMPILER NOTE: Not actual return?
		return current_widget != nil ? EVENTRESULT_STOP : EVENTRESULT_CONTINUE;
	}

	function onKeyRelease(context, event)
	{
		if (map_view)
		{
			if (event.keysym == PS2_PAD_CTRL_L1 || event.keysym == PS2_PAD_CTRL_R1)
				return EVENTRESULT_STOP;

			return EVENTRESULT_CONTINUE;
		}
	
		var state = context.getUpdateContext().getPadButtonState(0) &
			(0x100 | 0x200 | 0x800 | 0x1000 | 0x80 | 0x20);
	
		if (event.keysym == PS2_PAD_CTRL_CROSS)
		{
			grab = false;
		}
	
		if (!grab)
		{
			switch (event.keysym)
			{
				case PS2_PAD_CTRL_L1:
				case PS2_PAD_CTRL_L2:
				case PS2_PAD_CTRL_R1:
				case PS2_PAD_CTRL_R2:
				case PS2_PAD_CTRL_CROSS:
					var focus_widget = nil;
					if (state == 0x100)
					{
						focus_widget = ROOT::Panel::Pan;
						Map::PM.operate_mode = "pan";
					}
					else if (state == 0x200)
					{
						focus_widget = ROOT::Panel::Roll;
						Map::PM.operate_mode = "roll";
					}
					else if (state == 0x800)
					{
						focus_widget = ROOT::Panel::Move;
						Map::PM.operate_mode = "move";
					}
					else if (state == 0x1000)
					{
						focus_widget = ROOT::Panel::Climb;
						Map::PM.operate_mode = "climb";
					}
					else if (state == (0x100 | 0x200))
					{
						focus_widget = ROOT::Map::PM::zoom;
						Map::PM.operate_mode = "none";
					}
					else if (state == (0x800 | 0x1000))
					{
						focus_widget = ROOT::Panel::FocalLen;
						Map::PM.operate_mode = "none";
					}

					if (state != (0x800 | 0x1000))
					{
						var fov = Panel::FocalLen
						if (fov_popup)
						{
							if (fov.popup)
								context.pushEvent(MKeyPressEvent(context, fov, PS2_PAD_CTRL_CROSS, 1, 0, 0, 0));

							fov_popup.value = false;
						}
					}

					if (before_widget != nil)
					{
						if (focus_widget != current_widget)
						{
							if (current_widget != nil)
								current_widget.active = false;

							current_widget = focus_widget;
							
							if (current_widget != nil)
							{
								current_widget.active = true;
								ROOT.focus_widget = focus_widget;
								main::sound.play("cursor");
							}
							else
							{

								Map::PM.operate_mode = "none";	
								ROOT.focus_widget = before_widget;
								before_widget = nil;
							}
						}
					}
					else
					{
						Map::PM.operate_mode = "none";
					}

					break;
			}
		}

		// COMPILER NOTE: Not actual return?
		return current_widget != nil ? true : false;
	}
}

module PROJECT::ROOT::Map::PM
{
	static last_event_mask = 0;

	function onFocusOff(context)
	{
		main::sound.play("cursor");
	
		context.cursor = "normal";
	
		car::body.active = false;
		camera::body.active = false;
	
		PM.operate_mode = "map_zoom";
	
		context.event_mask = last_event_mask;
		context.cursor_visible = true;
	
		ToolTip::tooltip.key = "MapView_description";
		return EVENTRESULT_FILTER;
	}

	function setCarArrow(context, flg)
	{
		car::body::bga0.visible = !flg;
		car::body::bg.visible   = !flg;
		car::body::bga.visible  = !flg;
		car::shadow::bg.visible = !flg;
	
		car::body::arrow.visible   = flg;
		car::shadow::arrow.visible = flg;
	
		car::bgi.visible = !flg;
	}

	function setCameraArrow(context, flg)
	{
		camera::body::bga0.visible   = !flg;
		camera::body::bg.visible     = !flg;
		camera::body::bga.visible    = !flg;
		camera::shadow::bg.visible   = !flg;
	
		camera::body::arrow.visible   = flg;
		camera::shadow::arrow.visible = flg;
	
		camera::bgi.visible = !flg;
	}

	function setViewAngleRange(context, min, max)
	{
	}

	function setViewAngle(context, value)
	{
	}

	function onPhotoViewDisable(context, disable)
	{
		View.insensitive = disable;
	}

	function set_navigate_box(in)
	{
		if (in)
		{
			car::body.navigate_box    = [ -254, -36, 48 + 254, 48 + 36 ];
			camera::body.navigate_box = [ -254, -36, 48 + 254, 48 + 36 ];
		}
		else
		{
			// Centers of car and camera
			var px = (car.x + (car.w * 0.5));
			var py = (car.y + (car.h * 0.5));
			var qx = (camera.x + (camera.w * 0.5));
			var qy = (camera.y + (camera.h * 0.5));
			
			// Absolute deltas
			var dx = (px - qx);
			var dy = (py - qy);
			if (dx < 0.0) dx = -dx;
			if (dy < 0.0) dy = -dy;
			
			// Split mode: horizontal vs vertical
			var s = false;
			if (dx > dy)
				s = true;
			
			// Midpoint between centers
			var cx = ((px + qx) * 0.5);
			var cy = ((py + qy) * 0.5);
			
			// Primary/secondary actors and their bodies
			var a = camera;
			var b = car;
			var a_body = camera::body;
			var b_body = car::body;
			
			// If the car center is above the camera center, swap roles
			if (py < qy)
			{
				a = car;
				b = camera;
				a_body = car::body;
				b_body = camera::body;
			}
		
			// Build navigate box for "a"
			var x0 = 0.0;
			var y0 = (-a.y);
			var x1 = a.w;
			var y1 = (s ? (PM.h - a.y) : (cy - a.y));
			a_body.navigate_box = [ x0, y0, x1, y1 ];
		
			// Build navigate box for "b"
			x0 = 0.0;
			y0 = (s ? (-b.y) : (cy - b.y));
			x1 = b.w;
			y1 = (PM.h - b.y);
			b_body.navigate_box = [ x0, y0, x1, y1 ];
		}
	}
}

module PROJECT::ROOT::Map::PM::car::body
{
	function onFocusEnter(context, event)
	{
		if (PM.operate_mode == "none")
		{
			PM.operate_mode = "map_zoom";
			ROOT::map_view.value = true;
			ToolTip::tooltip.key = "MapView_description";
		}
	
		set_navigate_box(true /* in */);

		// COMPILER NOTE: Not actual return?
		return EVENTRESULT_STOP;
	}

	function onFocusLeave(context, event)
	{
		if (PM.operate_mode == "map_zoom")
		{
			PM.operate_mode = "none";
			ROOT::map_view.value = false;
			ToolTip::tooltip.key = "";
		}
	
		set_navigate_box(false /* in */);

		// COMPILER NOTE: Not actual return?
		return EVENTRESULT_STOP;
	}

	function onActivate(context, event, item)
	{
		main::sound.play("cursor");
	
		context.cursor = "";
		PM.operate_mode = "car";
		body.active = true;
	
		PM::last_event_mask.value = context.event_mask;
		context.event_mask = 0;
		context.cursor_visible = false;
	
		ToolTip::tooltip.key = "MapView_description_car";
	
		return EVENTRESULT_FILTER;
	}
}

module PROJECT::ROOT::Map::PM::camera::body
{
	function onFocusEnter(context, event)
	{
		if (PM.operate_mode == "none")
		{
			PM.operate_mode = "map_zoom";
			ROOT::map_view.value = true;
			ToolTip::tooltip.key = "MapView_description";
		}
	
		set_navigate_box(true, /* in */);

		// COMPILER NOTE: Not actual return?
		return true;
	}

	function onFocusLeave(context, event)
	{
		if (PM.operate_mode == "map_zoom")
		{
			PM.operate_mode = "none";
			ROOT::map_view.value = false;
			ToolTip::tooltip.key = "";
		}
	
		set_navigate_box(false /* in */);

		// COMPILER NOTE: Not actual return?
		return true;
	}

	function onActivate(context, event, item)
	{
		main::sound.play("cursor");
	
		context.cursor = "";
		PM.operate_mode = "camera";
		body.active = true;
	
		PM::last_event_mask.value = context.event_mask;
		context.event_mask = 0;
		context.cursor_visible = false;
	
		ToolTip::tooltip.key = "MapView_description";
	
		return EVENTRESULT_FILTER;
	}
}

module PROJECT::ROOT::Map::PM::zoom
{
	function onValueChanged(context, slider)
	{
		PM.setBaseLen(zoom.value);
	}
	
	function onStepChanged(context, slider)
	{
		zoom.step = zoom_step(zoom);
	}
}

module PROJECT::ROOT::Panel::FocalLen
{
	static last_professional = nil;

	function Cleanup()
	{
		last_professional = nil;
		popup::min.text = nil;
		popup::max.text = nil;
		popup::pinch::value.text = nil;
		label.text = nil;
	}


	function Reset()
	{
		var option = main::game.option;
		var professional = option.photo_professional;
	
		if (last_professional == nil)
		{
			last_professional = !professional;
	
			if (professional)
			{
				FocalLen.min = 16.0;
				FocalLen.max = 300.0;
				FocalLen.value = 70.0;
			}
			else
			{
				FocalLen.min = 1.0;
				FocalLen.max = 10.0;
	
				var value = normalize(70.0, 16.0, 300.0);
				FocalLen.value = FocalLen.min + value * (FocalLen.max - FocalLen.min);
			}
		}
	
		if (professional != last_professional)
		{
			if (professional)
			{
				var value = normalize(FocalLen.value, FocalLen.min, FocalLen.max);
	
				FocalLen.min = 16.0;
				FocalLen.max = 300.0;
				FocalLen.value = FocalLen.min + value * (FocalLen.max - FocalLen.min);
	
				FocalLen.current_value = FocalLen.value;
				FocalLen.repeat_start = FocalLen.value;
	
				FocalLen.step = fov_step(FocalLen, (FocalLen.max - FocalLen.min) / 4.0);
				popup::min.text = format_int(FocalLen.min);
				popup::max.text = format_int(FocalLen.max);
				popup::pinch::value.text = format_int(FocalLen.value);
				label.text = format_int(FocalLen.value) + "mm";
				Map::PM.view_angle = FocalLen.value;
			}
			else
			{
				var value = normalize(FocalLen.value, FocalLen.min, FocalLen.max);
	
				FocalLen.min = 1.0;
				FocalLen.max = 10.0;
				FocalLen.value = (FocalLen.min + value * (FocalLen.max - FocalLen.min));
	
				FocalLen.current_value = FocalLen.value;
				FocalLen.repeat_start = FocalLen.value;
				FocalLen.step = fov_step(FocalLen, (FocalLen.max - FocalLen.min) / 4.0);
	
				popup::min.text = format_int(FocalLen.min);
				popup::max.text = format_int(FocalLen.max);
				popup::pinch::value.text = format_int(FocalLen.value);
				label.text = format_int(FocalLen.value);
	
				// Map normalized slider back to mm for the map view angle
				var value = normalize(FocalLen.value, FocalLen.min, FocalLen.max);
				Map::PM.view_angle = (16.0 + value * (300.0 - 16.0));
			}
		}
		last_professional = professional;
	}

	function onValueChanged(context)
	{
		var option = main::game.option;
		var professional = option.photo_professional;
	
		if (professional)
		{
			popup::pinch::value.text = format_int(FocalLen.value);
			label.text = format_int(FocalLen.value) + "mm";
			Map::PM.view_angle = FocalLen.value;
		}
		else
		{
			popup::pinch::value.text = format_int(FocalLen.value);
			label.text = format_int(FocalLen.value);
	
			var value = normalize(FocalLen.value, FocalLen.min, FocalLen.max);
			Map::PM.view_angle = (16.0 + value * (300.0 - 16.0));
		}
	}

	function onStepChanged(context)
	{
		var option = main::game.option;
		var professional = option.photo_professional;
	
		if (professional)
		{
			FocalLen.step = fov_step(FocalLen, (FocalLen.max - FocalLen.min) / 4.0);
		}
		else
		{
			FocalLen.step = fov_step(FocalLen, (FocalLen.max - FocalLen.min) / 4.0);
		}
	}
}

module PROJECT::ROOT::Panel::Aperture
{
	static last_professional = nil;

	function Cleanup()
	{
		last_professional = nil;
		popup::min.text = nil;
		popup::max.text = nil;
		popup::pinch::value.text = nil;
		label.text = nil;
	}

	function Reset(context)
	{
		var option = main::game.option;
		var professional = option.photo_professional;
	
		// First-time init: seed last_professional opposite to force a refresh
		if (last_professional == nil)
		{
			last_professional = !professional;
	
			if (professional)
			{
				// Professional: F-number domain [1..16], default 7.5
				Aperture.min = 1.0;
				Aperture.max = 16.0;
				Aperture.value = 7.5;
			}
			else
			{
				// Non-professional: integer steps [1..10]
				Aperture.min = 1.0;
				Aperture.max = 10.0;
	
				// Start from pro default (7.5 on [1..16]) and remap into [1..10]
				var value = normalize(7.5, 1.0, 16.0); // 0..1
				Aperture.value = Aperture.min + value * (Aperture.max - Aperture.min);
			}
		}
	
		// If mode changed, remap values and refresh UI/mapping
		if (professional != last_professional)
		{
			if (professional)
			{
				// Remap current [min..max] → [1..16] continuously
				var value = 1.0 + normalize(Aperture.value, Aperture.min, Aperture.max) * (16.0 - 1.0);
	
				Aperture.min = 1.0;
				Aperture.max = 16.0;
				Aperture.value = value;
				Aperture.current_value = Aperture.value;
				Aperture.repeat_start = Aperture.value;
				Aperture.step = 1.0;
	
				// UI popups use mapped F-number labels in professional mode
				popup::min.text = format_int10(Map::PM.getAperture(context, 1.0));
				popup::max.text = format_int10(Map::PM.getAperture(context, 16.0));
	
				var ap = Map::PM.getAperture(context, value.toInt());
				popup::pinch::value.text = format_int10(ap);
				label.text = "F" + format_int10(ap);
	
				Map::PM.aperture = ap;
			}
			else
			{
				// Remap current [min..max] → normalized, then into [1..10]
				var value = normalize(Aperture.value, Aperture.min, Aperture.max);
	
				Aperture.min = 1.0;
				Aperture.max = 10.0;
				Aperture.value = Aperture.min + value * (Aperture.max - Aperture.min);
				Aperture.current_value = Aperture.value;
				Aperture.repeat_start = Aperture.value;
				Aperture.step = 1.0;
	
				// UI popups show plain integers in non-professional mode
				popup::min.text = format_int(Aperture.min);
				popup::max.text = format_int(Aperture.max);
				popup::pinch::value.text = format_int(Aperture.value);
				label.text = format_int(Aperture.value);
	
				// Still drive the underlying PM aperture via mapped [1..16]
				var value = 1.0 + normalize(Aperture.value, Aperture.min, Aperture.max) * (16.0 - 1.0);
				var ap = Map::PM.getAperture(context, value.toInt());
				Map::PM.aperture = ap;
			}
		}
	
		last_professional = professional;
	}

	function onValueChanged(context, slider)
	{
		var option = main::game.option;
		var professional = option.photo_professional;
	
		if (professional)
		{
			var i = Aperture.value.toInt();
			var ap = Map::PM.getAperture(context, i);
	
			Aperture.current_value = Aperture.value;
			Aperture.step = 1.0;
	
			popup::pinch::value.text = format_int10(ap);
			label.text = "F" + format_int10(ap);
			Map::PM.aperture = ap;
		}
		else
		{
			Aperture.current_value = Aperture.value;
			Aperture.step = 1.0;
	
			popup::pinch::value.text = format_int(Aperture.value);
			label.text = format_int(Aperture.value);
	
			var value = 1.0 + normalize(Aperture.value, Aperture.min, Aperture.max) * (16.0 - 1.0);
			Map::PM.aperture = value;
		}
	}
}
 
module PROJECT::ROOT::Panel::Pan
{
}

module PROJECT::ROOT::Panel::Roll
{
}

module PROJECT::ROOT::Panel::Move
{
}

module PROJECT::ROOT::Panel::Climb
{
}
 
 
module PROJECT::ROOT::Panel::Steering
{
	function onActivate(context, event, item)
	{
		main::sound.play("ok");
	
		var result = SteeringDialog::open(context, 0);
	
		if (result)
			SteeringDialog::Apply();
		else
			SteeringDialog::Cancel();
	
		SteeringDialog::Cleanup();
		return EVENTRESULT_FILTER;
	}
}

module PROJECT::ROOT::Panel::Filter
{
	function onActivate(context, event, item)
	{
		main::sound.play("ok");
	
		var result = FilterDialog::open(context, 0);
	
		if (result)
			FilterDialog::Apply();
		else
			FilterDialog::Cancel();
	
		FilterDialog::Cleanup();
		return EVENTRESULT_FILTER;
	}
}

module PROJECT::ROOT::Panel::Mode
{
	function Reset()
	{
		var option = main::game.option;
	
		Panel::ManualFocus.visible = option.photo_manual_focus;
		var professional = option.photo_professional;
	
		Panel::FocalLen::popup::bg.visible = true;
		Panel::FocalLen::popup::bg0.visible = false;
	
		var type = option.photo_shutter;
		main::game.loadShutterSound(type.downcase());
	}

	function onActivate(context, event, item)
	{
		main::sound.play("ok");
	
		var result = ModeDialog::open(context, 0);
	
		if (result)
		{
			ModeDialog::Apply();
			Reset();
			Panel::FocalLen::Reset();
			Panel::Aperture::Reset(context);
			ROOT::setStand(last_stand);
		}
		else
			ModeDialog::Cancel();
	
		ModeDialog::Cleanup(context);
		return EVENTRESULT_FILTER;
	}
}

module PROJECT::ROOT::Panel::Exit
{
	function onActivate(context, event, item)
	{
		main::sound.play("ok");
	
		var result = openConfirmDialog(context, DIALOG_QUERY, context.translate(ROOT, "Quit?"));
	
		if (result)
		{
			main::game.next_menu_project = main::game.major_menu_project;
			main::game.next_menu_arg = main::game.major_menu_page;
			main::game.menu_result = "exit";
			start_sequence(context, "menu");
		}
	
		return EVENTRESULT_FILTER;
	}
}

module PROJECT::ROOT::Panel::ManualFocus
{
	function setActor(widget)
	{
		widget.actor = main::menu::MBlinkActor(widget);
		widget.actor.period = 0.25;
	}


	function Reset()
	{
		setActor(ROOT::View::Focus::blink);
	
		View::Focus::fix.visible = true;
		View::Focus::blink.visible = false;
		View::Focus::active.visible = false;
	}

	function onEnter(context, event)
	{
		View::Focus::fix.visible = false;
		View::Focus::blink.visible = true;
		View::Focus::active.visible = false;
	}

	function onLeave(context, event)
	{
		View::Focus::fix.visible = true;
		View::Focus::blink.visible = false;
		View::Focus::active.visible = false;
	}

	function onActivate(context, event)
	{
		View::Focus::blink.visible = false;
		View::Focus::active.visible = true;
	
		main::sound.play("zoom1");
	
		for (var i = 0; i <= 35; i++)
		{
			var ii = i % 6;
			View::Focus::active.opacity = 0.2 * ii;
			context.sync();
		}
	
		main::sound.play("zoom");
	
		View::Focus::blink.visible = true;
		View::Focus::active.visible = false;
	
		ROOT::Map::PM.doFocus(context);
		return EVENTRESULT_FILTER;
	}

}

module PROJECT::ROOT::Panel::Shoot
{
	import main::menu::MActivateEvent;
	
	function onKeyPress(context, event)
	{
		// COMPILER NOTE: Is this actually returning?
		if (event.keysym == PS2_PAD_CTRL_CROSS)
		{
			Shoot.active = true;
			main::sound.play("shutter");
			return EVENTRESULT_STOP;
		}
		else if (event.keysym == PS2_PAD_CTRL_START)
			return EVENTRESULT_STOP;
		else if (Shoot.active)
			return EVENTRESULT_STOP;
		else
			return EVENTRESULT_CONTINUE;
	}

	function onKeyRelease(context, event)
	{
		// COMPILER NOTE: Is this actually returning?
		if ((event.keysym == PS2_PAD_CTRL_CROSS) && Shoot.active)
		{
			Shoot.active = false;
			context.pushEvent(MActivateEvent(context, Shoot));
			return EVENTRESULT_FILTER;
		}
		else if (event.keysym == PS2_PAD_CTRL_START)
			return EVENTRESULT_STOP;
		else
			return EVENTRESULT_CONTINUE;
	}

	function onActivate(context, event, item)
	{
		if (Map::PM.can_shoot)
		{
			var result = true;
	
			if (result)
			{
				context.sync(0.1);
				context.startPage(PreviewRoot);
			}
		}
		else
		{
			main::sound.play("disable");
			WarningDialog::open(context, context.translate(ROOT, "The car is not visible.Unable to take picture."));
		}
	
		return EVENTRESULT_FILTER;
	}
}

module PROJECT::ROOT::Panel::Aspect
{
	function onActivate(context, event, item)
	{
		main::sound.play("cursor");
	
		if (Panel::Lay.active)
			last_stand.value = true;
		else
			last_stand.value = false;
	
		ROOT::setStand(last_stand);
		return EVENTRESULT_FILTER;
	}
}